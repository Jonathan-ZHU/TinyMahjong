require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],2:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],3:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property
 *     on objects.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

function typedArraySupport () {
  function Bar () {}
  try {
    var arr = new Uint8Array(1)
    arr.foo = function () { return 42 }
    arr.constructor = Bar
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Bar && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    this.length = 0
    this.parent = undefined
  }

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined') {
    if (object.buffer instanceof ArrayBuffer) {
      return fromTypedArray(that, object)
    }
    if (object instanceof ArrayBuffer) {
      return fromArrayBuffer(that, object)
    }
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    array.byteLength
    that = Buffer._augment(new Uint8Array(array))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromTypedArray(that, new Uint8Array(array))
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
} else {
  // pre-set for values that may exist in the future
  Buffer.prototype.length = undefined
  Buffer.prototype.parent = undefined
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` is deprecated
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` is deprecated
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; i--) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":2,"ieee754":1,"isarray":4}],4:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],"Alert":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'c12553sxCxG/on0Bz7rkX0f', 'Alert');
// scripts/components/Alert.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _alert: null,
        _btnOK: null,
        _btnCancel: null,
        _title: null,
        _content: null,
        _onok: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }
        this._alert = cc.find("Canvas/alert");
        this._title = cc.find("Canvas/alert/title").getComponent(cc.Label);
        this._content = cc.find("Canvas/alert/content").getComponent(cc.Label);

        this._btnOK = cc.find("Canvas/alert/btn_ok");
        this._btnCancel = cc.find("Canvas/alert/btn_cancel");

        cc.vv.utils.addClickEvent(this._btnOK, this.node, "Alert", "onBtnClicked");
        cc.vv.utils.addClickEvent(this._btnCancel, this.node, "Alert", "onBtnClicked");

        this._alert.active = false;
        cc.vv.alert = this;
    },

    onBtnClicked: function onBtnClicked(event) {
        if (event.target.name == "btn_ok") {
            if (this._onok) {
                this._onok();
            }
        }
        this._alert.active = false;
        this._onok = null;
    },

    show: function show(title, content, onok, needcancel, okstr, cancelstr) {
        this._alert.active = true;
        this._onok = onok;
        this._title.string = title;
        this._content.string = content;
        if (needcancel) {
            this._btnCancel.active = true;
            this._btnOK.x = -150;
            this._btnCancel.x = 150;
        } else {
            this._btnCancel.active = false;
            this._btnOK.x = 0;
        }
        if (okstr) {
            this._btnOK.getChildByName("New Label").getComponent(cc.Label).string = okstr;
        }
        if (cancelstr) {
            this._btnCancel.getChildByName("New Label").getComponent(cc.Label).string = cancelstr;
        }
    },

    onDestory: function onDestory() {
        if (cc.vv) {
            cc.vv.alert = null;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"AnysdkMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'f58cea6lrpDZJSNs2BGBqxN', 'AnysdkMgr');
// scripts/AnysdkMgr.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _isCapturing: false
    },

    // use this for initialization
    onLoad: function onLoad() {},

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },


    init: function init() {
        this.ANDROID_API = "com/vivigames/scmj/WXAPI";
        this.IOS_API = "AppController";
        this.ANDROID_WEBPAGE_API = "org/cocos2dx/javascript/AppActivity";
    },

    openDownloadPage: function openDownloadPage() {
        console.log("open webpage!!!");
        console.log(cc.sys.os);
        console.log(cc.sys.OS_ANDROID);
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            console.log("open webpage OS_ANDROID!!!");
            jsb.reflection.callStaticMethod(this.ANDROID_WEBPAGE_API, "openDownloadPage", "(Ljava/lang/String;)V", cc.vv.SI.appweb);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod(this.IOS_API, "openDownloadPage");
        } else {
            console.log("platform:" + cc.sys.os + " dosn't implement share.");
        }
    },

    login: function login() {
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod(this.ANDROID_API, "Login", "()V");
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod(this.IOS_API, "login");
        } else {
            console.log("platform:" + cc.sys.os + " dosn't implement share.");
        }
    },

    share: function share(title, desc) {
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod(this.ANDROID_API, "Share", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V", cc.vv.SI.appweb, title, desc);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod(this.IOS_API, "share:shareTitle:shareDesc:", cc.vv.SI.appweb, title, desc);
        } else {
            console.log("platform:" + cc.sys.os + " dosn't implement share.");
        }
    },

    shareOnTimeline: function shareOnTimeline(title, desc) {
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod(this.ANDROID_API, "ShareOnTimeline", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V", cc.vv.SI.appweb, title, desc);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod(this.IOS_API, "sharetimeline:shareTitle:shareDesc:", cc.vv.SI.appweb, title, desc);
        } else {
            console.log("platform:" + cc.sys.os + " dosn't implement share.");
        }
    },

    copy: function copy(desc) {
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod(this.ANDROID_WEBPAGE_API, "Copy", "(Ljava/lang/String;)V", desc);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod(this.IOS_API, "copy:", desc);
        } else {
            console.log("platform:" + cc.sys.os + " dosn't implement share.");
        }
    },

    shareResult: function shareResult() {
        if (this._isCapturing) {
            return;
        }
        this._isCapturing = true;
        var size = cc.director.getWinSize();
        var currentDate = new Date();
        var fileName = "result_share.jpg";
        var fullPath = jsb.fileUtils.getWritablePath() + fileName;
        if (jsb.fileUtils.isFileExist(fullPath)) {
            jsb.fileUtils.removeFile(fullPath);
        }
        var texture = new cc.RenderTexture(Math.floor(size.width), Math.floor(size.height));
        texture.setPosition(cc.p(size.width / 2, size.height / 2));
        texture.begin();
        cc.director.getRunningScene().visit();
        texture.end();
        texture.saveToFile(fileName, cc.IMAGE_FORMAT_JPG);

        var self = this;
        var tryTimes = 0;
        var fn = function fn() {
            if (jsb.fileUtils.isFileExist(fullPath)) {
                var height = 100;
                var scale = height / size.height;
                var width = Math.floor(size.width * scale);

                if (cc.sys.os == cc.sys.OS_ANDROID) {
                    jsb.reflection.callStaticMethod(self.ANDROID_API, "ShareIMG", "(Ljava/lang/String;II)V", fullPath, width, height);
                } else if (cc.sys.os == cc.sys.OS_IOS) {
                    jsb.reflection.callStaticMethod(self.IOS_API, "shareIMG:width:height:", fullPath, width, height);
                } else {
                    console.log("platform:" + cc.sys.os + " dosn't implement share.");
                }
                self._isCapturing = false;
            } else {
                tryTimes++;
                if (tryTimes > 10) {
                    console.log("time out...");
                    return;
                }
                setTimeout(fn, 50);
            }
        };
        setTimeout(fn, 50);
    },

    onLoginResp: function onLoginResp(code) {
        var fn = function fn(ret) {
            if (ret.errcode == 0) {
                cc.sys.localStorage.setItem("wx_account", ret.account);
                cc.sys.localStorage.setItem("wx_sign", ret.sign);
            }
            cc.vv.userMgr.onAuth(ret);
        };
        cc.vv.http.sendRequest("/wechat_auth", { code: code, os: cc.sys.os }, fn);
    }
});

cc._RF.pop();
},{}],"AudioMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '55caepcpvFK5r0Ax5f8jss4', 'AudioMgr');
// scripts/AudioMgr.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        bgmVolume: 1.0,
        sfxVolume: 1.0,

        bgmAudioID: -1
    },

    // use this for initialization
    init: function init() {
        var t = cc.sys.localStorage.getItem("bgmVolume");
        if (t != null) {
            this.bgmVolume = parseFloat(t);
        }

        var t = cc.sys.localStorage.getItem("sfxVolume");
        if (t != null) {
            this.sfxVolume = parseFloat(t);
        }

        cc.game.on(cc.game.EVENT_HIDE, function () {
            console.log("cc.audioEngine.pauseAll");
            cc.audioEngine.pauseAll();
        });
        cc.game.on(cc.game.EVENT_SHOW, function () {
            console.log("cc.audioEngine.resumeAll");
            cc.audioEngine.resumeAll();
        });
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    getUrl: function getUrl(url) {
        return cc.url.raw("resources/sounds/" + url);
    },

    playBGM: function playBGM(url) {
        var audioUrl = this.getUrl(url);
        console.log(audioUrl);
        if (this.bgmAudioID >= 0) {
            cc.audioEngine.stop(this.bgmAudioID);
        }
        this.bgmAudioID = cc.audioEngine.play(audioUrl, true, this.bgmVolume);
    },
    playSFX: function playSFX(url) {
        var audioUrl = this.getUrl(url);
        if (this.sfxVolume > 0) {
            var audioId = cc.audioEngine.play(audioUrl, false, this.sfxVolume);
        }
    },


    setSFXVolume: function setSFXVolume(v) {
        if (this.sfxVolume != v) {
            cc.sys.localStorage.setItem("sfxVolume", v);
            this.sfxVolume = v;
        }
    },

    setBGMVolume: function setBGMVolume(v, force) {
        if (this.bgmAudioID >= 0) {
            if (v > 0) {
                cc.audioEngine.resume(this.bgmAudioID);
            } else {
                cc.audioEngine.pause(this.bgmAudioID);
            }
            //cc.audioEngine.setVolume(this.bgmAudioID,this.bgmVolume);
        }
        if (this.bgmVolume != v || force) {
            cc.sys.localStorage.setItem("bgmVolume", v);
            this.bgmVolume = v;
            cc.audioEngine.setVolume(this.bgmAudioID, v);
        }
    },

    pauseAll: function pauseAll() {
        cc.audioEngine.pauseAll();
    },

    resumeAll: function resumeAll() {
        cc.audioEngine.resumeAll();
    }
});

cc._RF.pop();
},{}],"Chat":[function(require,module,exports){
"use strict";
cc._RF.push(module, '58f27rxustNsYlRX3fryN8X', 'Chat');
// scripts/components/Chat.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _chatRoot: null,
        _tabQuick: null,
        _tabEmoji: null,
        _iptChat: null,

        _quickChatInfo: null,
        _btnChat: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        cc.vv.chat = this;

        this._btnChat = this.node.getChildByName("btn_chat");
        this._btnChat.active = cc.vv.replayMgr.isReplay() == false;

        this._chatRoot = this.node.getChildByName("chat");
        this._chatRoot.active = false;

        this._tabQuick = this._chatRoot.getChildByName("quickchatlist");
        this._tabEmoji = this._chatRoot.getChildByName("emojis");

        this._iptChat = this._chatRoot.getChildByName("iptChat").getComponent(cc.EditBox);

        this._quickChatInfo = {};
        this._quickChatInfo["item0"] = { index: 0, content: "快点啊，都等到我花儿都谢谢了！", sound: "fix_msg_1.mp3" };
        this._quickChatInfo["item1"] = { index: 1, content: "怎么又断线了，网络怎么这么差啊！", sound: "fix_msg_2.mp3" };
        this._quickChatInfo["item2"] = { index: 2, content: "不要走，决战到天亮！", sound: "fix_msg_3.mp3" };
        this._quickChatInfo["item3"] = { index: 3, content: "你的牌打得也太好了！", sound: "fix_msg_4.mp3" };
        this._quickChatInfo["item4"] = { index: 4, content: "你是妹妹还是哥哥啊？", sound: "fix_msg_5.mp3" };
        this._quickChatInfo["item5"] = { index: 5, content: "和你合作真是太愉快了！", sound: "fix_msg_6.mp3" };
        this._quickChatInfo["item6"] = { index: 6, content: "大家好，很高兴见到各位！", sound: "fix_msg_7.mp3" };
        this._quickChatInfo["item7"] = { index: 7, content: "各位，真是不好意思，我得离开一会儿。", sound: "fix_msg_8.mp3" };
        this._quickChatInfo["item8"] = { index: 8, content: "不要吵了，专心玩游戏吧！", sound: "fix_msg_9.mp3" };
    },

    getQuickChatInfo: function getQuickChatInfo(index) {
        var key = "item" + index;
        return this._quickChatInfo[key];
    },


    onBtnChatClicked: function onBtnChatClicked() {
        this._chatRoot.active = true;
    },

    onBgClicked: function onBgClicked() {
        this._chatRoot.active = false;
    },

    onTabClicked: function onTabClicked(event) {
        if (event.target.name == "tabQuick") {
            this._tabQuick.active = true;
            this._tabEmoji.active = false;
        } else if (event.target.name == "tabEmoji") {
            this._tabQuick.active = false;
            this._tabEmoji.active = true;
        }
    },

    onQuickChatItemClicked: function onQuickChatItemClicked(event) {
        this._chatRoot.active = false;
        var info = this._quickChatInfo[event.target.name];
        cc.vv.net.send("quick_chat", info.index);
    },

    onEmojiItemClicked: function onEmojiItemClicked(event) {
        console.log(event.target.name);
        this._chatRoot.active = false;
        cc.vv.net.send("emoji", event.target.name);
    },

    onBtnSendChatClicked: function onBtnSendChatClicked() {
        this._chatRoot.active = false;
        if (this._iptChat.string == "") {
            return;
        }
        cc.vv.net.send("chat", this._iptChat.string);
        this._iptChat.string = "";
    }

});

cc._RF.pop();
},{}],"CheckBox":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'dc9e5hcegFBFpbh0CwUFw8V', 'CheckBox');
// scripts/components/CheckBox.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        target: cc.Node,
        sprite: cc.SpriteFrame,
        checkedSprite: cc.SpriteFrame,
        checked: false
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.refresh();
    },

    onClicked: function onClicked() {
        this.checked = !this.checked;
        this.refresh();
    },

    switchToUnchecked: function switchToUnchecked() {
        this.checked = false;
        this.refresh();
    },

    refresh: function refresh() {
        var targetSprite = this.target.getComponent(cc.Sprite);
        if (this.checked) {
            targetSprite.spriteFrame = this.checkedSprite;
        } else {
            targetSprite.spriteFrame = this.sprite;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"CreateRole":[function(require,module,exports){
"use strict";
cc._RF.push(module, '5d56bFYy/REb77pQCq9YHh6', 'CreateRole');
// scripts/components/CreateRole.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        inputName: cc.EditBox
    },

    onRandomBtnClicked: function onRandomBtnClicked() {
        var names = ["上官", "欧阳", "东方", "端木", "独孤", "司马", "南宫", "夏侯", "诸葛", "皇甫", "长孙", "宇文", "轩辕", "东郭", "子车", "东阳", "子言"];

        var names2 = ["雀圣", "赌侠", "赌圣", "稳赢", "不输", "好运", "自摸", "有钱", "土豪"];
        var idx = Math.floor(Math.random() * (names.length - 1));
        var idx2 = Math.floor(Math.random() * (names2.length - 1));
        this.inputName.string = names[idx] + names2[idx2];
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = this.node.getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }
        this.onRandomBtnClicked();
    },

    onBtnConfirmClicked: function onBtnConfirmClicked() {
        var name = this.inputName.string;
        if (name == "") {
            console.log("invalid name.");
            return;
        }
        console.log(name);
        cc.vv.userMgr.create(name);
    }
    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"CreateRoom":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'eec07HsL4pBn5/PiT3SYBew', 'CreateRoom');
// scripts/components/CreateRoom.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        _leixingxuanze: null,
        _koufei: null,
        _quanshu: null,
        _jiesuan: null,
        _wanfaxuanze: null,
        _types: [], //定义多种游戏类型 
        _sjmmj_jifei: 0, //房主出资 or 玩家平分
        _sjmmj_jushu: 0, //8盘 or 1圈
        _dhmj_jifei: 0,
        _dhmj_jushu: 0,
        _tdh_jifei: 0,
        _tdh_jushu: 0
    },

    // use this for initialization
    onLoad: function onLoad() {
        //有多种玩法，沈家门麻将 定海麻将 推到胡麻将
        this._types = ["sjmmj", "dhmj", "tdh"];

        //隐藏除第一种外的其他玩法 界面
        for (var i = 1; i < this._types.length; i++) {
            this.node.getChildByName(this._types[i]).active = false;
        }

        //房主开8局 3砖  平摊每个人1砖
        //房主开一圈 6砖   平摊每个人 2砖
        //初始化计费
    },

    onBtnBack: function onBtnBack() {
        this.node.active = false;
    },

    onBtnOK: function onBtnOK(event) {
        this.node.active = false;
        //确定游戏类型
        var type = event.target.parent.name;
        //分别进入不同的创建逻辑
        //TODO：让添加一个游戏和规则更加方便
        if (type == "sjmmj") {
            this.createRoomSJMMJ();
        } else if (type == "dhmj") {
            this.createRoomDHMJ();
        } else if (type == "tdh") {
            this.createRoomTDH();
        }
    },

    onTypeClicked: function onTypeClicked(event) {
        this.switchType(event.target.parent.children[1].name);
    },

    onSJMMJfangzhuClicked: function onSJMMJfangzhuClicked(event) {
        this._sjmmj_jifei = 0;
        var cost = 1;
        if (this._sjmmj_jifei == 0) cost = 3;else cost = 1;
        if (this._sjmmj_jushu == 0) cost = cost;else cost *= 2;
        cc.find("Canvas/CreateRoom/sjmmj/cost/number").getComponent(cc.Label).string = "×" + cost;
    },
    onSJMMJwanjiaClicked: function onSJMMJwanjiaClicked(event) {
        this._sjmmj_jifei = 1;
        var cost = 1;
        if (this._sjmmj_jifei == 0) cost = 3;else cost = 1;
        if (this._sjmmj_jushu == 0) cost = cost;else cost *= 2;
        cc.find("Canvas/CreateRoom/sjmmj/cost/number").getComponent(cc.Label).string = "×" + cost;
    },
    onSJMMJ8panClicked: function onSJMMJ8panClicked(event) {
        this._sjmmj_jushu = 0;
        var cost = 1;
        if (this._sjmmj_jifei == 0) cost = 3;else cost = 1;
        if (this._sjmmj_jushu == 0) cost = cost;else cost *= 2;
        cc.find("Canvas/CreateRoom/sjmmj/cost/number").getComponent(cc.Label).string = "×" + cost;
    },
    onSJMMJ1quanClicked: function onSJMMJ1quanClicked(event) {
        this._sjmmj_jushu = 1;
        var cost = 1;
        if (this._sjmmj_jifei == 0) cost = 3;else cost = 1;
        if (this._sjmmj_jushu == 0) cost = cost;else cost = 2 * cost;
        cc.find("Canvas/CreateRoom/sjmmj/cost/number").getComponent(cc.Label).string = "×" + cost;
    },

    onDHMJfangzhuClicked: function onDHMJfangzhuClicked(event) {
        this._dhmj_jifei = 0;
        var cost = 1;
        if (this._dhmj_jifei == 0) cost = 3;else cost = 1;
        if (this._dhmj_jushu == 0) cost = cost;else cost *= 2;
        cc.find("Canvas/CreateRoom/dhmj/cost/number").getComponent(cc.Label).string = "×" + cost;
    },
    onDHMJwanjiaClicked: function onDHMJwanjiaClicked(event) {
        this._dhmj_jifei = 1;
        var cost = 1;
        if (this._dhmj_jifei == 0) cost = 3;else cost = 1;
        if (this._dhmj_jushu == 0) cost = cost;else cost *= 2;
        cc.find("Canvas/CreateRoom/dhmj/cost/number").getComponent(cc.Label).string = "×" + cost;
    },
    onDHMJ8panClicked: function onDHMJ8panClicked(event) {
        this._dhmj_jushu = 0;
        var cost = 1;
        if (this._dhmj_jifei == 0) cost = 3;else cost = 1;
        if (this._dhmj_jushu == 0) cost = cost;else cost *= 2;
        cc.find("Canvas/CreateRoom/dhmj/cost/number").getComponent(cc.Label).string = "×" + cost;
    },
    onDHMJ1quanClicked: function onDHMJ1quanClicked(event) {
        this._dhmj_jushu = 1;
        var cost = 1;
        if (this._dhmj_jifei == 0) cost = 3;else cost = 1;
        if (this._dhmj_jushu == 0) cost = cost;else cost *= 2;
        cc.find("Canvas/CreateRoom/dhmj/cost/number").getComponent(cc.Label).string = "×" + cost;
    },

    onTDHfangzhuClicked: function onTDHfangzhuClicked(event) {
        this._tdh_jifei = 0;
        var cost = 1;
        if (this._tdh_jifei == 0) cost = 3;else cost = 1;
        if (this._tdh_jushu == 0) cost = cost;else cost *= 2;
        cc.find("Canvas/CreateRoom/tdh/cost/number").getComponent(cc.Label).string = "×" + cost;
    },
    onTDHwanjiaClicked: function onTDHwanjiaClicked(event) {
        this._tdh_jifei = 1;
        var cost = 1;
        if (this._tdh_jifei == 0) cost = 3;else cost = 1;
        if (this._tdh_jushu == 0) cost = cost;else cost *= 2;
        cc.find("Canvas/CreateRoom/tdh/cost/number").getComponent(cc.Label).string = "×" + cost;
    },
    onTDH8panClicked: function onTDH8panClicked(event) {
        this._tdh_jushu = 0;
        var cost = 1;
        if (this._tdh_jifei == 0) cost = 3;else cost = 1;
        if (this._tdh_jushu == 0) cost = cost;else cost *= 2;
        cc.find("Canvas/CreateRoom/tdh/cost/number").getComponent(cc.Label).string = "×" + cost;
    },
    onTDH1quanClicked: function onTDH1quanClicked(event) {
        this._tdh_jushu = 1;
        var cost = 1;
        if (this._tdh_jifei == 0) cost = 3;else cost = 1;
        if (this._tdh_jushu == 0) cost = cost;else cost *= 2;
        cc.find("Canvas/CreateRoom/tdh/cost/number").getComponent(cc.Label).string = "×" + cost;
    },

    //tab界面切换
    switchType: function switchType(type) {
        for (var i = 0; i < this._types.length; i++) {
            this.node.getChildByName(this._types[i]).active = false;
        }
        this.node.getChildByName(type).active = true;
    },

    createRoomSJMMJ: function createRoomSJMMJ() {

        //获取需要的所有选项

        //这里一定要小写，后端会直接拼接这个字符串
        var type = "sjmmj";

        this._koufei = [];
        var t = this.node.getChildByName(type).getChildByName("koufei");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._koufei.push(n);
            }
        }

        this._quanshu = [];
        var t = this.node.getChildByName(type).getChildByName("quanshu");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._quanshu.push(n);
            }
        }

        this._jiesuan = [];
        var t = this.node.getChildByName(type).getChildByName("jiesuan");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._jiesuan.push(n);
            }
        }

        this._wanfaxuanze = [];
        var t = this.node.getChildByName(type).getChildByName("wanfaxuanze");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("CheckBox");
            if (n != null) {
                this._wanfaxuanze.push(n);
            }
        }

        var self = this;
        var onCreate = function onCreate(ret) {
            if (ret.errcode !== 0) {
                cc.vv.wc.hide();
                //console.log(ret.errmsg);
                if (ret.errcode == 2222) {
                    cc.vv.alert.show("提示", "房卡不足，创建房间失败!");
                } else {
                    cc.vv.alert.show("提示", "创建房间失败,错误码:" + ret.errcode);
                }
            } else {
                cc.vv.gameNetMgr.connectGameServer(ret);
            }
        };

        var hongzhongdanghua = self._wanfaxuanze[0].checked;

        var koufei = 0;
        for (var i = 0; i < self._koufei.length; ++i) {
            if (self._koufei[i].checked) {
                koufei = i;
                break;
            }
        }

        var quanshu = 0;
        for (var i = 0; i < self._quanshu.length; ++i) {
            if (self._quanshu[i].checked) {
                quanshu = i;
                break;
            }
        }

        var jiesuan = 0;
        for (var i = 0; i < self._jiesuan.length; ++i) {
            if (self._jiesuan[i].checked) {
                jiesuan = i;
                break;
            }
        }

        var conf = {
            type: type,
            hongzhongdanghua: hongzhongdanghua,
            koufei: koufei,
            quanshu: quanshu,
            jiesuan: jiesuan
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            conf: JSON.stringify(conf)
        };
        cc.vv.wc.show("正在创建房间");
        cc.vv.http.sendRequest("/create_private_room", data, onCreate);
    },

    createRoomDHMJ: function createRoomDHMJ() {

        //获取需要的所有选项
        //这里一定要小写，后端会直接拼接这个字符串
        var type = "dhmj";

        this._koufei = [];
        var t = this.node.getChildByName(type).getChildByName("koufei");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._koufei.push(n);
            }
        }

        this._quanshu = [];
        var t = this.node.getChildByName(type).getChildByName("quanshu");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._quanshu.push(n);
            }
        }

        this._jiesuan = [];
        var t = this.node.getChildByName(type).getChildByName("jiesuan");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._jiesuan.push(n);
            }
        }

        var self = this;
        var onCreate = function onCreate(ret) {
            if (ret.errcode !== 0) {
                cc.vv.wc.hide();
                if (ret.errcode == 2222) {
                    cc.vv.alert.show("提示", "房卡不足，创建房间失败!");
                } else {
                    cc.vv.alert.show("提示", "创建房间失败,错误码:" + ret.errcode);
                }
            } else {
                cc.vv.gameNetMgr.connectGameServer(ret);
            }
        };

        //判断用户做了哪些选择
        //扣费 0 房主出资 1 玩家平分
        //圈数 0 8盘 1 一圈
        //结算 0 50  1 120

        var koufei = 0;
        for (var i = 0; i < self._koufei.length; ++i) {
            if (self._koufei[i].checked) {
                koufei = i;
                break;
            }
        }

        var quanshu = 0;
        for (var i = 0; i < self._quanshu.length; ++i) {
            if (self._quanshu[i].checked) {
                quanshu = i;
                break;
            }
        }

        var jiesuan = 0;
        for (var i = 0; i < self._jiesuan.length; ++i) {
            if (self._jiesuan[i].checked) {
                jiesuan = i;
                break;
            }
        }

        var conf = {
            type: type,
            koufei: koufei,
            quanshu: quanshu,
            jiesuan: jiesuan
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            conf: JSON.stringify(conf)
        };
        console.log(data);
        cc.vv.wc.show("正在创建房间");
        cc.vv.http.sendRequest("/create_private_room", data, onCreate);
    },

    createRoomTDH: function createRoomTDH() {

        //获取需要的所有选项
        //这里一定要小写，后端会直接拼接这个字符串
        var type = "tdh";

        this._koufei = [];
        var t = this.node.getChildByName(type).getChildByName("koufei");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._koufei.push(n);
            }
        }

        this._quanshu = [];
        var t = this.node.getChildByName(type).getChildByName("quanshu");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._quanshu.push(n);
            }
        }

        this._jiesuan = [];
        var t = this.node.getChildByName(type).getChildByName("jiesuan");
        for (var i = 0; i < t.childrenCount; ++i) {
            var n = t.children[i].getComponent("RadioButton");
            if (n != null) {
                this._jiesuan.push(n);
            }
        }

        var self = this;
        var onCreate = function onCreate(ret) {
            if (ret.errcode !== 0) {
                cc.vv.wc.hide();
                if (ret.errcode == 2222) {
                    cc.vv.alert.show("提示", "房卡不足，创建房间失败!");
                } else {
                    cc.vv.alert.show("提示", "创建房间失败,错误码:" + ret.errcode);
                }
            } else {
                cc.vv.gameNetMgr.connectGameServer(ret);
            }
        };

        //判断用户做了哪些选择
        //扣费 0 房主出资 1 玩家平分
        //圈数 0 8盘 1 一圈
        //结算 0 50  1 120

        var koufei = 0;
        for (var i = 0; i < self._koufei.length; ++i) {
            if (self._koufei[i].checked) {
                koufei = i;
                break;
            }
        }

        var quanshu = 0;
        for (var i = 0; i < self._quanshu.length; ++i) {
            if (self._quanshu[i].checked) {
                quanshu = i;
                break;
            }
        }

        var jiesuan = 0;
        for (var i = 0; i < self._jiesuan.length; ++i) {
            if (self._jiesuan[i].checked) {
                jiesuan = i;
                break;
            }
        }

        var conf = {
            type: type,
            koufei: koufei,
            quanshu: quanshu,
            jiesuan: jiesuan
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            conf: JSON.stringify(conf)
        };
        console.log(data);
        cc.vv.wc.show("正在创建房间");
        cc.vv.http.sendRequest("/create_private_room", data, onCreate);
    }

});

cc._RF.pop();
},{}],"DingQue":[function(require,module,exports){
"use strict";
cc._RF.push(module, '907582awNJFnobC/mZGFLBq', 'DingQue');
// scripts/components/DingQue.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        queYiMen: null,
        tips: [],
        selected: [],
        dingques: []
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }
        this.initView();
        this.initDingQue();
        this.initEventHandlers();
    },

    initView: function initView() {
        var gameChild = this.node.getChildByName("game");
        this.queYiMen = gameChild.getChildByName("dingque");
        this.queYiMen.active = cc.vv.gameNetMgr.isDingQueing;

        var arr = ["myself", "right", "up", "left"];
        for (var i = 0; i < arr.length; ++i) {
            var side = gameChild.getChildByName(arr[i]);
            var seat = side.getChildByName("seat");
            var dingque = seat.getChildByName("que");
            this.dingques.push(dingque);
        }
        this.reset();

        var tips = this.queYiMen.getChildByName("tips");
        for (var i = 0; i < tips.childrenCount; ++i) {
            var n = tips.children[i];
            this.tips.push(n.getComponent(cc.Label));
        }

        if (cc.vv.gameNetMgr.gamestate == "dingque") {
            this.showDingQueChoice();
        }
    },

    initEventHandlers: function initEventHandlers() {
        var self = this;

        this.node.on('game_dingque_notify', function (data) {
            var seatIndex = cc.vv.gameNetMgr.getSeatIndexByID(data.detail);
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatIndex);
            console.log("game_dingque_notify:" + localIndex);
            self.tips[localIndex].node.active = true;
        });

        this.node.on('game_dingque_finish', function () {
            //通知每一个玩家定缺的花色
            self.queYiMen.active = false;
            cc.vv.gameNetMgr.isDingQueing = false;
            self.initDingQue();
        });
    },

    showDingQueChoice: function showDingQueChoice() {
        this.queYiMen.active = true;
        var sd = cc.vv.gameNetMgr.getSelfData();
        var typeCounts = [0, 0, 0];
        for (var i = 0; i < sd.holds.length; ++i) {
            var pai = sd.holds[i];
            var type = cc.vv.mahjongmgr.getMahjongType(pai);
            typeCounts[type]++;
        }

        var min = 65535;
        var minIndex = 0;
        for (var i = 0; i < typeCounts.length; ++i) {
            if (typeCounts[i] < min) {
                min = typeCounts[i];
                minIndex = i;
            }
        }

        var arr = ["tong", "tiao", "wan"];
        for (var i = 0; i < arr.length; ++i) {
            var node = this.queYiMen.getChildByName(arr[i]);
            if (minIndex == i) {
                node.getComponent(cc.Animation).play("dingque_tuijian");
            } else {
                node.getComponent(cc.Animation).stop();
            }
            //this.queYiMen.getChildByName(arr[i]).getChildByName('jian').active = minIndex == i;    
        }

        this.reset();
        for (var i = 0; i < this.tips.length; ++i) {
            var n = this.tips[i];
            if (i > 0) {
                n.node.active = false;
            } else {
                n.node.active = true;
            }
        }
    },

    initDingQue: function initDingQue() {
        var arr = ["tong", "tiao", "wan"];
        var data = cc.vv.gameNetMgr.seats;
        for (var i = 0; i < data.length; ++i) {
            var que = data[i].dingque;
            if (que == null || que < 0 || que >= arr.length) {
                que = null;
            } else {
                que = arr[que];
            }

            var localIndex = cc.vv.gameNetMgr.getLocalIndex(i);
            if (que) {
                this.dingques[localIndex].getChildByName(que).active = true;
            }
        }
    },

    reset: function reset() {
        this.setInteractable(true);

        this.selected.push(this.queYiMen.getChildByName("tong_selected"));
        this.selected.push(this.queYiMen.getChildByName("tiao_selected"));
        this.selected.push(this.queYiMen.getChildByName("wan_selected"));
        for (var i = 0; i < this.selected.length; ++i) {
            this.selected[i].active = false;
        }

        for (var i = 0; i < this.dingques.length; ++i) {
            for (var j = 0; j < this.dingques[i].children.length; ++j) {
                this.dingques[i].children[j].active = false;
            }
        }
    },

    onQueYiMenClicked: function onQueYiMenClicked(event) {
        var type = 0;
        if (event.target.name == "tong") {
            type = 0;
        } else if (event.target.name == "tiao") {
            type = 1;
        } else if (event.target.name == "wan") {
            type = 2;
        }

        for (var i = 0; i < this.selected.length; ++i) {
            this.selected[i].active = false;
        }
        this.selected[type].active = true;
        cc.vv.gameNetMgr.dingque = type;
        cc.vv.net.send("dingque", type);

        //this.setInteractable(false);
    },

    setInteractable: function setInteractable(value) {
        this.queYiMen.getChildByName("tong").getComponent(cc.Button).interactable = value;
        this.queYiMen.getChildByName("tiao").getComponent(cc.Button).interactable = value;
        this.queYiMen.getChildByName("wan").getComponent(cc.Button).interactable = value;
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"Folds":[function(require,module,exports){
"use strict";
cc._RF.push(module, '0bf63eiZEFMWbW03o8heqa5', 'Folds');
// scripts/components/Folds.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _folds: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this.initView();
        this.initEventHandler();

        this.initAllFolds();
    },

    initView: function initView() {
        this._folds = {};
        var game = this.node.getChildByName("game");
        var sides = ["myself", "right", "up", "left"];
        for (var i = 0; i < sides.length; ++i) {
            var sideName = sides[i];
            var sideRoot = game.getChildByName(sideName);
            var folds = [];
            var foldRoot = sideRoot.getChildByName("folds");
            for (var j = 0; j < foldRoot.children.length; ++j) {
                var n = foldRoot.children[j];
                n.active = false;
                var sprite = n.getComponent(cc.Sprite);
                sprite.spriteFrame = null;
                folds.push(sprite);
            }
            this._folds[sideName] = folds;
        }

        this.hideAllFolds();
    },

    hideAllFolds: function hideAllFolds() {
        for (var k in this._folds) {
            var f = this._folds[i];
            for (var i in f) {
                f[i].node.active = false;
            }
        }
    },

    initEventHandler: function initEventHandler() {
        var self = this;
        this.node.on('game_begin', function (data) {
            self.initAllFolds();
        });

        this.node.on('game_sync', function (data) {
            self.initAllFolds();
        });

        this.node.on('game_chupai_notify', function (data) {
            self.initFolds(data.detail);
        });

        this.node.on('guo_notify', function (data) {
            self.initFolds(data.detail);
        });
    },

    initAllFolds: function initAllFolds() {
        var seats = cc.vv.gameNetMgr.seats;
        for (var i in seats) {
            this.initFolds(seats[i]);
        }
    },

    initFolds: function initFolds(seatData) {
        var folds = seatData.folds;
        if (folds == null) {
            return;
        }
        var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatData.seatindex);
        var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);
        var side = cc.vv.mahjongmgr.getSide(localIndex);

        var foldsSprites = this._folds[side];
        for (var i = 0; i < foldsSprites.length; ++i) {
            var index = i;
            if (side == "right" || side == "up") {
                index = foldsSprites.length - i - 1;
            }
            var sprite = foldsSprites[index];
            sprite.node.active = true;
            this.setSpriteFrameByMJID(pre, sprite, folds[i]);
        }
        for (var i = folds.length; i < foldsSprites.length; ++i) {
            var index = i;
            if (side == "right" || side == "up") {
                index = foldsSprites.length - i - 1;
            }
            var sprite = foldsSprites[index];

            sprite.spriteFrame = null;
            sprite.node.active = false;
        }
    },

    setSpriteFrameByMJID: function setSpriteFrameByMJID(pre, sprite, mjid) {
        sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, mjid);
        sprite.node.active = true;
    }

});

cc._RF.pop();
},{}],"GameNetMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '9545659TARKZLMoHGqXoY2N', 'GameNetMgr');
// scripts/GameNetMgr.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        dataEventHandler: null,
        roomId: null,
        maxNumOfGames: -1,
        numOfGames: -1,
        numOfMJ: 0,
        seatIndex: -1,
        seats: null,
        turn: -1,
        button: -1,
        dingque: -1,
        chupai: -1,
        isDingQueing: false,
        isHuanSanZhang: false,
        gamestate: "",
        isOver: false,
        dissoveData: null,

        //舟山麻将额外属性
        fengxiang: null

    },

    reset: function reset() {
        this.turn = -1;
        this.chupai = -1, this.dingque = -1;
        this.button = -1;
        this.gamestate = "";
        this.dingque = -1;
        this.isDingQueing = false;
        this.isHuanSanZhang = false;
        this.curaction = null;
        for (var i = 0; i < this.seats.length; ++i) {
            this.seats[i].holds = [];
            this.seats[i].folds = [];
            this.seats[i].pengs = [];
            this.seats[i].chis = [];
            this.seats[i].huas = [];
            this.seats[i].angangs = [];
            this.seats[i].diangangs = [];
            this.seats[i].wangangs = [];
            this.seats[i].dingque = -1;
            this.seats[i].ready = false;
            this.seats[i].hued = false;
            this.seats[i].huanpais = null;
            this.huanpaimethod = -1;
        }
    },

    clear: function clear() {
        this.dataEventHandler = null;
        if (this.isOver == null) {
            this.seats = null;
            this.roomId = null;
            this.maxNumOfGames = 0;
            this.numOfGames = 0;
        }
    },

    dispatchEvent: function dispatchEvent(event, data) {
        if (this.dataEventHandler) {
            this.dataEventHandler.emit(event, data);
        }
    },


    getSeatIndexByID: function getSeatIndexByID(userId) {
        for (var i = 0; i < this.seats.length; ++i) {
            var s = this.seats[i];
            if (s.userid == userId) {
                return i;
            }
        }
        return -1;
    },

    isOwner: function isOwner() {
        return this.seatIndex == 0;
    },

    getSeatByID: function getSeatByID(userId) {
        var seatIndex = this.getSeatIndexByID(userId);
        var seat = this.seats[seatIndex];
        return seat;
    },

    getSelfData: function getSelfData() {
        return this.seats[this.seatIndex];
    },

    getLocalIndex: function getLocalIndex(index) {
        var ret = (index - this.seatIndex + 4) % 4;
        return ret;
    },

    prepareReplay: function prepareReplay(roomInfo, detailOfGame) {
        console.log("prepareReplay!!!");
        console.log(roomInfo);
        console.log(detailOfGame);
        this.roomId = roomInfo.id;
        this.seats = roomInfo.seats;
        this.turn = detailOfGame.base_info.button;
        var baseInfo = detailOfGame.base_info;
        for (var i = 0; i < this.seats.length; ++i) {
            var s = this.seats[i];
            s.seatindex = i;
            s.score = null;
            s.holds = baseInfo.game_seats[i];
            s.pengs = [];
            s.chis = [];
            s.huas = [];
            s.angangs = [];
            s.diangangs = [];
            s.wangangs = [];
            s.folds = [];
            console.log(s);
            if (cc.vv.userMgr.userId == s.userid) {
                this.seatIndex = i;
            }
        }
        this.conf = {
            type: baseInfo.type
        };
        if (this.conf.type == null) {
            this.conf.type == "sjmmmj";
        }
    },

    getWanfa: function getWanfa() {
        var conf = this.conf;
        if (conf && conf.maxGames != null && conf.maxFan != null) {
            var strArr = [];
            // strArr.push(conf.maxGames + "局");
            // strArr.push(conf.maxFan + "番封顶");
            if (conf.type == "sjmmj") {
                conf.koufei == 0 ? strArr.push("房主出资") : strArr.push("玩家平分");
                conf.hongzhongdanghua ? strArr.push("红中当花") : {};
                conf.quanshu == 0 ? strArr.push("8局") : strArr.push("一圈");
                if (conf.jiesuan == 0) strArr.push("幺半");else if (conf.jiesuan == 1) strArr.push("一二");else if (conf.jiesuan == 2) strArr.push("二四");
            } else if (conf.type == "dhmj") {
                conf.koufei == 0 ? strArr.push("房主出资") : strArr.push("玩家平分");
                conf.quanshu == 0 ? strArr.push("8局") : strArr.push("一圈");
                if (conf.jiesuan == 0) strArr.push("10");else if (conf.jiesuan == 1) strArr.push("25");else if (conf.jiesuan == 2) strArr.push("50");else if (conf.jiesuan == 3) strArr.push("120");
            } else if (conf.type == "tdh") {
                conf.koufei == 0 ? strArr.push("房主出资") : strArr.push("玩家平分");
                conf.quanshu == 0 ? strArr.push("8局") : strArr.push("一圈");
                if (conf.jiesuan == 0) strArr.push("有花");
            }
            // if(conf.zimo == 1){
            //     strArr.push("自摸加番");
            // }
            // else{
            //     strArr.push("自摸加底");
            // }
            // if(conf.jiangdui){
            //     strArr.push("将对");   
            // }
            // if(conf.dianganghua == 1){
            //     strArr.push("点杠花(自摸)");   
            // }
            // else{
            //     strArr.push("点杠花(放炮)");
            // }
            // if(conf.menqing){
            //     strArr.push("门清、中张");   
            // }
            // if(conf.tiandihu){
            //     strArr.push("天地胡");   
            // }
            return strArr.join(" ");
        }
        return "";
    },

    initHandlers: function initHandlers() {
        var self = this;
        cc.vv.net.addHandler("login_result", function (data) {
            console.log("login_result");
            console.log(data);
            if (data.errcode === 0) {
                var data = data.data;
                self.roomId = data.roomid;
                self.conf = data.conf;
                self.maxNumOfGames = data.conf.maxGames;
                self.numOfGames = data.numofgames;
                self.fengxiang = data.fengxiang;
                self.seats = data.seats;
                self.seatIndex = self.getSeatIndexByID(cc.vv.userMgr.userId);
                self.isOver = false;
            } else {
                console.log(data.errmsg);
            }
        });

        cc.vv.net.addHandler("login_finished", function (data) {
            console.log("login_finished");

            cc.director.loadScene("mjgame");

            // var loadgame = function (){
            //     cc.director.loadScene("mjgame");  
            // }
            // var fadeout = cc.fadeOut(0.1);
            // var finish = cc.callFunc(loadgame, this);
            // var seq = cc.sequence(fadeout, finish);
            // cc.director.getScene().getChildByName('Canvas').runAction(seq);


            //cc.director.loadScene("mjgame");
        });

        cc.vv.net.addHandler("exit_result", function (data) {
            self.roomId = null;
            self.turn = -1;
            self.dingque = -1;
            self.isDingQueing = false;
            self.seats = null;
        });

        cc.vv.net.addHandler("exit_notify_push", function (data) {
            var userId = data;
            var s = self.getSeatByID(userId);
            if (s != null) {
                s.userid = 0;
                s.name = "";
                self.dispatchEvent("user_state_changed", s);
            }
        });

        cc.vv.net.addHandler("dispress_push", function (data) {
            self.roomId = null;
            self.turn = -1;
            self.dingque = -1;
            self.isDingQueing = false;
            self.seats = null;
        });

        cc.vv.net.addHandler("disconnect", function (data) {
            if (self.roomId == null) {
                cc.director.loadScene("hall");
            } else {
                if (self.isOver == false) {
                    cc.vv.userMgr.oldRoomId = self.roomId;
                    self.dispatchEvent("disconnect");
                } else {
                    self.roomId = null;
                }
            }
        });

        cc.vv.net.addHandler("new_user_comes_push", function (data) {
            //console.log(data);
            var seatIndex = data.seatindex;
            if (self.seats[seatIndex].userid > 0) {
                self.seats[seatIndex].online = true;
            } else {
                data.online = true;
                self.seats[seatIndex] = data;
            }
            self.dispatchEvent('new_user', self.seats[seatIndex]);
        });

        cc.vv.net.addHandler("user_state_push", function (data) {
            //console.log(data);
            var userId = data.userid;
            var seat = self.getSeatByID(userId);
            seat.online = data.online;
            self.dispatchEvent('user_state_changed', seat);
        });

        cc.vv.net.addHandler("user_ready_push", function (data) {
            //console.log(data);
            var userId = data.userid;
            var seat = self.getSeatByID(userId);
            seat.ready = data.ready;
            self.dispatchEvent('user_state_changed', seat);
        });

        cc.vv.net.addHandler("game_holds_push", function (data) {
            var seat = self.seats[self.seatIndex];
            console.log(data);
            seat.holds = data;

            for (var i = 0; i < self.seats.length; ++i) {
                var s = self.seats[i];
                if (s.folds == null) {
                    s.folds = [];
                }
                if (s.pengs == null) {
                    s.pengs = [];
                }
                if (s.angangs == null) {
                    s.angangs = [];
                }
                if (s.diangangs == null) {
                    s.diangangs = [];
                }
                if (s.chis == null) {
                    s.chis = [];
                }
                if (s.huas == null) {
                    s.huas = [];
                }
                if (s.wangangs == null) {
                    s.wangangs = [];
                }
                s.ready = false;
            }
            self.dispatchEvent('game_holds');
        });

        cc.vv.net.addHandler("game_feng_push", function (data) {
            self.fengxiang = data;
            self.dispatchEvent('game_feng');
        });

        cc.vv.net.addHandler("game_begin_push", function (data) {
            console.log('game_action_push');
            console.log(data);
            self.button = data;
            self.turn = self.button;
            self.gamestate = "begin";
            self.dispatchEvent('game_begin');
        });

        cc.vv.net.addHandler("game_playing_push", function (data) {
            console.log('game_playing_push');
            self.gamestate = "playing";
            self.dispatchEvent('game_playing');
        });

        cc.vv.net.addHandler("game_sync_push", function (data) {
            console.log("game_sync_push");
            console.log(data);
            self.numOfMJ = data.numofmj;
            self.gamestate = data.state;
            self.fengxiang = data.fengxiang;
            if (self.gamestate == "dingque") {
                self.isDingQueing = true;
            } else if (self.gamestate == "huanpai") {
                self.isHuanSanZhang = true;
            }
            self.turn = data.turn;
            self.button = data.button;
            self.chupai = data.chuPai;
            self.huanpaimethod = data.huanpaimethod;
            for (var i = 0; i < 4; ++i) {
                var seat = self.seats[i];
                var sd = data.seats[i];
                seat.holds = sd.holds;
                seat.folds = sd.folds;
                seat.angangs = sd.angangs;
                seat.diangangs = sd.diangangs;
                seat.wangangs = sd.wangangs;
                seat.pengs = sd.pengs;
                seat.chis = sd.chis;
                seat.huas = sd.huas;
                seat.dingque = sd.que;
                seat.hued = sd.hued;
                seat.iszimo = sd.iszimo;
                seat.huinfo = sd.huinfo;
                seat.huanpais = sd.huanpais;
                if (i == self.seatIndex) {
                    self.dingque = sd.que;
                }
            }
        });

        cc.vv.net.addHandler("game_huanpai_push", function (data) {
            self.isHuanSanZhang = true;
            self.dispatchEvent('game_huanpai');
        });

        cc.vv.net.addHandler("hangang_notify_push", function (data) {
            self.dispatchEvent('hangang_notify', data);
        });

        cc.vv.net.addHandler("game_action_push", function (data) {
            self.curaction = data;
            console.log(data);
            self.dispatchEvent('game_action', data);
        });

        cc.vv.net.addHandler("game_num_push", function (data) {
            self.numOfGames = data;
            self.dispatchEvent('game_num', data);
        });

        cc.vv.net.addHandler("game_over_push", function (data) {
            console.log('game_over_push');
            console.log(data);
            var results = data.results;
            for (var i = 0; i < self.seats.length; ++i) {
                self.seats[i].score = results.length == 0 ? 0 : results[i].totalscore;
            }
            self.dispatchEvent('game_over', results);
            if (data.endinfo) {
                self.isOver = true;
                self.dispatchEvent('game_end', data.endinfo);
            }
            self.reset();
            for (var i = 0; i < self.seats.length; ++i) {
                self.dispatchEvent('user_state_changed', self.seats[i]);
            }
        });

        cc.vv.net.addHandler("mj_count_push", function (data) {
            console.log('mj_count_push');
            self.numOfMJ = data;
            //console.log(data);
            self.dispatchEvent('mj_count', data);
        });

        cc.vv.net.addHandler("game_chupai_push", function (data) {
            console.log('game_chupai_push');
            //console.log(data);
            var turnUserID = data;
            var si = self.getSeatIndexByID(turnUserID);
            self.doTurnChange(si);
        });

        cc.vv.net.addHandler("hu_push", function (data) {
            console.log('hu_push');
            console.log(data);
            self.doHu(data);
        });

        cc.vv.net.addHandler("game_chupai_notify_push", function (data) {
            var userId = data.userId;
            var pai = data.pai;
            var si = self.getSeatIndexByID(userId);
            self.doChupai(si, pai);
        });

        cc.vv.net.addHandler("game_mopai_push", function (data) {
            console.log('game_mopai_push');
            self.doMopai(self.seatIndex, data);
        });

        cc.vv.net.addHandler("guo_notify_push", function (data) {
            console.log('guo_notify_push');
            var userId = data.userId;
            var pai = data.pai;
            var si = self.getSeatIndexByID(userId);
            self.doGuo(si, pai);
        });

        cc.vv.net.addHandler("guo_result", function (data) {
            console.log('guo_result');
            self.dispatchEvent('guo_result');
        });

        cc.vv.net.addHandler("guohu_push", function (data) {
            console.log('guohu_push');
            self.dispatchEvent("push_notice", { info: "过胡", time: 1.5 });
        });

        cc.vv.net.addHandler("huanpai_notify", function (data) {
            var seat = self.getSeatByID(data.si);
            seat.huanpais = data.huanpais;
            self.dispatchEvent('huanpai_notify', seat);
        });

        cc.vv.net.addHandler("game_huanpai_over_push", function (data) {
            console.log('game_huanpai_over_push');
            var info = "";
            var method = data.method;
            if (method == 0) {
                info = "换对家牌";
            } else if (method == 1) {
                info = "换下家牌";
            } else {
                info = "换上家牌";
            }
            self.huanpaimethod = method;
            cc.vv.gameNetMgr.isHuanSanZhang = false;
            self.dispatchEvent("game_huanpai_over");
            self.dispatchEvent("push_notice", { info: info, time: 2 });
        });

        cc.vv.net.addHandler("peng_notify_push", function (data) {
            console.log('peng_notify_push');
            console.log(data);
            var userId = data.userid;
            var pai = data.pai;
            var si = self.getSeatIndexByID(userId);
            self.doPeng(si, data.pai);
        });

        cc.vv.net.addHandler("gang_notify_push", function (data) {
            console.log('gang_notify_push');
            console.log(data);
            var userId = data.userid;
            var pai = data.pai;
            var si = self.getSeatIndexByID(userId);
            self.doGang(si, pai, data.gangtype);
        });

        cc.vv.net.addHandler("chi_notify_push", function (data) {
            console.log('chi_notify_push');
            console.log(data);
            var userId = data.userid;
            var pai = data.pai;
            var chigroup = data.chigroup;
            var si = self.getSeatIndexByID(userId);
            self.doChi(si, data.pai, chigroup);
        });

        cc.vv.net.addHandler("gethua_notify_push", function (data) {
            console.log('gethua_notify_push');
            var userId = data.userid;
            var pai = data.pai;
            var si = self.getSeatIndexByID(userId);
            self.doHua(si, data.pai);
        });

        //开局补花侦听 全局
        cc.vv.net.addHandler("buhua_notify_push", function (data) {
            console.log('buhua_notify_push');
            var userId = data.userid;
            var buhuas = data.buhuas;
            var si = self.getSeatIndexByID(userId);
            self.doBuhua(si, buhuas);
        });

        //开局补花侦听 自己
        cc.vv.net.addHandler("game_buhua_push", function (data) {
            console.log('game_buhua_push');
            var userId = data.userid;
            var holds = data.holds;
            var buhuas = data.buhuas;
            var si = self.getSeatIndexByID(userId);
            self.doBuhuaforme(si, holds, buhuas);
        });

        cc.vv.net.addHandler("game_dingque_notify_push", function (data) {
            self.dispatchEvent('game_dingque_notify', data);
        });

        cc.vv.net.addHandler("game_dingque_finish_push", function (data) {
            for (var i = 0; i < data.length; ++i) {
                self.seats[i].dingque = data[i];
            }
            self.dispatchEvent('game_dingque_finish', data);
        });

        cc.vv.net.addHandler("chat_push", function (data) {
            self.dispatchEvent("chat_push", data);
        });

        cc.vv.net.addHandler("quick_chat_push", function (data) {
            self.dispatchEvent("quick_chat_push", data);
        });

        cc.vv.net.addHandler("emoji_push", function (data) {
            self.dispatchEvent("emoji_push", data);
        });

        cc.vv.net.addHandler("dissolve_notice_push", function (data) {
            console.log("dissolve_notice_push");
            console.log(data);
            self.dissoveData = data;
            self.dispatchEvent("dissolve_notice", data);
        });

        cc.vv.net.addHandler("dissolve_cancel_push", function (data) {
            self.dissoveData = null;
            self.dispatchEvent("dissolve_cancel", data);
        });

        cc.vv.net.addHandler("voice_msg_push", function (data) {
            self.dispatchEvent("voice_msg", data);
        });
    },

    doGuo: function doGuo(seatIndex, pai) {
        var seatData = this.seats[seatIndex];
        var folds = seatData.folds;
        folds.push(pai);
        this.dispatchEvent('guo_notify', seatData);
    },

    doMopai: function doMopai(seatIndex, pai) {
        var seatData = this.seats[seatIndex];
        if (seatData.holds) {
            seatData.holds.push(pai);
            this.dispatchEvent('game_mopai', { seatIndex: seatIndex, pai: pai });
        }
    },

    doChupai: function doChupai(seatIndex, pai) {
        this.chupai = pai;
        var seatData = this.seats[seatIndex];
        if (seatData.holds) {
            var idx = seatData.holds.indexOf(pai);
            seatData.holds.splice(idx, 1);
        }
        this.dispatchEvent('game_chupai_notify', { seatData: seatData, pai: pai });
    },

    doPeng: function doPeng(seatIndex, pai) {
        console.log(seatIndex);
        var seatData = this.seats[seatIndex];
        console.log(this.seats[seatIndex]);
        console.log(this.seats[0]);
        console.log(this.seats["0"]);
        console.log(seatData);
        console.log(seatData.huas);
        console.log(seatData.userid);
        //移除手牌
        if (seatData.holds) {
            for (var i = 0; i < 2; ++i) {
                var idx = seatData.holds.indexOf(pai);
                seatData.holds.splice(idx, 1);
            }
        }

        //更新碰牌数据
        var pengs = seatData.pengs;
        pengs.push(pai);

        this.dispatchEvent('peng_notify', seatData);
    },

    doChi: function doChi(seatIndex, pai, chigroup) {
        console.log("dochi");
        var seatData = this.seats[seatIndex];
        console.log(seatData);
        //移除手牌
        if (seatData.holds) {
            for (var i = 0; i < 3; ++i) {
                if (pai == chigroup[i]) continue;
                var idx = seatData.holds.indexOf(chigroup[i]);
                seatData.holds.splice(idx, 1);
            }
        }

        //更新吃牌数据
        var chis = seatData.chis;
        chis.push(chigroup);

        this.dispatchEvent('chi_notify', seatData);
    },

    doHua: function doHua(seatIndex, pai) {
        var seatData = this.seats[seatIndex];
        //更新花牌数据
        if (seatData.huas == undefined || seatData.huas == null) {
            seatData.huas = [];
        }
        var huas = seatData.huas;
        huas.push(pai);
        this.dispatchEvent('gethua_notify', seatData);
    },

    doBuhua: function doBuhua(seatIndex, buhuas) {
        console.log("da buhua");
        var seatData = this.seats[seatIndex];
        //更新花牌数据
        if (seatData.huas == undefined || seatData.huas == null) {
            seatData.huas = [];
        }
        var huas = seatData.huas;
        for (var i = 0; i < buhuas.length; i++) {
            huas.push(buhuas[i]);
        }
        this.dispatchEvent('gethua_notify', seatData);
    },

    doBuhuaforme: function doBuhuaforme(seatIndex, holds, buhuas) {
        console.log("da buhua");
        var seatData = this.seats[seatIndex];
        // for(var i=0 ; i < holds.length ; i++) {
        //     seatData.holds.push(holds[i]);
        // }
        // for(var i=0 ; i < buhuas.length ; i++) {
        //     var idx = seatData.holds.indexOf(buhuas[i]);
        //     seatData.holds.splice(idx,1);
        // }
        seatData.holds = holds;
        this.dispatchEvent('buhua_notify', seatData);
    },

    getGangType: function getGangType(seatData, pai) {
        if (seatData.pengs.indexOf(pai) != -1) {
            return "wangang";
        } else {
            var cnt = 0;
            for (var i = 0; i < seatData.holds.length; ++i) {
                if (seatData.holds[i] == pai) {
                    cnt++;
                }
            }
            if (cnt == 3) {
                return "diangang";
            } else {
                return "angang";
            }
        }
    },

    doGang: function doGang(seatIndex, pai, gangtype) {
        var seatData = this.seats[seatIndex];

        if (!gangtype) {
            gangtype = this.getGangType(seatData, pai);
        }

        if (gangtype == "wangang") {
            if (seatData.pengs.indexOf(pai) != -1) {
                var idx = seatData.pengs.indexOf(pai);
                if (idx != -1) {
                    seatData.pengs.splice(idx, 1);
                }
            }
            seatData.wangangs.push(pai);
        }
        if (seatData.holds) {
            for (var i = 0; i <= 4; ++i) {
                var idx = seatData.holds.indexOf(pai);
                if (idx == -1) {
                    //如果没有找到，表示移完了，直接跳出循环
                    break;
                }
                seatData.holds.splice(idx, 1);
            }
        }
        if (gangtype == "angang") {
            seatData.angangs.push(pai);
        } else if (gangtype == "diangang") {
            seatData.diangangs.push(pai);
        }
        this.dispatchEvent('gang_notify', { seatData: seatData, gangtype: gangtype });
    },

    doHu: function doHu(data) {
        this.dispatchEvent('hupai', data);
    },

    doTurnChange: function doTurnChange(si) {
        var data = {
            last: this.turn,
            turn: si
        };
        this.turn = si;
        this.dispatchEvent('game_chupai', data);
    },

    connectGameServer: function connectGameServer(data) {
        this.dissoveData = null;
        cc.vv.net.ip = data.ip + ":" + data.port;
        console.log(cc.vv.net.ip);
        var self = this;

        var onConnectOK = function onConnectOK() {
            console.log("onConnectOK");
            var sd = {
                token: data.token,
                roomid: data.roomid,
                time: data.time,
                sign: data.sign
            };
            cc.vv.net.send("login", sd);
        };

        var onConnectFailed = function onConnectFailed() {
            console.log("failed.");
            cc.vv.wc.hide();
        };
        cc.vv.wc.show("正在进入房间");
        cc.vv.net.connect(onConnectOK, onConnectFailed);
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"GameOver":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'facfdljnx5F+rFDAq5Qbmqa', 'GameOver');
// scripts/components/GameOver.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _gameover: null,
        _gameresult: null,
        _seats: [],
        _isGameEnd: false,
        _pingju: null,
        _win: null,
        _lose: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }
        if (cc.vv.gameNetMgr.conf == null) {
            return;
        }
        //TODO:可能出现不同的计分板
        this._gameover = this.node.getChildByName("game_over_" + cc.vv.gameNetMgr.conf.type);

        for (var n = 0; n < 4; n++) {
            var hua_node = this._gameover.getChildByName("result_list").getChildByName("s" + (n + 1)).getChildByName("huas");
            for (var m = 0; m < hua_node.childrenCount; m++) {
                hua_node.children[m].active = false;
            }
        }

        this._gameover.active = false;

        this._pingju = this._gameover.getChildByName("pingju");
        this._win = this._gameover.getChildByName("win");
        this._lose = this._gameover.getChildByName("lose");

        this._gameresult = this.node.getChildByName("game_result");

        var wanfa = this._gameover.getChildByName("wanfa").getComponent(cc.Label);
        wanfa.string = cc.vv.gameNetMgr.getWanfa();

        var listRoot = this._gameover.getChildByName("result_list");
        for (var i = 1; i <= 4; ++i) {
            var s = "s" + i;
            var sn = listRoot.getChildByName(s);
            //整理所有需要显示在计分板上的信息的节点
            var viewdata = {};
            viewdata.username = sn.getChildByName('username').getComponent(cc.Label);
            viewdata.reason = sn.getChildByName('reason').getComponent(cc.Label);
            viewdata.taisi = sn.getChildByName('taisi').getComponent(cc.Label);

            var f = sn.getChildByName('fan');
            if (f != null) {
                viewdata.fan = f.getComponent(cc.Label);
            }

            viewdata.score = sn.getChildByName('score').getComponent(cc.Label);
            viewdata.hu = sn.getChildByName('hu');
            viewdata.mahjongs = sn.getChildByName('pai');
            viewdata.zhuang = sn.getChildByName('zhuang');
            viewdata.hupai = sn.getChildByName('hupai');
            viewdata._pengandgang = [];

            this._seats.push(viewdata);
        }

        //初始化网络事件监听器
        var self = this;
        this.node.on('game_over', function (data) {
            self.onGameOver(data.detail);
        });

        this.node.on('game_end', function (data) {
            self._isGameEnd = true;
        });
    },

    onGameOver: function onGameOver(data) {
        //TODO:多种判定
        if (cc.vv.gameNetMgr.conf.type == "sjmmj") {
            this.onGameOver_SJMMJ(data);
        } else if (cc.vv.gameNetMgr.conf.type == "dhmj") {
            this.onGameOver_DHMJ(data);
        } else if (cc.vv.gameNetMgr.conf.type == "tdh") {
            this.onGameOver_TDH(data);
        }
    },
    onGameOver_SJMMJ: function onGameOver_SJMMJ(data) {
        console.log(data);
        if (data.length == 0) {
            this._gameresult.active = true;
            return;
        }
        this._gameover.active = true;
        this._pingju.active = false;
        this._win.active = false;
        this._lose.active = false;

        var myscore = data[cc.vv.gameNetMgr.seatIndex].score;
        if (myscore > 0) {
            this._win.active = true;
        } else if (myscore < 0) {
            this._lose.active = true;
        } else {
            this._pingju.active = true;
        }

        //显示玩家信息
        for (var i = 0; i < 4; ++i) {
            var seatView = this._seats[i];
            var userData = data[i];
            var hued = false;
            //胡牌的玩家才显示 是否清一色 根xn的字样
            var numOfGangs = userData.angangs.length + userData.wangangs.length + userData.diangangs.length;
            var numOfGen = userData.numofgen;
            var actionArr = [];
            var is7pairs = false;
            var ischadajiao = false;

            for (var j = 0; j < userData.actions.length; ++j) {
                var ac = userData.actions[j];
                if (ac.type == "zimo" || ac.type == "ganghua" || ac.type == "dianganghua" || ac.type == "hu" || ac.type == "gangpaohu" || ac.type == "qiangganghu" || ac.type == "chadajiao") {
                    if (userData.pattern == "7pairs") {
                        actionArr.push("七对");
                    } else if (userData.pattern == "l7pairs") {
                        actionArr.push("龙七对");
                    } else if (userData.pattern == "j7pairs") {
                        actionArr.push("将七对");
                    } else if (userData.pattern == "duidui") {
                        actionArr.push("碰碰胡");
                    } else if (userData.pattern == "jiangdui") {
                        actionArr.push("将对");
                    }

                    if (ac.type == "zimo") {
                        actionArr.push("自摸");
                    } else if (ac.type == "ganghua") {
                        actionArr.push("杠上花");
                    } else if (ac.type == "dianganghua") {
                        actionArr.push("点杠花");
                    } else if (ac.type == "gangpaohu") {
                        actionArr.push("杠炮胡");
                    } else if (ac.type == "qiangganghu") {
                        actionArr.push("抢杠胡");
                    } else if (ac.type == "chadajiao") {
                        ischadajiao = true;
                    }
                    hued = true;
                } else if (ac.type == "fangpao") {
                    actionArr.push("放炮");
                } else if (ac.type == "angang") {
                    actionArr.push("暗杠");
                } else if (ac.type == "diangang") {
                    actionArr.push("明杠");
                } else if (ac.type == "wangang") {
                    actionArr.push("弯杠");
                } else if (ac.type == "fanggang") {
                    actionArr.push("放杠");
                } else if (ac.type == "zhuanshougang") {
                    actionArr.push("转手杠");
                } else if (ac.type == "beiqianggang") {
                    actionArr.push("被抢杠");
                } else if (ac.type == "beichadajiao") {
                    actionArr.push("被查叫");
                }
            }

            if (hued) {
                if (userData.qingyise) {
                    actionArr.push("清一色");
                }

                if (userData.menqing) {
                    actionArr.push("门清");
                }

                if (userData.zhongzhang) {
                    actionArr.push("中张");
                }

                if (userData.jingouhu) {
                    actionArr.push("金钩胡");
                }

                if (userData.haidihu) {
                    actionArr.push("海底胡");
                }

                if (userData.tianhu) {
                    actionArr.push("天胡");
                }

                if (userData.dihu) {
                    actionArr.push("地胡");
                }

                if (numOfGen > 0) {
                    actionArr.push("根x" + numOfGen);
                }

                if (ischadajiao) {
                    actionArr.push("查大叫");
                }

                if (userData.hunyise) {
                    actionArr.push("混一色");
                }

                if (userData.duiduihu) {
                    actionArr.push("对对胡");
                }

                if (userData.paihu) {
                    actionArr.push("排胡");
                }

                if (userData.gangshanghua) {
                    actionArr.push("杠上花");
                }

                if (userData.kan) {
                    actionArr.push("坎档");
                }

                if (userData.bian) {
                    actionArr.push("边档");
                }

                if (userData.dan) {
                    actionArr.push("单吊");
                }

                if (userData.duidao) {
                    actionArr.push("对倒");
                }
            }

            for (var o = 0; o < 3; ++o) {
                seatView.hu.children[o].active = false;
            }
            if (userData.huorder >= 0) {
                seatView.hu.children[userData.huorder].active = true;
            }

            seatView.username.string = cc.vv.gameNetMgr.seats[i].name;
            seatView.zhuang.active = cc.vv.gameNetMgr.button == i;
            seatView.reason.string = actionArr.join("、");

            //显示丝数台数
            console.log("显示台和丝");
            console.log(userData.tai);
            console.log(userData.si);
            console.log(seatView.taisi.string);
            seatView.taisi.string = userData.tai + "台" + userData.si + "丝";

            //显示胡数
            var fan = 0;
            fan = userData.fan;
            seatView.fan.string = fan + "胡";

            //
            if (userData.score > 0) {
                seatView.score.string = "+" + userData.score;
            } else {
                seatView.score.string = userData.score;
            }

            var hupai = -1;
            if (hued) {
                hupai = userData.holds.pop();
            }

            cc.vv.mahjongmgr.sortMJ(userData.holds, userData.dingque);

            //胡牌不参与排序
            if (hued) {
                userData.holds.push(hupai);
            }

            //隐藏所有牌
            for (var k = 0; k < seatView.mahjongs.childrenCount; ++k) {
                var n = seatView.mahjongs.children[k];
                n.active = false;
            }

            var lackingNum = (userData.pengs.length + numOfGangs + userData.chis.length) * 3;
            //显示相关的牌
            for (var k = 0; k < userData.holds.length; ++k) {
                var pai = userData.holds[k];
                var n = seatView.mahjongs.children[k + lackingNum];
                n.active = true;
                var sprite = n.getComponent(cc.Sprite);
                sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
            }

            for (var k = 0; k < seatView._pengandgang.length; ++k) {
                seatView._pengandgang[k].active = false;
            }

            //初始化杠牌
            var index = 0;
            var gangs = userData.angangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "angang");
                index++;
            }

            var gangs = userData.diangangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "diangang");
                index++;
            }

            var gangs = userData.wangangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "wangang");
                index++;
            }

            //初始化碰牌
            var pengs = userData.pengs;
            if (pengs) {
                for (var k = 0; k < pengs.length; ++k) {
                    var mjid = pengs[k];
                    this.initPengAndGangs(seatView, index, mjid, "peng");
                    index++;
                }
            }

            //初始化吃牌
            var chis = userData.chis;
            if (chis) {
                for (var k = 0; k < chis.length; ++k) {
                    var mjid = chis[k];
                    this.initPengAndGangs(seatView, index, mjid, "chi");
                    index++;
                }
            }

            //初始化花牌 TODO:和下面一样写初始化函数 并且要首先隐藏所有的花

            var huas = userData.huas;
            var hua_node = this._gameover.getChildByName("result_list").getChildByName("s" + (i + 1)).getChildByName("huas");
            for (var k = 0; k < hua_node.childrenCount; ++k) {
                hua_node.children[k].active = false;
            }
            if (huas) {
                for (var k = 0; k < huas.length; ++k) {
                    var mjid = huas[k];
                    hua_node.children[k].active = true;
                    var sp = hua_node.children[k].getComponent(cc.Sprite);
                    sp.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", mjid);
                }
            }

            //东南西北小旗子转换
            var switchFengFlag = function switchFengFlag(direction, dir_str) {
                for (var k = 0; k < 4; k++) {
                    direction.children[k].active = false;
                }
                direction.getChildByName(dir_str).active = true;
            };

            //显示当前风圈和局数
            var numofgames = this._gameover.getChildByName("numofgames");
            var fengquan = "东风圈";
            switch (cc.vv.gameNetMgr.fengxiang) {
                case 0:
                    fengquan = "东风圈";break;
                case 1:
                    fengquan = "南风圈";break;
                case 2:
                    fengquan = "西风圈";break;
                case 3:
                    fengquan = "北风圈";break;
            }
            numofgames.getComponent(cc.Label).string = fengquan;

            //判断东南西北
            if (userData.button) {
                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + (i % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "dong");

                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + ((i + 1) % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "nan");

                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + ((i + 2) % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "xi");

                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + ((i + 3) % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "bei");
            }
        }
    },

    onGameOver_DHMJ: function onGameOver_DHMJ(data) {
        console.log(data);
        if (data.length == 0) {
            this._gameresult.active = true;
            return;
        }
        this._gameover.active = true;
        this._pingju.active = false;
        this._win.active = false;
        this._lose.active = false;

        var myscore = data[cc.vv.gameNetMgr.seatIndex].score;
        if (myscore > 0) {
            this._win.active = true;
        } else if (myscore < 0) {
            this._lose.active = true;
        } else {
            this._pingju.active = true;
        }

        //显示玩家信息
        for (var i = 0; i < 4; ++i) {
            var seatView = this._seats[i];
            var userData = data[i];
            var hued = false;
            //胡牌的玩家才显示 是否清一色 根xn的字样
            var numOfGangs = userData.angangs.length + userData.wangangs.length + userData.diangangs.length;
            var numOfGen = userData.numofgen;
            var actionArr = [];
            var is7pairs = false;
            var ischadajiao = false;
            for (var j = 0; j < userData.actions.length; ++j) {
                var ac = userData.actions[j];
                if (ac.type == "zimo" || ac.type == "ganghua" || ac.type == "dianganghua" || ac.type == "hu" || ac.type == "gangpaohu" || ac.type == "qiangganghu" || ac.type == "chadajiao") {
                    if (userData.pattern == "7pairs") {
                        actionArr.push("七对");
                    } else if (userData.pattern == "l7pairs") {
                        actionArr.push("龙七对");
                    } else if (userData.pattern == "j7pairs") {
                        actionArr.push("将七对");
                    } else if (userData.pattern == "duidui") {
                        actionArr.push("碰碰胡");
                    } else if (userData.pattern == "jiangdui") {
                        actionArr.push("将对");
                    }

                    if (ac.type == "zimo") {
                        actionArr.push("自摸");
                    } else if (ac.type == "ganghua") {
                        actionArr.push("杠上花");
                    } else if (ac.type == "dianganghua") {
                        actionArr.push("点杠花");
                    } else if (ac.type == "gangpaohu") {
                        actionArr.push("杠炮胡");
                    } else if (ac.type == "qiangganghu") {
                        actionArr.push("抢杠胡");
                    } else if (ac.type == "chadajiao") {
                        ischadajiao = true;
                    }
                    hued = true;
                } else if (ac.type == "fangpao") {
                    actionArr.push("放炮");
                } else if (ac.type == "angang") {
                    actionArr.push("暗杠");
                } else if (ac.type == "diangang") {
                    actionArr.push("明杠");
                } else if (ac.type == "wangang") {
                    actionArr.push("弯杠");
                } else if (ac.type == "fanggang") {
                    actionArr.push("放杠");
                } else if (ac.type == "zhuanshougang") {
                    actionArr.push("转手杠");
                } else if (ac.type == "beiqianggang") {
                    actionArr.push("被抢杠");
                } else if (ac.type == "beichadajiao") {
                    actionArr.push("被查叫");
                } else if (ac.type == "sanchisanpeng0") {
                    actionArr.push("三吃三碰东");
                } else if (ac.type == "sanchisanpeng1") {
                    actionArr.push("三吃三碰南");
                } else if (ac.type == "sanchisanpeng2") {
                    actionArr.push("三吃三碰西");
                } else if (ac.type == "sanchisanpeng3") {
                    actionArr.push("三吃三碰北");
                }
            }

            if (hued) {
                this._gameover.getChildByName("result_list").getChildByName("s" + (i + 1)).getChildByName("hu").active = true;

                if (userData.qingyise) {
                    actionArr.push("清一色");
                }

                if (userData.menqing) {
                    actionArr.push("门清");
                }

                if (userData.zhongzhang) {
                    actionArr.push("中张");
                }

                if (userData.jingouhu) {
                    actionArr.push("金钩胡");
                }

                if (userData.haidihu) {
                    actionArr.push("海底胡");
                }

                if (userData.tianhu) {
                    actionArr.push("天胡");
                }

                if (userData.dihu) {
                    actionArr.push("地胡");
                }

                if (numOfGen > 0) {
                    actionArr.push("根x" + numOfGen);
                }

                if (ischadajiao) {
                    actionArr.push("查大叫");
                }

                if (userData.hunyise) {
                    actionArr.push("混一色");
                }

                if (userData.duiduihu) {
                    actionArr.push("对对胡");
                }

                if (userData.paihu) {
                    actionArr.push("排胡");
                }

                if (userData.gangshanghua) {
                    actionArr.push("杠上花");
                }

                if (userData.kan) {
                    actionArr.push("坎档");
                }

                if (userData.bian) {
                    actionArr.push("边档");
                }

                if (userData.dan) {
                    actionArr.push("单吊");
                }

                if (userData.duidao) {
                    actionArr.push("对倒");
                }
            } else {
                this._gameover.getChildByName("result_list").getChildByName("s" + (i + 1)).getChildByName("hu").active = false;
            }

            // for(var o = 0; o < 3;++o){
            //     seatView.hu.children[o].active = false;    
            // }
            // if(userData.huorder >= 0){
            //     seatView.hu.children[userData.huorder].active = true;    
            // }

            seatView.username.string = cc.vv.gameNetMgr.seats[i].name;
            seatView.zhuang.active = cc.vv.gameNetMgr.button == i;
            seatView.reason.string = actionArr.join("、");

            //显示丝数台数
            if (userData.tai == -1) seatView.taisi.string = "";else seatView.taisi.string = userData.tai + "台";

            //
            if (userData.score > 0) {
                seatView.score.string = "+" + userData.score;
            } else {
                seatView.score.string = userData.score;
            }

            var hupai = -1;
            if (hued) {
                hupai = userData.holds.pop();
            }

            cc.vv.mahjongmgr.sortMJ(userData.holds, userData.dingque);

            //胡牌不参与排序
            if (hued) {
                userData.holds.push(hupai);
            }

            //隐藏所有牌
            for (var k = 0; k < seatView.mahjongs.childrenCount; ++k) {
                var n = seatView.mahjongs.children[k];
                n.active = false;
            }

            var lackingNum = (userData.pengs.length + numOfGangs + userData.chis.length) * 3;
            //显示相关的牌
            for (var k = 0; k < userData.holds.length; ++k) {
                var pai = userData.holds[k];
                var n = seatView.mahjongs.children[k + lackingNum];
                n.active = true;
                var sprite = n.getComponent(cc.Sprite);
                sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
            }

            for (var k = 0; k < seatView._pengandgang.length; ++k) {
                seatView._pengandgang[k].active = false;
            }

            //初始化杠牌
            var index = 0;
            var gangs = userData.angangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "angang");
                index++;
            }

            var gangs = userData.diangangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "diangang");
                index++;
            }

            var gangs = userData.wangangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "wangang");
                index++;
            }

            //初始化碰牌
            var pengs = userData.pengs;
            if (pengs) {
                for (var k = 0; k < pengs.length; ++k) {
                    var mjid = pengs[k];
                    this.initPengAndGangs(seatView, index, mjid, "peng");
                    index++;
                }
            }

            //初始化吃牌
            var chis = userData.chis;
            if (chis) {
                for (var k = 0; k < chis.length; ++k) {
                    var mjid = chis[k];
                    this.initPengAndGangs(seatView, index, mjid, "chi");
                    index++;
                }
            }

            //初始化花牌 TODO:和下面一样写初始化函数 并且要首先隐藏所有的花

            var huas = userData.huas;
            var hua_node = this._gameover.getChildByName("result_list").getChildByName("s" + (i + 1)).getChildByName("huas");
            for (var k = 0; k < hua_node.childrenCount; ++k) {
                hua_node.children[k].active = false;
            }
            if (huas) {
                for (var k = 0; k < huas.length; ++k) {
                    var mjid = huas[k];
                    hua_node.children[k].active = true;
                    var sp = hua_node.children[k].getComponent(cc.Sprite);
                    sp.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", mjid);
                }
            }

            //东南西北小旗子转换
            var switchFengFlag = function switchFengFlag(direction, dir_str) {
                for (var k = 0; k < 4; k++) {
                    direction.children[k].active = false;
                }
                direction.getChildByName(dir_str).active = true;
            };

            //显示当前风圈和局数
            var numofgames = this._gameover.getChildByName("numofgames");
            var fengquan = "东风圈";
            switch (cc.vv.gameNetMgr.fengxiang) {
                case 0:
                    fengquan = "东风圈";break;
                case 1:
                    fengquan = "南风圈";break;
                case 2:
                    fengquan = "西风圈";break;
                case 3:
                    fengquan = "北风圈";break;
            }
            numofgames.getComponent(cc.Label).string = fengquan;

            //判断东南西北
            if (userData.button) {
                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + (i % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "dong");

                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + ((i + 1) % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "nan");

                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + ((i + 2) % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "xi");

                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + ((i + 3) % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "bei");
            }
        }
    },
    onGameOver_TDH: function onGameOver_TDH(data) {
        console.log(data);
        if (data.length == 0) {
            this._gameresult.active = true;
            return;
        }
        this._gameover.active = true;
        this._pingju.active = false;
        this._win.active = false;
        this._lose.active = false;

        var myscore = data[cc.vv.gameNetMgr.seatIndex].score;
        if (myscore > 0) {
            this._win.active = true;
        } else if (myscore < 0) {
            this._lose.active = true;
        } else {
            this._pingju.active = true;
        }

        //显示玩家信息
        for (var i = 0; i < 4; ++i) {
            var seatView = this._seats[i];
            var userData = data[i];
            var hued = false;
            //胡牌的玩家才显示 是否清一色 根xn的字样
            var numOfGangs = userData.angangs.length + userData.wangangs.length + userData.diangangs.length;
            var numOfGen = userData.numofgen;
            var actionArr = [];
            var is7pairs = false;
            var ischadajiao = false;
            for (var j = 0; j < userData.actions.length; ++j) {
                var ac = userData.actions[j];
                if (ac.type == "zimo" || ac.type == "ganghua" || ac.type == "dianganghua" || ac.type == "hu" || ac.type == "gangpaohu" || ac.type == "qiangganghu" || ac.type == "chadajiao") {
                    if (userData.pattern == "7pairs") {
                        actionArr.push("七对");
                    } else if (userData.pattern == "l7pairs") {
                        actionArr.push("龙七对");
                    } else if (userData.pattern == "j7pairs") {
                        actionArr.push("将七对");
                    } else if (userData.pattern == "duidui") {
                        actionArr.push("碰碰胡");
                    } else if (userData.pattern == "jiangdui") {
                        actionArr.push("将对");
                    }

                    if (ac.type == "zimo") {
                        actionArr.push("自摸");
                    } else if (ac.type == "ganghua") {
                        actionArr.push("杠上花");
                    } else if (ac.type == "dianganghua") {
                        actionArr.push("点杠花");
                    } else if (ac.type == "gangpaohu") {
                        actionArr.push("杠炮胡");
                    } else if (ac.type == "qiangganghu") {
                        actionArr.push("抢杠胡");
                    } else if (ac.type == "chadajiao") {
                        ischadajiao = true;
                    }
                    hued = true;
                } else if (ac.type == "fangpao") {
                    actionArr.push("放炮");
                } else if (ac.type == "angang") {
                    actionArr.push("暗杠");
                } else if (ac.type == "diangang") {
                    actionArr.push("明杠");
                } else if (ac.type == "wangang") {
                    actionArr.push("弯杠");
                } else if (ac.type == "fanggang") {
                    actionArr.push("放杠");
                } else if (ac.type == "zhuanshougang") {
                    actionArr.push("转手杠");
                } else if (ac.type == "beiqianggang") {
                    actionArr.push("被抢杠");
                } else if (ac.type == "beichadajiao") {
                    actionArr.push("被查叫");
                }
            }

            if (hued) {
                if (userData.qingyise) {
                    actionArr.push("清一色");
                }

                if (userData.menqing) {
                    actionArr.push("门清");
                }

                if (userData.zhongzhang) {
                    actionArr.push("中张");
                }

                if (userData.jingouhu) {
                    actionArr.push("金钩胡");
                }

                if (userData.haidihu) {
                    actionArr.push("海底胡");
                }

                if (userData.tianhu) {
                    actionArr.push("天胡");
                }

                if (userData.dihu) {
                    actionArr.push("地胡");
                }

                if (numOfGen > 0) {
                    actionArr.push("根x" + numOfGen);
                }

                if (ischadajiao) {
                    actionArr.push("查大叫");
                }

                if (userData.hunyise) {
                    actionArr.push("混一色");
                }

                if (userData.duiduihu) {
                    actionArr.push("对对胡");
                }

                if (userData.paihu) {
                    actionArr.push("排胡");
                }

                if (userData.gangshanghua) {
                    actionArr.push("杠上花");
                }

                if (userData.kan) {
                    actionArr.push("坎档");
                }

                if (userData.bian) {
                    actionArr.push("边档");
                }

                if (userData.dan) {
                    actionArr.push("单吊");
                }

                if (userData.duidao) {
                    actionArr.push("对倒");
                }
            }

            for (var o = 0; o < 3; ++o) {
                seatView.hu.children[o].active = false;
            }
            if (userData.huorder >= 0) {
                seatView.hu.children[userData.huorder].active = true;
            }

            seatView.username.string = cc.vv.gameNetMgr.seats[i].name;
            seatView.zhuang.active = cc.vv.gameNetMgr.button == i;
            seatView.reason.string = actionArr.join("、");

            //显示丝数台数
            seatView.taisi.string = "";

            //
            if (userData.score > 0) {
                seatView.score.string = "+" + userData.score;
            } else {
                seatView.score.string = userData.score;
            }

            var hupai = -1;
            if (hued) {
                hupai = userData.holds.pop();
            }

            cc.vv.mahjongmgr.sortMJ(userData.holds, userData.dingque);

            //胡牌不参与排序
            if (hued) {
                userData.holds.push(hupai);
            }

            //隐藏所有牌
            for (var k = 0; k < seatView.mahjongs.childrenCount; ++k) {
                var n = seatView.mahjongs.children[k];
                n.active = false;
            }

            var lackingNum = (userData.pengs.length + numOfGangs + userData.chis.length) * 3;
            //显示相关的牌
            for (var k = 0; k < userData.holds.length; ++k) {
                var pai = userData.holds[k];
                var n = seatView.mahjongs.children[k + lackingNum];
                n.active = true;
                var sprite = n.getComponent(cc.Sprite);
                sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
            }

            for (var k = 0; k < seatView._pengandgang.length; ++k) {
                seatView._pengandgang[k].active = false;
            }

            //初始化杠牌
            var index = 0;
            var gangs = userData.angangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "angang");
                index++;
            }

            var gangs = userData.diangangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "diangang");
                index++;
            }

            var gangs = userData.wangangs;
            for (var k = 0; k < gangs.length; ++k) {
                var mjid = gangs[k];
                this.initPengAndGangs(seatView, index, mjid, "wangang");
                index++;
            }

            //初始化碰牌
            var pengs = userData.pengs;
            if (pengs) {
                for (var k = 0; k < pengs.length; ++k) {
                    var mjid = pengs[k];
                    this.initPengAndGangs(seatView, index, mjid, "peng");
                    index++;
                }
            }

            //初始化吃牌
            var chis = userData.chis;
            if (chis) {
                for (var k = 0; k < chis.length; ++k) {
                    var mjid = chis[k];
                    this.initPengAndGangs(seatView, index, mjid, "chi");
                    index++;
                }
            }

            //初始化花牌 TODO:和下面一样写初始化函数 并且要首先隐藏所有的花

            var huas = userData.huas;
            var hua_node = this._gameover.getChildByName("result_list").getChildByName("s" + (i + 1)).getChildByName("huas");
            for (var k = 0; k < hua_node.childrenCount; ++k) {
                hua_node.children[k].active = false;
            }
            if (huas) {
                for (var k = 0; k < huas.length; ++k) {
                    var mjid = huas[k];
                    hua_node.children[k].active = true;
                    var sp = hua_node.children[k].getComponent(cc.Sprite);
                    sp.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", mjid);
                }
            }

            //东南西北小旗子转换
            var switchFengFlag = function switchFengFlag(direction, dir_str) {
                for (var k = 0; k < 4; k++) {
                    direction.children[k].active = false;
                }
                direction.getChildByName(dir_str).active = true;
            };

            //显示当前风圈和局数
            var numofgames = this._gameover.getChildByName("numofgames");
            var fengquan = "东风圈";
            switch (cc.vv.gameNetMgr.fengxiang) {
                case 0:
                    fengquan = "东风圈";break;
                case 1:
                    fengquan = "南风圈";break;
                case 2:
                    fengquan = "西风圈";break;
                case 3:
                    fengquan = "北风圈";break;
            }
            numofgames.getComponent(cc.Label).string = fengquan;

            //判断东南西北
            if (userData.button) {
                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + (i % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "dong");

                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + ((i + 1) % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "nan");

                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + ((i + 2) % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "xi");

                var direction = this._gameover.getChildByName("result_list").getChildByName("s" + ((i + 3) % 4 + 1)).getChildByName("direction");
                switchFengFlag(direction, "bei");
            }
        }
    },

    initPengAndGangs: function initPengAndGangs(seatView, index, mjid, flag) {
        var pgroot = null;
        if (seatView._pengandgang.length <= index) {
            pgroot = cc.instantiate(cc.vv.mahjongmgr.pengPrefabSelf);
            seatView._pengandgang.push(pgroot);
            seatView.mahjongs.addChild(pgroot);
        } else {
            pgroot = seatView._pengandgang[index];
            pgroot.active = true;
        }

        var sprites = pgroot.getComponentsInChildren(cc.Sprite);
        for (var s = 0; s < sprites.length; ++s) {
            var sprite = sprites[s];
            if (sprite.node.name == "gang") {
                var isGang = flag != "peng";
                sprite.node.active = isGang;
                sprite.node.scaleX = 1.0;
                sprite.node.scaleY = 1.0;
                if (flag == "angang") {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getEmptySpriteFrame("myself");
                    sprite.node.scaleX = 1.4;
                    sprite.node.scaleY = 1.4;
                } else {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("B_", mjid);
                }
            } else {
                if (flag == "peng") sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("B_", mjid);else if (flag == "chi") {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("B_", mjid[s]);
                } else {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("B_", mjid);
                }
            }
        }
        pgroot.x = index * 55 * 3 + index * 10;
    },

    onBtnReadyClicked: function onBtnReadyClicked() {
        console.log("onBtnReadyClicked");
        if (this._isGameEnd) {
            this._gameresult.active = true;
        } else {
            cc.vv.net.send('ready');
        }
        this._gameover.active = false;
    },

    onBtnShareClicked: function onBtnShareClicked() {
        console.log("onBtnShareClicked");
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"GameResult":[function(require,module,exports){
"use strict";
cc._RF.push(module, '2b08d8pm0VBDLYlZIdfLuPS', 'GameResult');
// scripts/components/GameResult.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _gameresult: null,
        _seats: []
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this._gameresult = this.node.getChildByName("game_result");
        //this._gameresult.active = false;

        var seats = this._gameresult.getChildByName("seats");
        for (var i = 0; i < seats.children.length; ++i) {
            this._seats.push(seats.children[i].getComponent("Seat"));
        }

        var btnClose = cc.find("Canvas/game_result/btnClose");
        if (btnClose) {
            cc.vv.utils.addClickEvent(btnClose, this.node, "GameResult", "onBtnCloseClicked");
        }

        var btnShare = cc.find("Canvas/game_result/btnShare");
        if (btnShare) {
            cc.vv.utils.addClickEvent(btnShare, this.node, "GameResult", "onBtnShareClicked");
        }

        //初始化网络事件监听器
        var self = this;
        this.node.on('game_end', function (data) {
            self.onGameEnd(data.detail);
        });
    },

    showResult: function showResult(seat, info, isZuiJiaPaoShou) {
        seat.node.getChildByName("zuijiapaoshou").active = isZuiJiaPaoShou;

        seat.node.getChildByName("zimocishu").getComponent(cc.Label).string = info.numzimo;
        seat.node.getChildByName("jiepaocishu").getComponent(cc.Label).string = info.numjiepao;
        seat.node.getChildByName("dianpaocishu").getComponent(cc.Label).string = info.numdianpao;
        seat.node.getChildByName("angangcishu").getComponent(cc.Label).string = info.numangang;
        seat.node.getChildByName("minggangcishu").getComponent(cc.Label).string = info.numminggang;
        //seat.node.getChildByName("chajiaocishu").getComponent(cc.Label).string = info.numchadajiao;
    },

    onGameEnd: function onGameEnd(endinfo) {
        var seats = cc.vv.gameNetMgr.seats;
        var maxscore = -1;
        var maxdianpao = 0;
        var dianpaogaoshou = -1;
        for (var i = 0; i < seats.length; ++i) {
            var seat = seats[i];
            if (seat.score > maxscore) {
                maxscore = seat.score;
            }
            if (endinfo[i].numdianpao > maxdianpao) {
                maxdianpao = endinfo[i].numdianpao;
                dianpaogaoshou = i;
            }
        }

        for (var i = 0; i < seats.length; ++i) {
            var seat = seats[i];
            var isBigwin = false;
            if (seat.score > 0) {
                isBigwin = seat.score == maxscore;
            }
            this._seats[i].setInfo(seat.name, seat.score, isBigwin);
            this._seats[i].setID(seat.userid);
            var isZuiJiaPaoShou = dianpaogaoshou == i;
            this.showResult(this._seats[i], endinfo[i], isZuiJiaPaoShou);
        }
    },

    onBtnCloseClicked: function onBtnCloseClicked() {
        cc.director.loadScene("hall");
    },

    onBtnShareClicked: function onBtnShareClicked() {
        cc.vv.anysdkMgr.shareResult();
    }
});

cc._RF.pop();
},{}],"Global":[function(require,module,exports){
"use strict";
cc._RF.push(module, '24e30ZJLgdH3rs1R1CvqN8U', 'Global');
// scripts/Global.js

"use strict";

var Global = cc.Class({
    extends: cc.Component,
    statics: {
        isstarted: false,
        netinited: false,
        userguid: 0,
        nickname: "",
        money: 0,
        lv: 0,
        roomId: 0

    }
});

cc._RF.pop();
},{}],"HTTP":[function(require,module,exports){
"use strict";
cc._RF.push(module, '90ae61J525JQIt5taF3Nce2', 'HTTP');
// scripts/HTTP.js

"use strict";

//local

// var URL = "http://192.168.0.115:9000";
var URL = "http://116.62.227.93:9000";
//DEV SERVER
//var URL = "http://139.219.224.143:9000";
//FORMAL SERVER
//var URL = "http://119.23.250.115:9000";

cc.VERSION = 20170609;
var HTTP = cc.Class({
    extends: cc.Component,

    statics: {
        sessionId: 0,
        userId: 0,
        master_url: URL,
        url: URL,
        sendRequest: function sendRequest(path, data, handler, extraUrl) {
            var xhr = cc.loader.getXMLHttpRequest();
            xhr.timeout = 5000;
            var str = "?";
            for (var k in data) {
                if (str != "?") {
                    str += "&";
                }
                str += k + "=" + data[k];
            }
            if (extraUrl == null) {
                extraUrl = HTTP.url;
            }
            var requestURL = extraUrl + path + encodeURI(str);
            console.log("RequestURL:" + requestURL);
            xhr.open("GET", requestURL, true);
            if (cc.sys.isNative) {
                xhr.setRequestHeader("Accept-Encoding", "gzip,deflate", "text/html;charset=UTF-8");
            }

            xhr.onreadystatechange = function () {
                console.log(xhr);
                if (xhr.readyState === 4 && xhr.status >= 200 && xhr.status < 300) {
                    console.log("http res(" + xhr.responseText.length + "):" + xhr.responseText);
                    try {
                        var ret = JSON.parse(xhr.responseText);
                        if (handler !== null) {
                            handler(ret);
                        } /* code */
                    } catch (e) {
                        console.log("err:" + e);
                        //handler(null);
                    } finally {
                        if (cc.vv && cc.vv.wc) {
                            //       cc.vv.wc.hide();    
                        }
                    }
                } else {
                    console.log("status=" + xhr.readyState);
                    //self.url = "http://139.219.224.143:9000";
                    //HTTP.url = "http://139.219.224.143:9000";
                }
            };

            if (cc.vv && cc.vv.wc) {
                //cc.vv.wc.show();
            }
            xhr.send();
            return xhr;
        }
    }
});

cc._RF.pop();
},{}],"Hall":[function(require,module,exports){
"use strict";
cc._RF.push(module, '6edb3jjx+FBepS1mk1xKDF2', 'Hall');
// scripts/components/Hall.js

"use strict";

var Net = require("Net");
var Global = require("Global");
cc.Class({
    extends: cc.Component,

    properties: {
        lblName: cc.Label,
        lblMoney: cc.Label,
        lblGems: cc.Label,
        lblID: cc.Label,
        lblNotice: cc.Label,
        joinGameWin: cc.Node,
        createRoomWin: cc.Node,
        settingsWin: cc.Node,
        helpWin: cc.Node,
        xiaoxiWin: cc.Node,
        btnJoinGame: cc.Node,
        btnReturnGame: cc.Node,
        sprHeadImg: cc.Sprite
    },

    initNetHandlers: function initNetHandlers() {
        var self = this;
    },

    onShare: function onShare() {
        cc.find("Canvas/ShareBox").active = false;
        cc.vv.anysdkMgr.share("舟山麻将", "舟山麻将，包含了沈家门麻将、定海麻将、推到胡等多种舟山流行麻将玩法。");
        var data = {
            userid: cc.vv.userMgr.userId,
            type: "share"
        };
        cc.vv.http.sendRequest("/share_get_gems", data, function (res) {
            console.log("share_get_gems");
            if (res.errcode.data.gems > 0) {
                cc.vv.alert.show("提示", "微信分享成功，获得" + res.errcode.data.gems + "钻");
                cc.vv.userMgr.gems += res.errcode.data.gems;
                cc.find("Canvas/top_left/headinfo/lblGems").getComponent(cc.Label).string = cc.vv.userMgr.gems;
            }
            cc.find("Canvas/ShareBox").active = false;
            console.log(res);
        });
    },

    onTimeline: function onTimeline() {
        cc.find("Canvas/ShareBox").active = false;
        cc.vv.anysdkMgr.shareOnTimeline("舟山麻将", "舟山麻将，包含了沈家门麻将、定海麻将、推到胡等多种舟山流行麻将玩法。");
        var data = {
            userid: cc.vv.userMgr.userId,
            type: "timeline"
        };
        cc.vv.http.sendRequest("/share_get_gems", data, function (res) {
            console.log("share_get_gems");
            if (res.errcode.data.gems > 0) {
                cc.vv.alert.show("提示", "微信分享到朋友圈成功，获得" + res.errcode.data.gems + "钻");
                cc.vv.userMgr.gems += res.errcode.data.gems;
                cc.find("Canvas/top_left/headinfo/lblGems").getComponent(cc.Label).string = cc.vv.userMgr.gems;
            }
            cc.find("Canvas/ShareBox").active = false;
            console.log(res);
        });
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = this.node.getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }
        if (!cc.vv) {
            cc.director.loadScene("loading");
            return;
        }
        this.initLabels();

        if (cc.vv.gameNetMgr.roomId == null) {
            this.btnJoinGame.active = true;
            this.btnReturnGame.active = false;
        } else {
            this.btnJoinGame.active = false;
            this.btnReturnGame.active = true;
        }

        //var params = cc.vv.args;
        var roomId = cc.vv.userMgr.oldRoomId;
        if (roomId != null) {
            cc.vv.userMgr.oldRoomId = null;
            cc.vv.userMgr.enterRoom(roomId);
        }

        var imgLoader = this.sprHeadImg.node.getComponent("ImageLoader");
        imgLoader.setUserID(cc.vv.userMgr.userId);
        cc.vv.utils.addClickEvent(this.sprHeadImg.node, this.node, "Hall", "onBtnClicked");

        this.addComponent("UserInfoShow");

        this.initButtonHandler("Canvas/right_bottom/btn_shezhi");
        this.initButtonHandler("Canvas/right_bottom/btn_help");
        this.initButtonHandler("Canvas/right_bottom/btn_xiaoxi");
        this.helpWin.addComponent("OnBack");
        this.xiaoxiWin.addComponent("OnBack");

        if (!cc.vv.userMgr.notice) {
            cc.vv.userMgr.notice = {
                version: null,
                msg: "数据请求中..."
            };
        }

        if (!cc.vv.userMgr.gemstip) {
            cc.vv.userMgr.gemstip = {
                version: null,
                msg: "数据请求中..."
            };
        }

        this.lblNotice.string = cc.vv.userMgr.notice.msg;

        this.refreshInfo();
        this.refreshNotice();
        this.refreshGemsTip();

        cc.vv.audioMgr.playBGM("bgMain.mp3");

        //初始化签到信息
        this.initCheckin();

        //预加载麻将游戏界面
        cc.director.preloadScene('mjgame', function () {
            cc.log('preload mjgame complete!!!');
        });

        var youkeorweixin = cc.sys.localStorage.getItem("youkeorweixin");
        if (cc.sys.os == cc.sys.OS_IOS && youkeorweixin == "0") {
            //隐藏显示下边按钮
            cc.find("Canvas/hallBg/fujianmajiang").active = false;
            cc.find("Canvas/hallBg/anhuimajiang").active = false;
            cc.find("Canvas/hallBg/qiqibuyu").active = false;
            cc.find("Canvas/hallBg/qiqipuke").active = false;
            cc.find("Canvas/hallBg/more").active = false;
            cc.find("Canvas/hallBg/xixia001").active = false;
            // cc.find("Canvas/top_left/headinfo/bg").active = false;
            // cc.find("Canvas/top_left/headinfo/gems").active = false;
            // cc.find("Canvas/top_left/headinfo/btn_add_gems").active = false;
            // cc.find("Canvas/top_left/headinfo/lblGems").active = false;
            cc.find("Canvas/right_bottom/btn_zhanji").active = false;
            cc.find("Canvas/right_bottom/btn_share").active = false;
            cc.find("Canvas/right_bottom/btn_checkin").active = false;
            // cc.find("Canvas/CreateRoom/sjmmj/cost").active = false;
            // cc.find("Canvas/CreateRoom/dhmj/cost").active = false;
            // cc.find("Canvas/CreateRoom/tdh/cost").active = false;
            cc.find("Canvas/CreateRoom/bg/New Label").active = false;
            cc.vv.utils.showAct = false;
        }

        if (cc.vv.utils.showAct) {
            cc.find("Canvas/Activity").active = true;
        }
    },

    //初始化签到信息
    initCheckin: function initCheckin() {
        //获取签到信息
        var data = {
            userid: cc.vv.userMgr.userId
        };
        cc.vv.http.sendRequest("/get_checkin_status", data, function (res) {
            console.log("get_checkin_status");
            console.log(res);
            //当前已签到次数
            var checkin_days = res.errcode.data.checkin_days;
            //上次签到时间
            var checkin_date = res.errcode.data.checkin_data;
            //当前日期
            var d = new Date();
            var y = d.getFullYear();
            var m = d.getMonth() + 1;
            m = m < 10 ? "0" + m : m;
            var day = d.getDate();
            day = day < 10 ? "0" + day : day;
            var nowdate = y + "-" + m + "-" + day;

            //获取7天的签到图片
            var days = cc.find("Canvas/CheckinBox/bg").children;
            var checkin_days = checkin_days % 7;
            for (var i = 0; i < checkin_days; i++) {
                days[i].getChildByName("hascheckin").active = true;
                days[i].getComponent(cc.Button).interactable = false;
                days[i].color = new cc.Color(168, 168, 168);
                days[i].opacity = 255;
            }
            for (var i = checkin_days; i < 7; i++) {
                days[i].getChildByName("hascheckin").active = false;
                days[i].getComponent(cc.Button).interactable = false;
                days[i].color = new cc.Color(255, 255, 255);
                days[i].opacity = 160;
            }
            if (checkin_date != nowdate) {
                days[checkin_days].opacity = 255;
                days[checkin_days].getComponent(cc.Button).interactable = true;
            }
        });
    },

    openShareBox: function openShareBox() {
        cc.find("Canvas/ShareBox").active = true;
    },

    closeShareBox: function closeShareBox() {
        cc.find("Canvas/ShareBox").active = false;
    },

    closeActivity: function closeActivity() {
        cc.find("Canvas/Activity").active = false;
        cc.vv.utils.showAct = false;
    },

    onDaysClicked: function onDaysClicked() {
        console.log("onDaysClicked");
        //隐藏签到面板
        cc.find("Canvas/CheckinBox").active = false;
        //发送请求
        var data = {
            userid: cc.vv.userMgr.userId
        };
        var self = this;
        cc.vv.http.sendRequest("/checkin", data, function (res) {
            var addgems = res.errcode.data.gems;
            self.initCheckin();
            cc.vv.alert.show("提示", "签到成功，获得" + addgems + "钻");
            cc.vv.userMgr.gems += addgems;
            cc.find("Canvas/top_left/headinfo/lblGems").getComponent(cc.Label).string = cc.vv.userMgr.gems;
        });
    },

    refreshInfo: function refreshInfo() {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                if (ret.gems != null) {
                    this.lblGems.string = ret.gems;
                }
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign
        };
        cc.vv.http.sendRequest("/get_user_status", data, onGet.bind(this));
    },

    refreshGemsTip: function refreshGemsTip() {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                cc.vv.userMgr.gemstip.version = ret.version;
                cc.vv.userMgr.gemstip.msg = ret.msg.replace("<newline>", "\n");
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            type: "fkgm",
            version: cc.vv.userMgr.gemstip.version
        };
        cc.vv.http.sendRequest("/get_message", data, onGet.bind(this));
    },

    refreshNotice: function refreshNotice() {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                cc.vv.userMgr.notice.version = ret.version;
                cc.vv.userMgr.notice.msg = ret.msg;
                this.lblNotice.string = ret.msg;
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            type: "notice",
            version: cc.vv.userMgr.notice.version
        };
        cc.vv.http.sendRequest("/get_message", data, onGet.bind(this));
    },

    initButtonHandler: function initButtonHandler(btnPath) {
        var btn = cc.find(btnPath);
        cc.vv.utils.addClickEvent(btn, this.node, "Hall", "onBtnClicked");
    },

    initLabels: function initLabels() {
        this.lblName.string = cc.vv.userMgr.userName;
        this.lblMoney.string = cc.vv.userMgr.coins;
        this.lblGems.string = cc.vv.userMgr.gems;
        this.lblID.string = "ID:" + cc.vv.userMgr.userId;
    },

    onBtnClicked: function onBtnClicked(event) {
        if (event.target.name == "btn_shezhi") {
            this.settingsWin.active = true;
        } else if (event.target.name == "btn_help") {
            this.helpWin.active = true;
        } else if (event.target.name == "btn_xiaoxi") {
            this.xiaoxiWin.active = true;
        } else if (event.target.name == "head") {
            cc.vv.userinfoShow.show(cc.vv.userMgr.userName, cc.vv.userMgr.userId, this.sprHeadImg, cc.vv.userMgr.sex, cc.vv.userMgr.ip);
        }
    },

    onJoinGameClicked: function onJoinGameClicked() {
        this.joinGameWin.active = true;
    },

    onReturnGameClicked: function onReturnGameClicked() {
        var loadgame = function loadgame() {
            cc.director.loadScene("mjgame");
        };
        var fadeout = cc.fadeOut(0.1);
        var finish = cc.callFunc(loadgame, this);
        var seq = cc.sequence(fadeout, finish);
        this.node.runAction(seq);
    },

    onBtnAddGemsClicked: function onBtnAddGemsClicked() {
        // cc.vv.alert.show("提示",cc.vv.userMgr.gemstip.msg);
        // this.refreshInfo();
        cc.log("apple 内购");

        if (cc.sys.isNative && cc.sys.os == cc.sys.OS_IOS) {
            var ret = jsb.reflection.callStaticMethod("AdMaster", "showAd:title:", "apple", "内购");
        }
    },

    onCreateRoomClicked: function onCreateRoomClicked() {
        if (cc.vv.gameNetMgr.roomId != null) {
            cc.vv.alert.show("提示", "房间已经创建!\n必须解散当前房间才能创建新的房间");
            return;
        }
        console.log("onCreateRoomClicked");
        this.createRoomWin.active = true;
    },

    onCheckinClicked: function onCheckinClicked() {
        cc.find("Canvas/CheckinBox").active = true;
    },
    onCheckinClose: function onCheckinClose() {
        cc.find("Canvas/CheckinBox").active = false;
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        var x = this.lblNotice.node.x;
        x -= dt * 100;
        if (x + this.lblNotice.node.width < -1000) {
            x = 500;
        }
        this.lblNotice.node.x = x;

        if (cc.vv && cc.vv.userMgr.roomData != null) {
            cc.vv.userMgr.enterRoom(cc.vv.userMgr.roomData);
            cc.vv.userMgr.roomData = null;
        }
    }
});

cc._RF.pop();
},{"Global":"Global","Net":"Net"}],"History":[function(require,module,exports){
(function (Buffer){
"use strict";
cc._RF.push(module, '4d7bci0LUxMT6MJKXJDj89w', 'History');
// scripts/components/History.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        HistoryItemPrefab: {
            default: null,
            type: cc.Prefab
        },
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _history: null,
        _viewlist: null,
        _content: null,
        _viewitemTemp: null,
        _historyData: null,
        _curRoomInfo: null,
        _emptyTip: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._history = this.node.getChildByName("history");
        this._history.active = false;

        this._emptyTip = this._history.getChildByName("emptyTip");
        this._emptyTip.active = true;

        this._viewlist = this._history.getChildByName("viewlist");
        this._content = cc.find("view/content", this._viewlist);

        this._viewitemTemp = this._content.children[0];
        this._content.removeChild(this._viewitemTemp);

        var node = cc.find("Canvas/right_bottom/btn_zhanji");
        this.addClickEvent(node, this.node, "History", "onBtnHistoryClicked");

        var node = cc.find("Canvas/history/btn_back");
        this.addClickEvent(node, this.node, "History", "onBtnBackClicked");
    },

    addClickEvent: function addClickEvent(node, target, component, handler) {
        var eventHandler = new cc.Component.EventHandler();
        eventHandler.target = target;
        eventHandler.component = component;
        eventHandler.handler = handler;

        var clickEvents = node.getComponent(cc.Button).clickEvents;
        clickEvents.push(eventHandler);
    },

    onBtnBackClicked: function onBtnBackClicked() {
        if (this._curRoomInfo == null) {
            this._historyData = null;
            this._history.active = false;
        } else {
            this.initRoomHistoryList(this._historyData);
        }
    },

    onBtnHistoryClicked: function onBtnHistoryClicked() {
        this._history.active = true;
        var self = this;
        cc.vv.userMgr.getHistoryList(function (data) {
            data.sort(function (a, b) {
                return a.time < b.time;
            });
            self._historyData = data;
            for (var i = 0; i < data.length; ++i) {
                for (var j = 0; j < 4; ++j) {
                    var s = data[i].seats[j];
                    s.name = new Buffer(s.name, 'base64').toString();
                }
            }
            self.initRoomHistoryList(data);
        });
    },

    dateFormat: function dateFormat(time) {
        var date = new Date(time);
        var datetime = "{0}-{1}-{2} {3}:{4}:{5}";
        var year = date.getFullYear();
        var month = date.getMonth() + 1;
        month = month >= 10 ? month : "0" + month;
        var day = date.getDate();
        day = day >= 10 ? day : "0" + day;
        var h = date.getHours();
        h = h >= 10 ? h : "0" + h;
        var m = date.getMinutes();
        m = m >= 10 ? m : "0" + m;
        var s = date.getSeconds();
        s = s >= 10 ? s : "0" + s;
        datetime = datetime.format(year, month, day, h, m, s);
        return datetime;
    },

    initRoomHistoryList: function initRoomHistoryList(data) {
        console.log("initRoomHistoryList");
        for (var i = 0; i < data.length; ++i) {
            var node = this.getViewItem(i);
            node.idx = i;
            var titleId = "" + (i + 1);
            node.getChildByName("title").getComponent(cc.Label).string = titleId;
            node.getChildByName("roomNo").getComponent(cc.Label).string = "房间ID:" + data[i].id;
            var datetime = this.dateFormat(data[i].time * 1000);
            node.getChildByName("time").getComponent(cc.Label).string = datetime;

            console.log(1);

            var btnOp = node.getChildByName("btnOp");
            btnOp.idx = i;
            //btnOp.getChildByName("Label").getComponent(cc.Label).string = "详情";

            console.log(2);

            for (var j = 0; j < 4; ++j) {
                var s = data[i].seats[j];
                var info = s.name + ":" + s.score;
                //console.log(info);
                node.getChildByName("info" + j).getComponent(cc.Label).string = info;
            }

            console.log(3);
        }
        this._emptyTip.active = data.length == 0;
        console.log(this._emptyTip.active);
        this.shrinkContent(data.length);
        this._curRoomInfo = null;
    },

    initGameHistoryList: function initGameHistoryList(roomInfo, data) {
        console.log("initGameHistoryList");
        data.sort(function (a, b) {
            return a.create_time < b.create_time;
        });
        for (var i = 0; i < data.length; ++i) {
            var node = this.getViewItem(i);
            var idx = data.length - i - 1;
            node.idx = idx;
            var titleId = "" + (idx + 1);
            node.getChildByName("title").getComponent(cc.Label).string = titleId;
            node.getChildByName("roomNo").getComponent(cc.Label).string = "房间ID:" + roomInfo.id;
            var datetime = this.dateFormat(data[i].create_time * 1000);
            node.getChildByName("time").getComponent(cc.Label).string = datetime;

            var btnOp = node.getChildByName("btnOp");
            btnOp.idx = idx;
            //btnOp.getChildByName("Label").getComponent(cc.Label).string = "回放";

            var result = JSON.parse(data[i].result);
            for (var j = 0; j < 4; ++j) {
                var s = roomInfo.seats[j];
                var info = s.name + ":" + result[j];
                //console.log(info);
                node.getChildByName("info" + j).getComponent(cc.Label).string = info;
            }
        }
        this.shrinkContent(data.length);
        this._curRoomInfo = roomInfo;
    },

    getViewItem: function getViewItem(index) {
        var content = this._content;
        if (content.childrenCount > index) {
            return content.children[index];
        }
        var node = cc.instantiate(this._viewitemTemp);
        content.addChild(node);
        return node;
    },
    shrinkContent: function shrinkContent(num) {
        while (this._content.childrenCount > num) {
            var lastOne = this._content.children[this._content.childrenCount - 1];
            this._content.removeChild(lastOne, true);
        }
    },

    getGameListOfRoom: function getGameListOfRoom(idx) {
        var self = this;
        var roomInfo = this._historyData[idx];
        cc.vv.userMgr.getGamesOfRoom(roomInfo.uuid, function (data) {
            if (data != null && data.length > 0) {
                self.initGameHistoryList(roomInfo, data);
            }
        });
    },

    getDetailOfGame: function getDetailOfGame(idx) {
        var self = this;
        var roomUUID = this._curRoomInfo.uuid;
        cc.vv.userMgr.getDetailOfGame(roomUUID, idx, function (data) {
            data.base_info = JSON.parse(data.base_info);
            data.action_records = JSON.parse(data.action_records);
            cc.vv.gameNetMgr.prepareReplay(self._curRoomInfo, data);
            cc.vv.replayMgr.init(data);
            cc.director.loadScene("mjgame");
        });
    },

    onViewItemClicked: function onViewItemClicked(event) {
        var idx = event.target.idx;
        console.log(idx);
        if (this._curRoomInfo == null) {
            this.getGameListOfRoom(idx);
        } else {
            this.getDetailOfGame(idx + 1);
        }
    },

    onBtnOpClicked: function onBtnOpClicked(event) {
        var idx = event.target.parent.idx;
        console.log(idx);
        if (this._curRoomInfo == null) {
            this.getGameListOfRoom(idx);
        } else {
            this.getDetailOfGame(idx + 1);
        }
    }

});

cc._RF.pop();
}).call(this,require("buffer").Buffer)

},{"buffer":3}],"HotUpdate":[function(require,module,exports){
"use strict";
cc._RF.push(module, '17141EodNRM/4IpsE04IyCU', 'HotUpdate');
// scripts/HotUpdate.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        updatePanel: {
            default: null,
            type: cc.Node
        },
        manifestUrl: {
            default: null,
            url: cc.RawAsset
        },
        percent: {
            default: null,
            type: cc.Label
        },
        lblErr: {
            default: null,
            type: cc.Label
        }
    },

    checkCb: function checkCb(event) {
        cc.log('Code: ' + event.getEventCode());
        switch (event.getEventCode()) {
            case jsb.EventAssetsManager.ERROR_NO_LOCAL_MANIFEST:
                cc.log("No local manifest file found, hot update skipped.");
                cc.eventManager.removeListener(this._checkListener);
                break;
            case jsb.EventAssetsManager.ERROR_DOWNLOAD_MANIFEST:
            case jsb.EventAssetsManager.ERROR_PARSE_MANIFEST:
                cc.log("Fail to download manifest file, hot update skipped.");
                cc.eventManager.removeListener(this._checkListener);
                break;
            case jsb.EventAssetsManager.ALREADY_UP_TO_DATE:
                cc.log("Already up to date with the latest remote version.");
                cc.eventManager.removeListener(this._checkListener);
                this.lblErr.string += "游戏不需要更新\n";
                cc.director.loadScene("loading");
                break;
            case jsb.EventAssetsManager.NEW_VERSION_FOUND:
                this._needUpdate = true;
                this.updatePanel.active = true;
                this.percent.string = '00.00%';
                cc.eventManager.removeListener(this._checkListener);
                break;
            default:
                break;
        }
        this.hotUpdate();
    },

    updateCb: function updateCb(event) {
        var needRestart = false;
        var failed = false;
        switch (event.getEventCode()) {
            case jsb.EventAssetsManager.ERROR_NO_LOCAL_MANIFEST:
                cc.log('No local manifest file found, hot update skipped.');
                failed = true;
                break;
            case jsb.EventAssetsManager.UPDATE_PROGRESSION:
                var percent = event.getPercent();
                var percentByFile = event.getPercentByFile();

                var msg = event.getMessage();
                if (msg) {
                    cc.log(msg);
                }
                cc.log(percent.toFixed(2) + '%');
                this.percent.string = percent + '%';
                break;
            case jsb.EventAssetsManager.ERROR_DOWNLOAD_MANIFEST:
            case jsb.EventAssetsManager.ERROR_PARSE_MANIFEST:
                cc.log('Fail to download manifest file, hot update skipped.');
                failed = true;
                break;
            case jsb.EventAssetsManager.ALREADY_UP_TO_DATE:
                cc.log('Already up to date with the latest remote version.');
                failed = true;
                break;
            case jsb.EventAssetsManager.UPDATE_FINISHED:
                cc.log('Update finished. ' + event.getMessage());

                needRestart = true;
                break;
            case jsb.EventAssetsManager.UPDATE_FAILED:
                cc.log('Update failed. ' + event.getMessage());

                this._failCount++;
                if (this._failCount < 5) {
                    this._am.downloadFailedAssets();
                } else {
                    cc.log('Reach maximum fail count, exit update process');
                    this._failCount = 0;
                    failed = true;
                }
                break;
            case jsb.EventAssetsManager.ERROR_UPDATING:
                cc.log('Asset update error: ' + event.getAssetId() + ', ' + event.getMessage());
                break;
            case jsb.EventAssetsManager.ERROR_DECOMPRESS:
                cc.log(event.getMessage());
                break;
            default:
                break;
        }

        if (failed) {
            cc.eventManager.removeListener(this._updateListener);
            this.updatePanel.active = false;
        }

        if (needRestart) {
            cc.eventManager.removeListener(this._updateListener);
            // Prepend the manifest's search path
            var searchPaths = jsb.fileUtils.getSearchPaths();
            var newPaths = this._am.getLocalManifest().getSearchPaths();
            Array.prototype.unshift(searchPaths, newPaths);
            // This value will be retrieved and appended to the default search path during game startup,
            // please refer to samples/js-tests/main.js for detailed usage.
            // !!! Re-add the search paths in main.js is very important, otherwise, new scripts won't take effect.
            cc.sys.localStorage.setItem('HotUpdateSearchPaths', JSON.stringify(searchPaths));

            jsb.fileUtils.setSearchPaths(searchPaths);
            this.lblErr.string += "游戏资源更新完毕\n";
            cc.game.restart();
        }
    },

    hotUpdate: function hotUpdate() {
        if (this._am && this._needUpdate) {
            this.lblErr.string += "开始更新游戏资源...\n";
            this._updateListener = new jsb.EventListenerAssetsManager(this._am, this.updateCb.bind(this));
            cc.eventManager.addListener(this._updateListener, 1);

            this._failCount = 0;
            this._am.update();
        }
    },

    // use this for initialization
    onLoad: function onLoad() {
        // Hot update is only available in Native build
        if (!cc.sys.isNative) {
            return;
        }
        this.lblErr.string += "检查游戏资源...\n";
        var storagePath = (jsb.fileUtils ? jsb.fileUtils.getWritablePath() : '/') + 'tiantianqipai-asset';
        cc.log('Storage path for remote asset : ' + storagePath);
        this.lblErr.string += storagePath + "\n";
        cc.log('Local manifest URL : ' + this.manifestUrl);
        this._am = new jsb.AssetsManager(this.manifestUrl, storagePath);
        this._am.retain();

        this._needUpdate = false;
        if (this._am.getLocalManifest().isLoaded()) {
            this._checkListener = new jsb.EventListenerAssetsManager(this._am, this.checkCb.bind(this));
            cc.eventManager.addListener(this._checkListener, 1);

            this._am.checkUpdate();
        }
    },

    onDestroy: function onDestroy() {
        this._am && this._am.release();
    }
});

cc._RF.pop();
},{}],"HuanSanZhang":[function(require,module,exports){
"use strict";
cc._RF.push(module, '9a096oAgU5HwrxX05ZPNYtW', 'HuanSanZhang');
// scripts/components/HuanSanZhang.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _huanpaitip: null,
        _huanpaiArr: []
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._huanpaitip = cc.find("Canvas/huansanzhang");
        this._huanpaitip.active = cc.vv.gameNetMgr.isHuanSanZhang;

        if (this._huanpaitip.active) {
            this.showHuanpai(cc.vv.gameNetMgr.getSelfData().huanpais == null);
        }
        this.initHuaipaiInfo();

        var btnOk = cc.find("Canvas/huansanzhang/btn_ok");
        if (btnOk) {
            cc.vv.utils.addClickEvent(btnOk, this.node, "HuanSanZhang", "onHuanSanZhang");
        }

        var self = this;

        this.node.on('game_huanpai', function (data) {
            self._huanpaitip.active = true;
            self.showHuanpai(true);
        });

        this.node.on('huanpai_notify', function (data) {
            if (data.detail.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initHuaipaiInfo();
            }
        });

        this.node.on('game_huanpai_over', function (data) {
            self._huanpaitip.active = false;
            for (var i = 0; i < self._huanpaiArr.length; ++i) {
                self._huanpaiArr[i].y = 0;
            }
            self._huanpaiArr = [];
            self.initHuaipaiInfo();
        });

        this.node.on('game_huanpai_result', function (data) {
            cc.vv.gameNetMgr.isHuanSanZhang = false;
            self._huanpaitip.active = false;
            for (var i = 0; i < self._huanpaiArr.length; ++i) {
                self._huanpaiArr[i].y = 0;
            }
            self._huanpaiArr = [];
        });

        this.node.on('mj_clicked', function (data) {
            var target = data.detail;
            //如果已经点起来，则取消
            var idx = self._huanpaiArr.indexOf(target);
            if (idx != -1) {
                target.y = 0;
                self._huanpaiArr.splice(idx, 1);
            } else {
                //如果是新的，则加入
                if (self._huanpaiArr.length < 3) {
                    self._huanpaiArr.push(target);
                    target.y = 15;
                }
            }
        });
    },

    showHuanpai: function showHuanpai(interactable) {
        this._huanpaitip.getChildByName("info").getComponent(cc.Label).string = "请选择三张一样花色的牌";
        this._huanpaitip.getChildByName("btn_ok").getComponent(cc.Button).interactable = interactable;
        this._huanpaitip.getChildByName("mask").active = false;
    },

    initHuaipaiInfo: function initHuaipaiInfo() {
        var huaipaiinfo = cc.find("Canvas/game/huanpaiinfo");
        var seat = cc.vv.gameNetMgr.getSelfData();
        if (seat.huanpais == null) {
            huaipaiinfo.active = false;
            return;
        }
        huaipaiinfo.active = true;
        for (var i = 0; i < seat.huanpais.length; ++i) {
            huaipaiinfo.getChildByName("hp" + (i + 1)).getComponent(cc.Sprite).spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", seat.huanpais[i]);
        }

        var hpm = huaipaiinfo.getChildByName("hpm");
        hpm.active = true;
        if (cc.vv.gameNetMgr.huanpaimethod == 0) {
            hpm.rotation = 90;
        } else if (cc.vv.gameNetMgr.huanpaimethod == 1) {
            hpm.rotation = 0;
        } else if (cc.vv.gameNetMgr.huanpaimethod == 2) {
            hpm.rotation = 180;
        } else {
            hpm.active = false;
        }
    },

    onHuanSanZhang: function onHuanSanZhang(event) {
        if (this._huanpaiArr.length != 3) {
            return;
        }

        var type = null;
        for (var i = 0; i < this._huanpaiArr.length; ++i) {
            var pai = this._huanpaiArr[i].mjId;
            var nt = cc.vv.mahjongmgr.getMahjongType(pai);
            if (type == null) {
                type = nt;
            } else {
                if (type != nt) {
                    return;
                }
            }
        }

        var data = {
            p1: this._huanpaiArr[0].mjId,
            p2: this._huanpaiArr[1].mjId,
            p3: this._huanpaiArr[2].mjId
        };

        this._huanpaitip.getChildByName("info").getComponent(cc.Label).string = "等待其他玩家选牌...";
        this._huanpaitip.getChildByName("btn_ok").getComponent(cc.Button).interactable = false;
        this._huanpaitip.getChildByName("mask").active = true;

        cc.vv.net.send("huanpai", data);
    }

});

cc._RF.pop();
},{}],"ImageLoader":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'ed057Bgp8FHlJbGI+ljAN7d', 'ImageLoader');
// scripts/components/ImageLoader.js

"use strict";

function loadImage(url, code, callback) {
    /*
    if(cc.vv.images == null){
        cc.vv.images = {};
    }
    var imageInfo = cc.vv.images[url];
    if(imageInfo == null){
        imageInfo = {
            image:null,
            queue:[],
        };
        cc.vv.images[url] = imageInfo;
    }
    
    cc.loader.load(url,function (err,tex) {
        imageInfo.image = tex;
        var spriteFrame = new cc.SpriteFrame(tex, cc.Rect(0, 0, tex.width, tex.height));
        for(var i = 0; i < imageInfo.queue.length; ++i){
            var itm = imageInfo.queue[i];
            itm.callback(itm.code,spriteFrame);
        }
        itm.queue = [];
    });
    if(imageInfo.image != null){
        var tex = imageInfo.image;
        var spriteFrame = new cc.SpriteFrame(tex, cc.Rect(0, 0, tex.width, tex.height));
        callback(code,spriteFrame);
    }
    else{
        imageInfo.queue.push({code:code,callback:callback});
    }*/
    cc.loader.load(url, function (err, tex) {
        var spriteFrame = new cc.SpriteFrame(tex, cc.Rect(0, 0, tex.width, tex.height));
        callback(code, spriteFrame);
    });
};

function getBaseInfo(userid, callback) {
    if (cc.vv.baseInfoMap == null) {
        cc.vv.baseInfoMap = {};
    }

    if (cc.vv.baseInfoMap[userid] != null) {
        callback(userid, cc.vv.baseInfoMap[userid]);
    } else {
        cc.vv.http.sendRequest('/base_info', { userid: userid }, function (ret) {
            var url = null;
            if (ret.headimgurl) {
                url = ret.headimgurl + ".jpg";
            }
            var info = {
                name: ret.name,
                sex: ret.sex,
                url: url
            };
            cc.vv.baseInfoMap[userid] = info;
            callback(userid, info);
        }, cc.vv.http.master_url);
    }
};

cc.Class({
    extends: cc.Component,
    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {
        this.setupSpriteFrame();
    },

    setUserID: function setUserID(userid) {
        if (cc.sys.isNative == false) {
            return;
        }
        if (!userid) {
            return;
        }
        if (cc.vv.images == null) {
            cc.vv.images = {};
        }

        var self = this;
        getBaseInfo(userid, function (code, info) {
            if (info && info.url) {
                loadImage(info.url, userid, function (err, spriteFrame) {
                    self._spriteFrame = spriteFrame;
                    self.setupSpriteFrame();
                });
            }
        });
    },

    setupSpriteFrame: function setupSpriteFrame() {
        if (this._spriteFrame) {
            var spr = this.getComponent(cc.Sprite);
            if (spr) {
                spr.spriteFrame = this._spriteFrame;
            }
        }
    }
    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"JoinGameInput":[function(require,module,exports){
"use strict";
cc._RF.push(module, '10a1c8jz95Ju4NnpkOWUfin', 'JoinGameInput');
// scripts/components/JoinGameInput.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        nums: {
            default: [],
            type: [cc.Label]
        },
        _inputIndex: 0
    },

    // use this for initialization
    onLoad: function onLoad() {},

    onEnable: function onEnable() {
        this.onResetClicked();
    },

    onInputFinished: function onInputFinished(roomId) {
        cc.vv.userMgr.enterRoom(roomId, function (ret) {
            if (ret.errcode == 0) {
                this.node.active = false;
            } else {
                var content = "房间[" + roomId + "]不存在，请重新输入!";
                if (ret.errcode == 4) {
                    content = "房间[" + roomId + "]已满!";
                }
                if (ret.errcode == 5) {
                    content = "钻石不足请充值！";
                }
                cc.vv.alert.show("提示", content);
                this.onResetClicked();
            }
        }.bind(this));
    },

    onInput: function onInput(num) {
        if (this._inputIndex >= this.nums.length) {
            return;
        }
        this.nums[this._inputIndex].string = num;
        this._inputIndex += 1;

        if (this._inputIndex == this.nums.length) {
            var roomId = this.parseRoomID();
            console.log("ok:" + roomId);
            this.onInputFinished(roomId);
        }
    },

    onN0Clicked: function onN0Clicked() {
        this.onInput(0);
    },
    onN1Clicked: function onN1Clicked() {
        this.onInput(1);
    },
    onN2Clicked: function onN2Clicked() {
        this.onInput(2);
    },
    onN3Clicked: function onN3Clicked() {
        this.onInput(3);
    },
    onN4Clicked: function onN4Clicked() {
        this.onInput(4);
    },
    onN5Clicked: function onN5Clicked() {
        this.onInput(5);
    },
    onN6Clicked: function onN6Clicked() {
        this.onInput(6);
    },
    onN7Clicked: function onN7Clicked() {
        this.onInput(7);
    },
    onN8Clicked: function onN8Clicked() {
        this.onInput(8);
    },
    onN9Clicked: function onN9Clicked() {
        this.onInput(9);
    },
    onResetClicked: function onResetClicked() {
        for (var i = 0; i < this.nums.length; ++i) {
            this.nums[i].string = "";
        }
        this._inputIndex = 0;
    },
    onDelClicked: function onDelClicked() {
        if (this._inputIndex > 0) {
            this._inputIndex -= 1;
            this.nums[this._inputIndex].string = "";
        }
    },
    onCloseClicked: function onCloseClicked() {
        this.node.active = false;
    },

    parseRoomID: function parseRoomID() {
        var str = "";
        for (var i = 0; i < this.nums.length; ++i) {
            str += this.nums[i].string;
        }
        return str;
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"LoadingLogic":[function(require,module,exports){
"use strict";
cc._RF.push(module, '350d3Ry9aVIqJR27fP2H/z1', 'LoadingLogic');
// scripts/components/LoadingLogic.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        tipLabel: cc.Label,
        _stateStr: '',
        _progress: 0.0,
        _splash: null,
        _isLoading: false
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = this.node.getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }
        this.initMgr();
        this.tipLabel.string = this._stateStr;

        this._splash = cc.find("Canvas/splash");
        this._splash.active = true;

        cc.vv.http.sendRequest("/mj_login", 1, function (data) {
            cc.sys.localStorage.setItem("youkeorweixin", data.data.youkeorweixin);
            if (cc.sys.localStorage.getItem("youkeorweixin") == "0" && cc.sys.os == cc.sys.OS_IOS) {
                cc.find("Canvas/New Label").active = false;
            }
        });
    },

    start: function start() {
        var self = this;
        var SHOW_TIME = 3000;
        var FADE_TIME = 500;
        if (cc.sys.os != cc.sys.OS_IOS || !cc.sys.isNative) {
            self._splash.active = true;
            var t = Date.now();
            var fn = function fn() {
                var dt = Date.now() - t;
                if (dt < SHOW_TIME) {
                    setTimeout(fn, 33);
                } else {
                    var op = (1 - (dt - SHOW_TIME) / FADE_TIME) * 255;
                    if (op < 0) {
                        self._splash.opacity = 0;
                        self.checkVersion();
                    } else {
                        self._splash.opacity = op;
                        setTimeout(fn, 33);
                    }
                }
            };
            setTimeout(fn, 33);
        } else {
            this._splash.active = false;
            this.checkVersion();
        }
    },

    initMgr: function initMgr() {
        cc.vv = {};
        var UserMgr = require("UserMgr");
        cc.vv.userMgr = new UserMgr();

        var ReplayMgr = require("ReplayMgr");
        cc.vv.replayMgr = new ReplayMgr();

        cc.vv.http = require("HTTP");
        cc.vv.global = require("Global");
        cc.vv.net = require("Net");

        var GameNetMgr = require("GameNetMgr");
        cc.vv.gameNetMgr = new GameNetMgr();
        cc.vv.gameNetMgr.initHandlers();

        var AnysdkMgr = require("AnysdkMgr");
        cc.vv.anysdkMgr = new AnysdkMgr();
        cc.vv.anysdkMgr.init();

        var VoiceMgr = require("VoiceMgr");
        cc.vv.voiceMgr = new VoiceMgr();
        cc.vv.voiceMgr.init();

        var AudioMgr = require("AudioMgr");
        cc.vv.audioMgr = new AudioMgr();
        cc.vv.audioMgr.init();

        var Utils = require("Utils");
        cc.vv.utils = new Utils();

        cc.args = this.urlParse();
    },

    urlParse: function urlParse() {
        var params = {};
        if (window.location == null) {
            return params;
        }
        var name, value;
        var str = window.location.href; //取得整个地址栏
        var num = str.indexOf("?");
        str = str.substr(num + 1); //取得所有参数   stringvar.substr(start [, length ]

        var arr = str.split("&"); //各个参数放到数组里
        for (var i = 0; i < arr.length; i++) {
            num = arr[i].indexOf("=");
            if (num > 0) {
                name = arr[i].substring(0, num);
                value = arr[i].substr(num + 1);
                params[name] = value;
            }
        }
        return params;
    },

    checkVersion: function checkVersion() {
        var self = this;
        var onGetVersion = function onGetVersion(ret) {
            if (ret.version == null) {
                console.log("error.");
            } else {
                cc.vv.SI = ret;
                if (ret.version != cc.VERSION) {
                    cc.find("Canvas/alert").active = true;
                } else {
                    self.startPreloading();
                }
            }
        };

        var xhr = null;
        var complete = false;
        var fnRequest = function fnRequest() {
            self._stateStr = "正在连接服务器";
            xhr = cc.vv.http.sendRequest("/get_serverinfo", null, function (ret) {
                xhr = null;
                complete = true;
                onGetVersion(ret);
            });
            setTimeout(fn, 5000);
        };

        var fn = function fn() {
            if (!complete) {
                if (xhr) {
                    xhr.abort();
                    self._stateStr = "连接失败，即将重试";
                    setTimeout(function () {
                        fnRequest();
                    }, 5000);
                } else {
                    fnRequest();
                }
            }
        };
        fn();
    },

    onBtnDownloadClicked: function onBtnDownloadClicked() {
        cc.sys.openURL(cc.vv.SI.appweb);
    },

    startPreloading: function startPreloading() {
        this._stateStr = "正在加载资源，请稍候";
        this._isLoading = true;
        var self = this;

        cc.loader.onProgress = function (completedCount, totalCount, item) {
            //console.log("completedCount:" + completedCount + ",totalCount:" + totalCount );
            if (self._isLoading) {
                self._progress = completedCount / totalCount;
            }
        };

        cc.loader.loadResAll("textures", function (err, assets) {
            self.onLoadComplete();
        });
    },

    onLoadComplete: function onLoadComplete() {
        this._isLoading = false;
        this._stateStr = "准备登陆";
        cc.director.loadScene("login");
        cc.loader.onComplete = null;
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._stateStr.length == 0) {
            return;
        }
        this.tipLabel.string = this._stateStr + ' ';
        if (this._isLoading) {
            this.tipLabel.string += Math.floor(this._progress * 100) + "%";
        } else {
            var t = Math.floor(Date.now() / 1000) % 4;
            for (var i = 0; i < t; ++i) {
                this.tipLabel.string += '.';
            }
        }
    }
});

cc._RF.pop();
},{"AnysdkMgr":"AnysdkMgr","AudioMgr":"AudioMgr","GameNetMgr":"GameNetMgr","Global":"Global","HTTP":"HTTP","Net":"Net","ReplayMgr":"ReplayMgr","UserMgr":"UserMgr","Utils":"Utils","VoiceMgr":"VoiceMgr"}],"Login":[function(require,module,exports){
"use strict";
cc._RF.push(module, '572a7Qfh69N9ZLXkNthANfi', 'Login');
// scripts/components/Login.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

String.prototype.format = function (args) {
    if (arguments.length > 0) {
        var result = this;
        if (arguments.length == 1 && (typeof args === "undefined" ? "undefined" : _typeof(args)) == "object") {
            for (var key in args) {
                var reg = new RegExp("({" + key + "})", "g");
                result = result.replace(reg, args[key]);
            }
        } else {
            for (var i = 0; i < arguments.length; i++) {
                if (arguments[i] == undefined) {
                    return "";
                } else {
                    var reg = new RegExp("({[" + i + "]})", "g");
                    result = result.replace(reg, arguments[i]);
                }
            }
        }
        return result;
    } else {
        return this;
    }
};

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _mima: null,
        _mimaIndex: 0,
        mjdl: 1 },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = this.node.getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }

        if (!cc.vv) {
            cc.director.loadScene("loading");
            return;
        }
        cc.vv.http.url = cc.vv.http.master_url;
        cc.vv.net.addHandler('push_need_create_role', function () {
            console.log("onLoad:push_need_create_role");
            cc.director.loadScene("createrole");
        });

        cc.vv.audioMgr.playBGM("bgMain.mp3");

        this._mima = ["A", "A", "B", "B", "A", "B", "A", "B", "A", "A", "A", "B", "B", "B"];

        if (!cc.sys.isNative || cc.sys.os == cc.sys.OS_WINDOWS) {
            cc.find("Canvas/btn_yk").active = true;
        }

        var youkeorweixin = cc.sys.localStorage.getItem("youkeorweixin");
        //安卓只显示微信登陆
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            console.log("platform:" + cc.sys.OS_ANDROID + " OS_ANDROID.");
            cc.find("Canvas/btn_yk").active = false;
            cc.find("Canvas/z_weixindenglu").active = true;
        }
        //IOS审核版本 只显示游客登录 过审版本 只显示微信登陆
        else if (cc.sys.os == cc.sys.OS_IOS) {
                console.log("platform:" + cc.sys.OS_IOS + " OS_IOS.");
                if (youkeorweixin == "0") {
                    cc.find("Canvas/btn_yk").active = true;
                    cc.find("Canvas/z_weixindenglu").active = false;
                    cc.find("Canvas/yhxy").active = true;
                }
                if (youkeorweixin == "1" || youkeorweixin == "null") {
                    cc.find("Canvas/z_weixindenglu").active = true;
                    cc.find("Canvas/btn_yk").active = false;
                }
            } else {
                cc.find("Canvas/btn_yk").active = true;
                cc.find("Canvas/z_weixindenglu").active = false;
                console.log("platform:" + cc.sys.os + " dosn't implement share.");
            }

        cc.systemEvent.on(cc.SystemEvent.EventType.KEY_UP, function (event) {
            cc.game.end();
        }, cc.Game);
    },

    start: function start() {
        var account = cc.sys.localStorage.getItem("wx_account");
        var sign = cc.sys.localStorage.getItem("wx_sign");
        if (account != null && sign != null) {
            var ret = {
                errcode: 0,
                account: account,
                sign: sign
            };
            cc.vv.userMgr.onAuth(ret);
        }
    },

    onBtnReturn: function onBtnReturn() {
        var yhxy = this.node.getChildByName("yhxy");
        yhxy.active = false;
    },
    check_mark: function check_mark() {
        var tyyhxy = this.node.getChildByName("tyyhxy");
        var btn_checkbox = tyyhxy.getChildByName("btn_checkbox");
        var check_mark = btn_checkbox.getChildByName("check_mark");
        if (this.mjdl == 1) {
            check_mark.active = false;
            this.mjdl = 0;
        } else {
            check_mark.active = true;
            this.mjdl = 1;
        }
        console.log("this.mjdl:" + this.mjdl);
    },
    yonghuxieyi: function yonghuxieyi() {

        var yhxy = this.node.getChildByName("yhxy");
        yhxy.active = true;
    },
    prompt: function prompt() {
        var prompt = this.node.getChildByName("prompt");
        prompt.active = false;
    },
    onBtnQuickStartClicked: function onBtnQuickStartClicked() {
        if (this.mjdl == 0) {
            var prompt = this.node.getChildByName("prompt");
            prompt.active = true;
            return;
        }
        console.log("ssy");

        cc.vv.userMgr.guestAuth();
    },

    onBtnDownloadClicked: function onBtnDownloadClicked() {
        cc.sys.openURL(cc.vv.SI.appweb);
    },

    onBtnWeichatClicked: function onBtnWeichatClicked() {

        var self = this;
        if (self.mjdl == 0) {
            var prompt = this.node.getChildByName("prompt");
            prompt.active = true;
            return;
        }
        console.log("ss");
        cc.vv.anysdkMgr.login();
    },

    onBtnMIMAClicked: function onBtnMIMAClicked(event) {
        if (this._mima[this._mimaIndex] == event.target.name) {
            this._mimaIndex++;
            if (this._mimaIndex == this._mima.length) {
                cc.find("Canvas/btn_yk").active = true;
            }
        } else {
            console.log("oh ho~~~");
            this._mimaIndex = 0;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"MJGame":[function(require,module,exports){
"use strict";
cc._RF.push(module, '7fa8fcvrqFOj6lhh6xHzd3c', 'MJGame');
// scripts/components/MJGame.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        gameRoot: {
            default: null,
            type: cc.Node
        },

        prepareRoot: {
            default: null,
            type: cc.Node
        },

        _myMJArr: [],
        _options: null,
        _selectedMJ: null,
        _chupaiSprite: [],
        _mjcount: null,
        _gamecount: null,
        _hupaiTips: [],
        _hupaiLists: [],
        _playEfxs: [],
        _opts: [],
        _gametype: null
    },

    onLoad: function onLoad() {
        if (!cc.sys.isNative && cc.sys.isMobile) {
            var cvs = this.node.getComponent(cc.Canvas);
            cvs.fitHeight = true;
            cvs.fitWidth = true;
        }
        if (!cc.vv) {
            cc.director.loadScene("loading");
            return;
        }
        this.addComponent("NoticeTip");
        this.addComponent("GameOver");
        this.addComponent("DingQue");
        this.addComponent("PengGangs");
        this.addComponent("MJRoom");
        this.addComponent("TimePointer");
        this.addComponent("GameResult");
        this.addComponent("Chat");
        this.addComponent("Folds");
        this.addComponent("ReplayCtrl");
        this.addComponent("PopupMgr");
        this.addComponent("HuanSanZhang");
        this.addComponent("ReConnect");
        this.addComponent("Voice");
        this.addComponent("UserInfoShow");
        this.addComponent("Alert");
        this.initView();
        this.initEventHandlers();

        this.gameRoot.active = false;
        this.prepareRoot.active = true;
        this.initWanfaLabel();
        this.onGameBeign();
        cc.vv.audioMgr.playBGM("bgMain.mp3");

        //淡入
        // var fadein = cc.fadeIn(0.1);
        // this.node.runAction(fadein);
    },

    initView: function initView() {

        //搜索需要的子节点
        var gameChild = this.node.getChildByName("game");

        this._mjcount = gameChild.getChildByName('mjcount').getComponent(cc.Label);
        if (this._mjcount > 0) {
            this._mjcount.string = "剩余" + cc.vv.gameNetMgr.numOfMJ + "张";
        } else {
            this._mjcount.string = "";
        }
        this._gamecount = gameChild.getChildByName('gamecount').getComponent(cc.Label);
        switch (cc.vv.gameNetMgr.fengxiang) {
            case 0:
                this._gamecount.string = "东风圈";break;
            case 1:
                this._gamecount.string = "南风圈";break;
            case 2:
                this._gamecount.string = "西风圈";break;
            case 3:
                this._gamecount.string = "北风圈";break;
            default:
                this._gamecount.string = "";break;
        }

        this._gametype = gameChild.getChildByName('gametype');
        switch (cc.vv.gameNetMgr.conf.type) {
            case "sjmmj":
                this._gametype.getComponent(cc.Label).string = "沈家门麻将";break;
            case "dhmj":
                this._gametype.getComponent(cc.Label).string = "定海麻将";break;
            case "tdh":
                this._gametype.getComponent(cc.Label).string = "推到胡";break;
        }

        var myselfChild = gameChild.getChildByName("myself");
        var myholds = myselfChild.getChildByName("holds");

        for (var i = 0; i < myholds.children.length; ++i) {
            var sprite = myholds.children[i].getComponent(cc.Sprite);
            this._myMJArr.push(sprite);
            sprite.spriteFrame = null;
        }

        var realwidth = cc.director.getVisibleSize().width;
        myholds.scaleX *= realwidth / 1280;
        myholds.scaleY *= realwidth / 1280;

        var sides = ["myself", "right", "up", "left"];
        for (var i = 0; i < sides.length; ++i) {
            var side = sides[i];

            var sideChild = gameChild.getChildByName(side);
            this._hupaiTips.push(sideChild.getChildByName("HuPai"));
            this._hupaiLists.push(sideChild.getChildByName("hupailist"));
            this._playEfxs.push(sideChild.getChildByName("play_efx").getComponent(cc.Animation));
            this._chupaiSprite.push(sideChild.getChildByName("ChuPai").children[0].getComponent(cc.Sprite));

            var opt = sideChild.getChildByName("opt");
            opt.active = false;
            var sprite = opt.getChildByName("pai").getComponent(cc.Sprite);
            var data = {
                node: opt,
                sprite: sprite
            };
            this._opts.push(data);
        }

        var opts = gameChild.getChildByName("ops");
        this._options = opts;
        this.hideOptions();
        this.hideChupai();
    },

    hideChupai: function hideChupai() {
        for (var i = 0; i < this._chupaiSprite.length; ++i) {
            this._chupaiSprite[i].node.active = false;
        }
    },

    initEventHandlers: function initEventHandlers() {
        cc.vv.gameNetMgr.dataEventHandler = this.node;

        //初始化事件监听器
        var self = this;

        this.node.on('game_holds', function (data) {
            self.initMahjongs();
            self.checkQueYiMen();
        });

        this.node.on('game_begin', function (data) {
            self.playShazi();
            self.onGameBeign(data);
        });

        this.node.on('game_sync', function (data) {
            self.onGameBeign(data);
        });

        this.node.on('game_chupai', function (data) {
            data = data.detail;
            self.hideChupai();
            self.checkQueYiMen();
            if (data.last != cc.vv.gameNetMgr.seatIndex) {
                self.initMopai(data.last, null);
            }
            if (!cc.vv.replayMgr.isReplay() && data.turn != cc.vv.gameNetMgr.seatIndex) {
                self.initMopai(data.turn, -1);
            }
        });

        this.node.on('game_mopai', function (data) {
            self.hideChupai();
            data = data.detail;
            var pai = data.pai;
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(data.seatIndex);
            if (localIndex == 0) {
                var index = 13;
                var sprite = self._myMJArr[index];
                self.setSpriteFrameByMJID("M_", sprite, pai, index);
                sprite.node.mjId = pai;
            } else if (cc.vv.replayMgr.isReplay()) {
                self.initMopai(data.seatIndex, pai);
            }
        });

        this.node.on('game_action', function (data) {
            self.showAction(data.detail);
            console.log("game_action");
        });

        // this.node.on('game_feng',function(data){
        //     self._gamecount
        //     console.log("game_feng");
        // });

        this.node.on('hupai', function (data) {
            var data = data.detail;
            //如果不是玩家自己，则将玩家的牌都放倒
            var seatIndex = data.seatindex;
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatIndex);
            var hupai = self._hupaiTips[localIndex];
            hupai.active = true;

            if (localIndex == 0) {
                self.hideOptions();
            }
            var seatData = cc.vv.gameNetMgr.seats[seatIndex];
            seatData.hued = true;
            if (cc.vv.gameNetMgr.conf.type == "xlch") {
                hupai.getChildByName("sprHu").active = true;
                hupai.getChildByName("sprZimo").active = false;
                self.initHupai(localIndex, data.hupai);
                if (data.iszimo) {
                    if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                        seatData.holds.pop();
                        self.initMahjongs();
                    } else {
                        self.initOtherMahjongs(seatData);
                    }
                }
            } else {
                hupai.getChildByName("sprHu").active = !data.iszimo;
                hupai.getChildByName("sprZimo").active = data.iszimo;

                if (!(data.iszimo && localIndex == 0)) {
                    //if(cc.vv.replayMgr.isReplay() == false && localIndex != 0){
                    //    self.initEmptySprites(seatIndex);                
                    //}
                    self.initMopai(seatIndex, data.hupai);
                }
            }

            if (cc.vv.replayMgr.isReplay() == true && cc.vv.gameNetMgr.conf.type != "xlch") {
                var opt = self._opts[localIndex];
                opt.node.active = true;
                opt.sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", data.hupai);
            }

            if (data.iszimo) {
                self.playEfx(localIndex, "play_zimo");
            } else {
                self.playEfx(localIndex, "play_hu");
            }

            cc.vv.audioMgr.playSFX("nv/hu.mp3");
        });

        this.node.on('mj_count', function (data) {
            self._mjcount.string = "剩余" + cc.vv.gameNetMgr.numOfMJ + "张";
        });

        this.node.on('game_num', function (data) {
            //console.log('game_num!!!!!!!!!!'+cc.vv.gameNetMgr.fengxiang);
            // switch(cc.vv.gameNetMgr.fengxiang) {
            //     case 0: 
            //         self._gamecount.string = "东风圈";break;
            //     case 1: 
            //         self._gamecount.string = "南风圈";break;
            //     case 2: 
            //         self._gamecount.string = "西风圈";break;
            //     case 3: 
            //         self._gamecount.string = "北风圈";break;

            // }
        });

        this.node.on('game_feng', function (data) {
            console.log('game_num!!!!!!!!!!' + cc.vv.gameNetMgr.fengxiang);
            switch (cc.vv.gameNetMgr.fengxiang) {
                case 0:
                    self._gamecount.string = "东风圈";break;
                case 1:
                    self._gamecount.string = "南风圈";break;
                case 2:
                    self._gamecount.string = "西风圈";break;
                case 3:
                    self._gamecount.string = "北风圈";break;

            }
        });

        this.node.on('game_over', function (data) {
            self.gameRoot.active = false;
            self.prepareRoot.active = true;
        });

        this.node.on('game_chupai_notify', function (data) {
            self.hideChupai();
            var seatData = data.detail.seatData;
            //如果是自己，则刷新手牌
            if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initMahjongs();
            } else {
                self.initOtherMahjongs(seatData);
            }
            self.showChupai();
            var audioUrl = cc.vv.mahjongmgr.getAudioURLByMJID(data.detail.pai);
            cc.vv.audioMgr.playSFX(audioUrl);
        });

        this.node.on('guo_notify', function (data) {
            self.hideChupai();
            self.hideOptions();
            var seatData = data.detail;
            //如果是自己，则刷新手牌
            if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initMahjongs();
            }
            cc.vv.audioMgr.playSFX("give.mp3");
        });

        this.node.on('guo_result', function (data) {
            self.hideOptions();
        });

        this.node.on('game_dingque_finish', function (data) {
            self.initMahjongs();
        });

        this.node.on('peng_notify', function (data) {
            self.hideChupai();

            var seatData = data.detail;
            console.log('peng_notify');
            console.log(data);
            if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initMahjongs();
            } else {
                self.initOtherMahjongs(seatData);
            }
            var localIndex = self.getLocalIndex(seatData.seatindex);
            self.playEfx(localIndex, "play_peng");
            cc.vv.audioMgr.playSFX("nv/peng.mp3");
            self.hideOptions();
        });

        this.node.on('chi_notify', function (data) {
            console.log('chi_notify');
            console.log(data);
            self.hideChupai();

            var seatData = data.detail;

            console.log(data);
            if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initMahjongs();
            } else {
                self.initOtherMahjongs(seatData);
            }
            var localIndex = self.getLocalIndex(seatData.seatindex);
            self.playEfx(localIndex, "play_chi");
            cc.vv.audioMgr.playSFX("nv/chi.mp3");
            self.hideOptions();
        });

        this.node.on('buhua_notify', function (data) {
            console.log('buhua_notify');
            console.log(data.detail.holds);
            var seatData = data.detail;
            if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initMahjongs();
            } else {
                self.initOtherMahjongs(seatData);
            }
        });

        this.node.on('gang_notify', function (data) {
            self.hideChupai();
            var data = data.detail;
            var seatData = data.seatData;
            var gangtype = data.gangtype;
            if (seatData.seatindex == cc.vv.gameNetMgr.seatIndex) {
                self.initMahjongs();
            } else {
                self.initOtherMahjongs(seatData);
            }

            var localIndex = self.getLocalIndex(seatData.seatindex);
            if (gangtype == "wangang") {
                self.playEfx(localIndex, "play_gang");
                cc.vv.audioMgr.playSFX("guafeng.mp3");
            } else {
                self.playEfx(localIndex, "play_gang");
                cc.vv.audioMgr.playSFX("rain.mp3");
            }
        });

        this.node.on("hangang_notify", function (data) {
            var data = data.detail;
            var localIndex = self.getLocalIndex(data);
            self.playEfx(localIndex, "play_gang");
            cc.vv.audioMgr.playSFX("nv/gang.mp3");
            self.hideOptions();
        });
    },

    showChupai: function showChupai() {
        var pai = cc.vv.gameNetMgr.chupai;
        if (pai >= 0) {
            //
            var localIndex = this.getLocalIndex(cc.vv.gameNetMgr.turn);
            var sprite = this._chupaiSprite[localIndex];
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
            sprite.node.active = true;
        }
    },

    addOption: function addOption(btnName, pai, chitype) {
        console.log("弹出操作框");
        console.log(btnName);
        console.log(pai);
        //添加吃牌的三种方式
        //var str = pai.split("_");
        //var painame = str[0];
        //var painum = str[1];
        if (chitype && chitype.left == true) {
            var op = this._options.getChildByName("chiop").getChildByName("left");
            op.active = true;
            var sprite = op.children[0].getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
            var sprite = op.children[1].getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai + 1);
            var sprite = op.children[2].getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai + 2);
        }

        if (chitype && chitype.mid == true) {
            var op = this._options.getChildByName("chiop").getChildByName("mid");
            op.active = true;
            var sprite = op.children[0].getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai - 1);
            var sprite = op.children[1].getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
            var sprite = op.children[2].getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai + 1);
        }
        if (chitype && chitype.right == true) {
            var op = this._options.getChildByName("chiop").getChildByName("right");
            op.active = true;
            var sprite = op.children[0].getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai - 2);
            var sprite = op.children[1].getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai - 1);
            var sprite = op.children[2].getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
        }
        //其他
        for (var i = 0; i < this._options.childrenCount; ++i) {
            var child = this._options.children[i];
            if (child.name == "op" && child.active == false) {
                child.active = true;
                var sprite = child.getChildByName("opTarget").getComponent(cc.Sprite);
                sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID("M_", pai);
                var btn = child.getChildByName(btnName);
                btn.active = true;
                btn.pai = pai;
                return;
            }
        }
    },

    hideOptions: function hideOptions(data) {
        this._options.active = false;
        for (var i = 0; i < this._options.childrenCount; ++i) {
            var child = this._options.children[i];
            if (child.name == "op") {
                child.active = false;
                child.getChildByName("btnPeng").active = false;
                child.getChildByName("btnGang").active = false;
                child.getChildByName("btnHu").active = false;
                child.getChildByName("btnChi").active = false;
            }
            if (child.name == "chiop") {
                child.active = false;
                child.getChildByName("left").active = false;
                child.getChildByName("mid").active = false;
                child.getChildByName("right").active = false;
            }
        }
    },

    showAction: function showAction(data) {
        console.log("show action");
        console.log(this._options.active);
        if (this._options.active) {
            this.hideOptions();
        }

        if (data && (data.hu || data.gang || data.peng || data.chi)) {
            console.log(data.chi);
            this._options.active = true;
            if (data.hu) {
                this.addOption("btnHu", data.pai);
            }
            if (data.peng) {
                this.addOption("btnPeng", data.pai);
            }

            if (data.gang) {
                for (var i = 0; i < data.gangpai.length; ++i) {
                    var gp = data.gangpai[i];
                    this.addOption("btnGang", gp);
                }
            }

            if (data.chi) {
                this.addOption("btnChi", data.pai, data.chitype);
            }
        }
        console.log(data.chi);
    },

    initWanfaLabel: function initWanfaLabel() {
        var wanfa = cc.find("Canvas/infobar/wanfa").getComponent(cc.Label);
        wanfa.string = cc.vv.gameNetMgr.getWanfa();
    },

    initHupai: function initHupai(localIndex, pai) {
        if (cc.vv.gameNetMgr.conf.type == "xlch") {
            var hupailist = this._hupaiLists[localIndex];
            for (var i = 0; i < hupailist.children.length; ++i) {
                var hupainode = hupailist.children[i];
                if (hupainode.active == false) {
                    var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);
                    hupainode.getComponent(cc.Sprite).spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, pai);
                    hupainode.active = true;
                    break;
                }
            }
        }
    },

    playEfx: function playEfx(index, name) {
        this._playEfxs[index].node.active = true;
        this._playEfxs[index].play(name);
    },

    playShazi: function playShazi() {
        var anim1 = this.node.getChildByName("game").getChildByName("shaizi").getChildByName("shaizi1").getComponent(cc.Animation);
        anim1.play("shaizi");
        var anim2 = this.node.getChildByName("game").getChildByName("shaizi").getChildByName("shaizi2").getComponent(cc.Animation);
        anim2.play("shaizi2");
        this.onfinished(false);
        anim2.on("finished", this.onfinished, this);
    },

    onfinished: function onfinished(isshow) {
        var show = true;
        isshow == false ? show = false : {};
        var side = this.node.getChildByName("game").getChildByName("myself");
        side.getChildByName("huas").active = show;
        side.getChildByName("holds").active = show;
        var side = this.node.getChildByName("game").getChildByName("left");
        side.getChildByName("huas").active = show;
        side.getChildByName("holds").active = show;
        var side = this.node.getChildByName("game").getChildByName("up");
        side.getChildByName("huas").active = show;
        side.getChildByName("holds").active = show;
        var side = this.node.getChildByName("game").getChildByName("right");
        side.getChildByName("huas").active = show;
        side.getChildByName("holds").active = show;
    },

    onGameBeign: function onGameBeign() {

        //更换gameover界面头像 懒得封装了，反正以后也用不到
        var sprIcon = cc.find("Canvas/game_over_sjmmj/result_list/s1/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[0].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[0].userid);
        var sprIcon = cc.find("Canvas/game_over_sjmmj/result_list/s2/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[1].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[1].userid);
        var sprIcon = cc.find("Canvas/game_over_sjmmj/result_list/s3/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[2].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[2].userid);
        var sprIcon = cc.find("Canvas/game_over_sjmmj/result_list/s4/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[3].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[3].userid);

        var sprIcon = cc.find("Canvas/game_over_dhmj/result_list/s1/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[0].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[0].userid);
        var sprIcon = cc.find("Canvas/game_over_dhmj/result_list/s2/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[1].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[1].userid);
        var sprIcon = cc.find("Canvas/game_over_dhmj/result_list/s3/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[2].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[2].userid);
        var sprIcon = cc.find("Canvas/game_over_dhmj/result_list/s4/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[3].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[3].userid);

        var sprIcon = cc.find("Canvas/game_over_tdh/result_list/s1/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[0].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[0].userid);
        var sprIcon = cc.find("Canvas/game_over_tdh/result_list/s2/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[1].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[1].userid);
        var sprIcon = cc.find("Canvas/game_over_tdh/result_list/s3/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[2].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[2].userid);
        var sprIcon = cc.find("Canvas/game_over_tdh/result_list/s4/touxiang").getComponent("ImageLoader");
        if (sprIcon && cc.vv.gameNetMgr.seats[3].userid) sprIcon.setUserID(cc.vv.gameNetMgr.seats[3].userid);

        for (var i = 0; i < this._playEfxs.length; ++i) {
            this._playEfxs[i].node.active = false;
        }

        for (var i = 0; i < this._hupaiLists.length; ++i) {
            for (var j = 0; j < this._hupaiLists[i].childrenCount; ++j) {
                this._hupaiLists[i].children[j].active = false;
            }
        }

        for (var i = 0; i < cc.vv.gameNetMgr.seats.length; ++i) {
            var seatData = cc.vv.gameNetMgr.seats[i];
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(i);
            var hupai = this._hupaiTips[localIndex];
            hupai.active = seatData.hued;
            if (seatData.hued) {
                hupai.getChildByName("sprHu").active = !seatData.iszimo;
                hupai.getChildByName("sprZimo").active = seatData.iszimo;
            }

            if (seatData.huinfo) {
                for (var j = 0; j < seatData.huinfo.length; ++j) {
                    var info = seatData.huinfo[j];
                    if (info.ishupai) {
                        this.initHupai(localIndex, info.pai);
                    }
                }
            }
        }

        this.hideChupai();
        this.hideOptions();
        var sides = ["right", "up", "left"];
        var gameChild = this.node.getChildByName("game");
        for (var i = 0; i < sides.length; ++i) {
            var sideChild = gameChild.getChildByName(sides[i]);
            var holds = sideChild.getChildByName("holds");
            for (var j = 0; j < holds.childrenCount; ++j) {
                var nc = holds.children[j];
                nc.active = true;
                nc.scaleX = 1.0;
                nc.scaleY = 1.0;
                var sprite = nc.getComponent(cc.Sprite);
                sprite.spriteFrame = cc.vv.mahjongmgr.holdsEmpty[i + 1];
            }
        }

        if (cc.vv.gameNetMgr.gamestate == "" && cc.vv.replayMgr.isReplay() == false) {
            return;
        }

        this.gameRoot.active = true;
        this.prepareRoot.active = false;
        this.initMahjongs();
        var seats = cc.vv.gameNetMgr.seats;
        for (var i in seats) {
            var seatData = seats[i];
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(i);
            if (localIndex != 0) {
                this.initOtherMahjongs(seatData);
                if (i == cc.vv.gameNetMgr.turn) {
                    this.initMopai(i, -1);
                } else {
                    this.initMopai(i, null);
                }
            }
        }
        this.showChupai();
        if (cc.vv.gameNetMgr.curaction != null) {
            this.showAction(cc.vv.gameNetMgr.curaction);
            cc.vv.gameNetMgr.curaction = null;
        }

        this.checkQueYiMen();
    },

    onMJClicked: function onMJClicked(event) {
        if (cc.vv.gameNetMgr.isHuanSanZhang) {
            this.node.emit("mj_clicked", event.target);
            return;
        }

        //如果不是自己的轮子，则忽略
        if (cc.vv.gameNetMgr.turn != cc.vv.gameNetMgr.seatIndex) {
            console.log("not your turn." + cc.vv.gameNetMgr.turn);
            return;
        }

        for (var i = 0; i < this._myMJArr.length; ++i) {
            if (event.target == this._myMJArr[i].node) {
                //如果是再次点击，则出牌
                if (event.target == this._selectedMJ) {
                    this.shoot(this._selectedMJ.mjId);
                    this._selectedMJ.y = 0;
                    this._selectedMJ = null;
                    //取消显示桌面上相同的牌
                    this.hideSameType();
                    return;
                }
                //如果不是则显示桌面上相同的牌
                else {
                        this.showSameType(event.target);
                    }
                if (this._selectedMJ != null) {
                    this._selectedMJ.y = 0;
                }
                event.target.y = 15;
                this._selectedMJ = event.target;
                return;
            }
        }
    },

    //显示桌面上相同牌的功能
    showSameType: function showSameType(mj) {
        var sprite = mj.getComponent(cc.Sprite);
        //提取_之前的内容
        function getEnd(mainStr, searchStr) {
            var foundOffset = mainStr.indexOf(searchStr);
            if (foundOffset == -1) {
                return null;
            }
            return mainStr.substring(foundOffset + searchStr.length, mainStr.length);
        }
        var mjname = getEnd(sprite.spriteFrame._name, "_");
        //所有folds
        var allfolds = [];
        allfolds = allfolds.concat(cc.find("Canvas/game/right/folds").children);
        allfolds = allfolds.concat(cc.find("Canvas/game/up/folds").children);
        allfolds = allfolds.concat(cc.find("Canvas/game/left/folds").children);
        allfolds = allfolds.concat(cc.find("Canvas/game/myself/folds").children);

        //var aaa = cc.find("Canvas/game/myself/penggangs").children;

        //var sprites = cc.find("Canvas/game/myself/penggangs").children[0].children;
        var pgs = cc.find("Canvas/game/myself/penggangs");
        for (var i = 0; i < pgs.childrenCount; i++) {
            var nowpg = pgs.children[i];
            allfolds = allfolds.concat(nowpg.children);
        }
        var pgs = cc.find("Canvas/game/right/penggangs");
        for (var i = 0; i < pgs.childrenCount; i++) {
            var nowpg = pgs.children[i];
            allfolds = allfolds.concat(nowpg.children);
        }
        var pgs = cc.find("Canvas/game/up/penggangs");
        for (var i = 0; i < pgs.childrenCount; i++) {
            var nowpg = pgs.children[i];
            allfolds = allfolds.concat(nowpg.children);
        }
        var pgs = cc.find("Canvas/game/left/penggangs");
        for (var i = 0; i < pgs.childrenCount; i++) {
            var nowpg = pgs.children[i];
            allfolds = allfolds.concat(nowpg.children);
        }

        for (var i = 0; i < allfolds.length; i++) {
            var nowsprite = allfolds[i].getComponent(cc.Sprite);
            if (nowsprite.spriteFrame) {
                var nowname = getEnd(nowsprite.spriteFrame._name, "_");
                if (nowname == mjname) {
                    allfolds[i].color = new cc.Color(155, 228, 228);
                } else {
                    allfolds[i].color = new cc.Color(255, 255, 255);
                }
            }
        }
    },

    //取消显示桌面上相同牌的功能
    hideSameType: function hideSameType() {
        var allfolds = [];
        allfolds = allfolds.concat(cc.find("Canvas/game/right/folds").children);
        allfolds = allfolds.concat(cc.find("Canvas/game/up/folds").children);
        allfolds = allfolds.concat(cc.find("Canvas/game/left/folds").children);
        allfolds = allfolds.concat(cc.find("Canvas/game/myself/folds").children);
        for (var i = 0; i < allfolds.length; i++) {
            var nowsprite = allfolds[i].getComponent(cc.Sprite);
            if (nowsprite.spriteFrame) {
                allfolds[i].color = new cc.Color(255, 255, 255);
            }
        }
    },

    //如果摸到的牌是花，则会调用这个函数
    chuhua: function (_chuhua) {
        function chuhua(_x) {
            return _chuhua.apply(this, arguments);
        }

        chuhua.toString = function () {
            return _chuhua.toString();
        };

        return chuhua;
    }(function (mjid) {
        console.log(chuhua);
    }),

    //出牌
    shoot: function shoot(mjId) {
        if (mjId == null) {
            return;
        }
        cc.vv.net.send('chupai', mjId);
    },

    getMJIndex: function getMJIndex(side, index) {
        if (side == "right" || side == "up") {
            return 13 - index;
        }
        return index;
    },

    initMopai: function initMopai(seatIndex, pai) {
        var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatIndex);
        var side = cc.vv.mahjongmgr.getSide(localIndex);
        var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);

        var gameChild = this.node.getChildByName("game");
        var sideChild = gameChild.getChildByName(side);
        var holds = sideChild.getChildByName("holds");

        var lastIndex = this.getMJIndex(side, 13);
        var nc = holds.children[lastIndex];

        nc.scaleX = 1.0;
        nc.scaleY = 1.0;

        if (pai == null) {
            nc.active = false;
        } else if (pai >= 0) {
            nc.active = true;
            if (side == "up") {
                nc.scaleX = 0.73;
                nc.scaleY = 0.73;
            }
            var sprite = nc.getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, pai);
        } else if (pai != null) {
            nc.active = true;
            if (side == "up") {
                nc.scaleX = 1.0;
                nc.scaleY = 1.0;
            }
            var sprite = nc.getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getHoldsEmptySpriteFrame(side);
        }
    },

    initEmptySprites: function initEmptySprites(seatIndex) {
        var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatIndex);
        var side = cc.vv.mahjongmgr.getSide(localIndex);
        var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);

        var gameChild = this.node.getChildByName("game");
        var sideChild = gameChild.getChildByName(side);
        var holds = sideChild.getChildByName("holds");
        var spriteFrame = cc.vv.mahjongmgr.getEmptySpriteFrame(side);
        for (var i = 0; i < holds.childrenCount; ++i) {
            var nc = holds.children[i];
            nc.scaleX = 1.0;
            nc.scaleY = 1.0;

            var sprite = nc.getComponent(cc.Sprite);
            sprite.spriteFrame = spriteFrame;
        }
    },

    initOtherMahjongs: function initOtherMahjongs(seatData) {
        //console.log("seat:" + seatData.seatindex);
        var localIndex = this.getLocalIndex(seatData.seatindex);
        if (localIndex == 0) {
            return;
        }
        var side = cc.vv.mahjongmgr.getSide(localIndex);
        var game = this.node.getChildByName("game");
        var sideRoot = game.getChildByName(side);
        var sideHolds = sideRoot.getChildByName("holds");
        var num = seatData.pengs.length + seatData.angangs.length + seatData.diangangs.length + seatData.wangangs.length + seatData.chis.length;
        num *= 3;
        for (var i = 0; i < num; ++i) {
            var idx = this.getMJIndex(side, i);
            sideHolds.children[idx].active = false;
        }

        var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);
        var holds = this.sortHolds(seatData);
        if (holds != null && holds.length > 0) {
            for (var i = 0; i < holds.length; ++i) {
                var idx = this.getMJIndex(side, i + num);
                var sprite = sideHolds.children[idx].getComponent(cc.Sprite);
                if (side == "up") {
                    sprite.node.scaleX = 0.73;
                    sprite.node.scaleY = 0.73;
                }
                sprite.node.active = true;
                sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, holds[i]);
            }

            if (holds.length + num == 13) {
                var lasetIdx = this.getMJIndex(side, 13);
                sideHolds.children[lasetIdx].active = false;
            }
        }
    },

    sortHolds: function sortHolds(seatData) {
        var holds = seatData.holds;
        if (holds == null) {
            return null;
        }
        //如果手上的牌的数目是2,5,8,11,14，表示最后一张牌是刚摸到的牌
        var mopai = null;
        var l = holds.length;
        if (l == 2 || l == 5 || l == 8 || l == 11 || l == 14) {
            mopai = holds.pop();
        }

        var dingque = seatData.dingque;
        cc.vv.mahjongmgr.sortMJ(holds, dingque);

        //将摸牌添加到最后
        if (mopai != null) {
            holds.push(mopai);
        }
        return holds;
    },

    initMahjongs: function initMahjongs() {
        var seats = cc.vv.gameNetMgr.seats;
        var seatData = seats[cc.vv.gameNetMgr.seatIndex];
        var holds = this.sortHolds(seatData);
        if (holds == null) {
            return;
        }
        console.log(seats);
        //初始化手牌
        var lackingNum = (seatData.chis.length + seatData.pengs.length + seatData.angangs.length + seatData.diangangs.length + seatData.wangangs.length) * 3;
        for (var i = 0; i < holds.length; ++i) {
            var mjid = holds[i];
            var sprite = this._myMJArr[i + lackingNum];
            sprite.node.mjId = mjid;
            sprite.node.y = 0;
            this.setSpriteFrameByMJID("M_", sprite, mjid);
        }
        for (var i = 0; i < lackingNum; ++i) {
            var sprite = this._myMJArr[i];
            sprite.node.mjId = null;
            sprite.spriteFrame = null;
            sprite.node.active = false;
        }
        for (var i = lackingNum + holds.length; i < this._myMJArr.length; ++i) {
            var sprite = this._myMJArr[i];
            sprite.node.mjId = null;
            sprite.spriteFrame = null;
            sprite.node.active = false;
        }
    },

    setSpriteFrameByMJID: function setSpriteFrameByMJID(pre, sprite, mjid) {
        sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, mjid);
        sprite.node.active = true;
    },

    //如果玩家手上还有缺的牌没有打，则只能打缺牌
    checkQueYiMen: function checkQueYiMen() {
        if (cc.vv.gameNetMgr.conf == null || cc.vv.gameNetMgr.conf.type != "xlch" || !cc.vv.gameNetMgr.getSelfData().hued) {
            //遍历检查看是否有未打缺的牌 如果有，则需要将不是定缺的牌设置为不可用
            var dingque = cc.vv.gameNetMgr.dingque;
            //        console.log(dingque)
            var hasQue = false;
            if (cc.vv.gameNetMgr.seatIndex == cc.vv.gameNetMgr.turn) {
                for (var i = 0; i < this._myMJArr.length; ++i) {
                    var sprite = this._myMJArr[i];
                    //                console.log("sprite.node.mjId:" + sprite.node.mjId);
                    if (sprite.node.mjId != null) {
                        var type = cc.vv.mahjongmgr.getMahjongType(sprite.node.mjId);
                        if (type == dingque) {
                            hasQue = true;
                            break;
                        }
                    }
                }
            }

            //        console.log("hasQue:" + hasQue);
            for (var i = 0; i < this._myMJArr.length; ++i) {
                var sprite = this._myMJArr[i];
                if (sprite.node.mjId != null) {
                    var type = cc.vv.mahjongmgr.getMahjongType(sprite.node.mjId);
                    if (hasQue && type != dingque) {
                        sprite.node.getComponent(cc.Button).interactable = false;
                    } else {
                        sprite.node.getComponent(cc.Button).interactable = true;
                    }
                }
            }
        } else {
            if (cc.vv.gameNetMgr.seatIndex == cc.vv.gameNetMgr.turn) {
                for (var i = 0; i < 14; ++i) {
                    var sprite = this._myMJArr[i];
                    if (sprite.node.active == true) {
                        sprite.node.getComponent(cc.Button).interactable = i == 13;
                    }
                }
            } else {
                for (var i = 0; i < 14; ++i) {
                    var sprite = this._myMJArr[i];
                    if (sprite.node.active == true) {
                        sprite.node.getComponent(cc.Button).interactable = true;
                    }
                }
            }
        }
    },

    getLocalIndex: function getLocalIndex(index) {
        var ret = (index - cc.vv.gameNetMgr.seatIndex + 4) % 4;
        //console.log("old:" + index + ",base:" + cc.vv.gameNetMgr.seatIndex + ",new:" + ret);
        return ret;
    },

    onOptionClicked: function onOptionClicked(event) {
        console.log(event.target.name);
        if (event.target.name == "btnPeng") {
            cc.vv.net.send("peng");
        } else if (event.target.name == "btnGang") {
            cc.vv.net.send("gang", event.target.pai);
        } else if (event.target.name == "btnHu") {
            cc.vv.net.send("hu");
        }
        //打开吃菜单
        else if (event.target.name == "btnChi") {
                this._options.getChildByName("chiop").active = true;

                for (var i = 0; i < this._options.childrenCount; ++i) {
                    var child = this._options.children[i];
                    if (child.name == "op") {
                        child.active = false;
                    }
                }
            }
            //左吃
            else if (event.target.name == "left") {
                    cc.vv.net.send("chi", "left");
                }
                //中吃
                else if (event.target.name == "mid") {
                        cc.vv.net.send("chi", "mid");
                    }
                    //右吃
                    else if (event.target.name == "right") {
                            cc.vv.net.send("chi", "right");
                        } else if (event.target.name == "btnGuo") {
                            cc.vv.net.send("guo");
                        }
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {},

    onDestroy: function onDestroy() {
        console.log("onDestroy");
        if (cc.vv) {
            cc.vv.gameNetMgr.clear();
        }
    }
});

cc._RF.pop();
},{}],"MJRoom":[function(require,module,exports){
"use strict";
cc._RF.push(module, '921dfQJZddJ+5GFUXqxmMmT', 'MJRoom');
// scripts/components/MJRoom.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        lblRoomNo: {
            default: null,
            type: cc.Label
        },
        _seats: [],
        _seats2: [],
        _timeLabel: null,
        _voiceMsgQueue: [],
        _lastPlayingSeat: null,
        _playingSeat: null,
        _lastPlayTime: null,
        _ifshowipwarning: true
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this.initView();
        this.initSeats();
        this.initEventHandlers();

        var youkeorweixin = cc.sys.localStorage.getItem("youkeorweixin");
        if (cc.sys.os == cc.sys.OS_IOS && youkeorweixin == "0") {
            //隐藏显示下边按钮
            cc.find("Canvas/prepare/btnWeichat").active = false;
        }
        //this.addComponent("Alert");
    },

    initView: function initView() {
        var prepare = this.node.getChildByName("prepare");
        var seats = prepare.getChildByName("seats");
        for (var i = 0; i < seats.children.length; ++i) {
            this._seats.push(seats.children[i].getComponent("Seat"));
        }

        this.refreshBtns();

        this.lblRoomNo = cc.find("Canvas/infobar/shijian/Z_room_txt/New Label").getComponent(cc.Label);
        this._timeLabel = cc.find("Canvas/infobar/shijian/time").getComponent(cc.Label);

        //显示玩法
        cc.find("Canvas/infobar/wanfa").getComponent(cc.Label).string = cc.vv.gameNetMgr.getWanfa();

        this.lblRoomNo.string = cc.vv.gameNetMgr.roomId;
        var gameChild = this.node.getChildByName("game");
        var sides = ["myself", "right", "up", "left"];
        for (var i = 0; i < sides.length; ++i) {
            var sideNode = gameChild.getChildByName(sides[i]);
            var seat = sideNode.getChildByName("seat");
            this._seats2.push(seat.getComponent("Seat"));
        }

        var btnWechat = cc.find("Canvas/prepare/btnWeichat");
        if (btnWechat) {
            cc.vv.utils.addClickEvent(btnWechat, this.node, "MJRoom", "onBtnWeichatClicked");
        }

        var btnCopy = cc.find("Canvas/prepare/btnCopy");
        if (btnCopy) {
            cc.vv.utils.addClickEvent(btnCopy, this.node, "MJRoom", "onBtnCopyClicked");
        }

        var titles = cc.find("Canvas/typeTitle");
        for (var i = 0; i < titles.children.length; ++i) {
            titles.children[i].active = false;
        }

        if (cc.vv.gameNetMgr.conf) {
            // var type = cc.vv.gameNetMgr.conf.type;
            // if(type == null || type == ""){
            //     type = "xzdd";
            // }
            // titles.getChildByName(type).active = true;   
        }
    },

    refreshBtns: function refreshBtns() {
        var prepare = this.node.getChildByName("prepare");
        var btnExit = prepare.getChildByName("btnExit");
        var btnDispress = prepare.getChildByName("btnDissolve");
        var btnWeichat = prepare.getChildByName("btnWeichat");
        var btnBack = prepare.getChildByName("btnBack");
        var isIdle = cc.vv.gameNetMgr.numOfGames == 0;
        console.log('isIdle' + isIdle);
        console.log(cc.vv.gameNetMgr.numOfGames);
        btnExit.active = !cc.vv.gameNetMgr.isOwner() && isIdle;
        btnDispress.active = cc.vv.gameNetMgr.isOwner() && isIdle;

        btnWeichat.active = isIdle;
        btnBack.active = isIdle;
    },

    ipWarning: function ipWarning() {

        if (!this._ifshowipwarning) return;

        var seats = cc.vv.gameNetMgr.seats;
        var nowseat = cc.vv.gameNetMgr.seatIndex;
        if (!nowseat) return;
        var others = [];
        for (var i = 0; i < 4; i++) {
            if (nowseat && i != nowseat) {
                others.push([seats[i].name, seats[i].ip]);
            }
        }
        var warnames = [];
        if ((others[0][1] == others[1][1] || others[0][1] == others[2][1]) && others[0][1] != null) {
            warnames.push(others[0][0]);
        }
        if ((others[1][1] == others[0][1] || others[1][1] == others[2][1]) && others[1][1] != null) {
            warnames.push(others[1][0]);
        }
        if ((others[2][1] == others[1][1] || others[2][1] == others[0][1]) && others[1][1] != null) {
            warnames.push(others[2][0]);
        }
        var str = warnames.join("、");
        if (warnames.length > 0) {
            cc.vv.alert.show("IP警告", "玩家" + str + "来自相同IP，请谨防其他玩家打勾手上当受骗", function () {
                cc.vv.net.send("dissolve_cause_ip");
            }, true, "解散", "继续");
            this._ifshowipwarning = false;
        }
    },

    initEventHandlers: function initEventHandlers() {
        var self = this;
        this.node.on('new_user', function (data) {
            self.initSingleSeat(data.detail);
        });

        this.node.on('user_state_changed', function (data) {
            self.initSingleSeat(data.detail);
        });

        this.node.on('game_begin', function (data) {

            self.refreshBtns();
            self.initSeats();
        });

        this.node.on('game_num', function (data) {

            self.refreshBtns();
        });

        this.node.on('game_huanpai', function (data) {
            for (var i in self._seats2) {
                self._seats2[i].refreshXuanPaiState();
            }
        });

        this.node.on('huanpai_notify', function (data) {
            var idx = data.detail.seatindex;
            var localIdx = cc.vv.gameNetMgr.getLocalIndex(idx);
            self._seats2[localIdx].refreshXuanPaiState();
        });

        this.node.on('game_huanpai_over', function (data) {
            for (var i in self._seats2) {
                self._seats2[i].refreshXuanPaiState();
            }
        });

        this.node.on('voice_msg', function (data) {
            var data = data.detail;
            self._voiceMsgQueue.push(data);
            self.playVoice();
        });

        this.node.on('chat_push', function (data) {
            var data = data.detail;
            var idx = cc.vv.gameNetMgr.getSeatIndexByID(data.sender);
            var localIdx = cc.vv.gameNetMgr.getLocalIndex(idx);
            self._seats[localIdx].chat(data.content);
            self._seats2[localIdx].chat(data.content);
        });

        this.node.on('quick_chat_push', function (data) {
            var data = data.detail;
            var idx = cc.vv.gameNetMgr.getSeatIndexByID(data.sender);
            var localIdx = cc.vv.gameNetMgr.getLocalIndex(idx);

            var index = data.content;
            var info = cc.vv.chat.getQuickChatInfo(index);
            self._seats[localIdx].chat(info.content);
            self._seats2[localIdx].chat(info.content);

            cc.vv.audioMgr.playSFX(info.sound);
        });

        this.node.on('emoji_push', function (data) {
            var data = data.detail;
            var idx = cc.vv.gameNetMgr.getSeatIndexByID(data.sender);
            var localIdx = cc.vv.gameNetMgr.getLocalIndex(idx);
            console.log(data);
            self._seats[localIdx].emoji(data.content);
            self._seats2[localIdx].emoji(data.content);
        });
    },

    initSeats: function initSeats() {
        var seats = cc.vv.gameNetMgr.seats;
        for (var i = 0; i < seats.length; ++i) {
            this.initSingleSeat(seats[i]);
        }
    },

    initSingleSeat: function initSingleSeat(seat) {
        var index = cc.vv.gameNetMgr.getLocalIndex(seat.seatindex);
        var isOffline = !seat.online;
        var isZhuang = seat.seatindex == cc.vv.gameNetMgr.button;

        console.log("isOffline:" + isOffline);

        this._seats[index].setInfo(seat.name, seat.score);
        this._seats[index].setReady(seat.ready);
        this._seats[index].setOffline(isOffline);
        this._seats[index].setID(seat.userid);
        this._seats[index].voiceMsg(false);

        this._seats2[index].setInfo(seat.name, seat.score);
        this._seats2[index].setZhuang(isZhuang);
        this._seats2[index].setOffline(isOffline);
        this._seats2[index].setID(seat.userid);
        this._seats2[index].voiceMsg(false);
        this._seats2[index].refreshXuanPaiState();
    },

    onBtnSettingsClicked: function onBtnSettingsClicked() {
        cc.vv.popupMgr.showSettings();
    },

    onBtnBackClicked: function onBtnBackClicked() {
        cc.vv.alert.show("返回大厅", "返回大厅房间仍会保留，快去邀请大伙来玩吧！", function () {
            cc.director.loadScene("hall");
        }, true);
    },

    onBtnChatClicked: function onBtnChatClicked() {},

    onBtnWeichatClicked: function onBtnWeichatClicked() {
        if (cc.vv.gameNetMgr.conf.type == "sjmmj") {
            var title = "<沈家门麻将>";
        } else if (cc.vv.gameNetMgr.conf.type == "dhmj") {
            var title = "<定海麻将>";
        } else if (cc.vv.gameNetMgr.conf.type == "tdh") {
            var title = "<推倒胡>";
        }
        cc.vv.anysdkMgr.share("奇奇舟山麻将" + title, "房号:" + cc.vv.gameNetMgr.roomId + " 玩法:" + cc.vv.gameNetMgr.getWanfa());
    },

    //复制房间信息
    onBtnCopyClicked: function onBtnCopyClicked() {
        if (cc.vv.gameNetMgr.conf.type == "sjmmj") {
            var title = "<沈家门麻将>";
        } else if (cc.vv.gameNetMgr.conf.type == "dhmj") {
            var title = "<定海麻将>";
        } else if (cc.vv.gameNetMgr.conf.type == "tdh") {
            var title = "<推倒胡>";
        }
        cc.vv.anysdkMgr.copy("奇奇舟山麻将" + title + " 房号:【" + cc.vv.gameNetMgr.roomId + "】 玩法:" + cc.vv.gameNetMgr.getWanfa());
        cc.find("Canvas/copysuccess").active = true;
        setTimeout(function () {
            cc.find("Canvas/copysuccess").active = false;
        }, 1000);
    },

    onBtnDissolveClicked: function onBtnDissolveClicked() {
        var youkeorweixin = cc.sys.localStorage.getItem("youkeorweixin");
        if (cc.sys.os == cc.sys.OS_IOS && youkeorweixin == "0") {
            cc.vv.alert.show("解散房间", "是否确定解散？", function () {
                cc.vv.net.send("dispress");
            }, true);
            return;
        }

        cc.vv.alert.show("解散房间", "解散房间不扣房卡，是否确定解散？", function () {
            cc.vv.net.send("dispress");
        }, true);
    },

    onBtnExit: function onBtnExit() {
        cc.vv.net.send("exit");
    },

    playVoice: function playVoice() {
        if (this._playingSeat == null && this._voiceMsgQueue.length) {
            console.log("playVoice2");
            var data = this._voiceMsgQueue.shift();
            var idx = cc.vv.gameNetMgr.getSeatIndexByID(data.sender);
            var localIndex = cc.vv.gameNetMgr.getLocalIndex(idx);
            this._playingSeat = localIndex;
            this._seats[localIndex].voiceMsg(true);
            this._seats2[localIndex].voiceMsg(true);

            var msgInfo = JSON.parse(data.content);

            var msgfile = "voicemsg.amr";
            console.log(msgInfo.msg.length);
            cc.vv.voiceMgr.writeVoice(msgfile, msgInfo.msg);
            cc.vv.voiceMgr.play(msgfile);
            this._lastPlayTime = Date.now() + msgInfo.time;
        }
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        var minutes = Math.floor(Date.now() / 1000 / 60);
        if (this._lastMinute != minutes) {
            this._lastMinute = minutes;
            var date = new Date();
            var h = date.getHours();
            h = h < 10 ? "0" + h : h;

            var m = date.getMinutes();
            m = m < 10 ? "0" + m : m;
            this._timeLabel.string = "" + h + ":" + m;
        }

        if (this._lastPlayTime != null) {
            if (Date.now() > this._lastPlayTime + 200) {
                this.onPlayerOver();
                this._lastPlayTime = null;
            }
        } else {
            this.playVoice();
        }
        this.ipWarning();
    },

    onPlayerOver: function onPlayerOver() {
        cc.vv.audioMgr.resumeAll();
        console.log("onPlayCallback:" + this._playingSeat);
        var localIndex = this._playingSeat;
        this._playingSeat = null;
        this._seats[localIndex].voiceMsg(false);
        this._seats2[localIndex].voiceMsg(false);
    },

    onDestroy: function onDestroy() {
        cc.vv.voiceMgr.stop();
        //        cc.vv.voiceMgr.onPlayCallback = null;
    }
});

cc._RF.pop();
},{}],"MahjongMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '0ecea6X+IFIK5XFdJe38hXa', 'MahjongMgr');
// scripts/MahjongMgr.js

"use strict";

var mahjongSprites = [];

cc.Class({
    extends: cc.Component,

    properties: {
        leftAtlas: {
            default: null,
            type: cc.SpriteAtlas
        },

        rightAtlas: {
            default: null,
            type: cc.SpriteAtlas
        },

        bottomAtlas: {
            default: null,
            type: cc.SpriteAtlas
        },

        bottomFoldAtlas: {
            default: null,
            type: cc.SpriteAtlas
        },

        pengPrefabSelf: {
            default: null,
            type: cc.Prefab
        },

        pengPrefabLeft: {
            default: null,
            type: cc.Prefab
        },

        emptyAtlas: {
            default: null,
            type: cc.SpriteAtlas
        },

        holdsEmpty: {
            default: [],
            type: [cc.SpriteFrame]
        },

        _sides: null,
        _pres: null,
        _foldPres: null
    },

    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }
        this._sides = ["myself", "right", "up", "left"];
        this._pres = ["M_", "R_", "B_", "L_"];
        this._foldPres = ["B_", "R_", "B_", "L_"];
        cc.vv.mahjongmgr = this;
        //筒
        for (var i = 1; i < 10; ++i) {
            mahjongSprites.push("dot_" + i);
        }

        //条
        for (var i = 1; i < 10; ++i) {
            mahjongSprites.push("bamboo_" + i);
        }

        //万
        for (var i = 1; i < 10; ++i) {
            mahjongSprites.push("character_" + i);
        }

        //中、发、白
        mahjongSprites.push("red");
        mahjongSprites.push("green");
        mahjongSprites.push("white");

        //东西南北风
        mahjongSprites.push("wind_east");
        mahjongSprites.push("wind_west");
        mahjongSprites.push("wind_south");
        mahjongSprites.push("wind_north");

        //春夏秋冬
        mahjongSprites.push("spring");
        mahjongSprites.push("summer");
        mahjongSprites.push("autumn");
        mahjongSprites.push("winter");

        //梅兰竹菊 
        mahjongSprites.push("plum");
        mahjongSprites.push("orchid");
        mahjongSprites.push("bamboo");
        mahjongSprites.push("chrysanthemum");
    },

    getMahjongSpriteByID: function getMahjongSpriteByID(id) {
        return mahjongSprites[id];
    },

    getMahjongType: function getMahjongType(id) {
        if (id >= 0 && id < 9) {
            return 0;
        } else if (id >= 9 && id < 18) {
            return 1;
        } else if (id >= 18 && id < 27) {
            return 2;
        }
    },

    getSpriteFrameByMJID: function getSpriteFrameByMJID(pre, mjid) {
        var spriteFrameName = this.getMahjongSpriteByID(mjid);
        spriteFrameName = pre + spriteFrameName;
        if (pre == "M_") {
            return this.bottomAtlas.getSpriteFrame(spriteFrameName);
        } else if (pre == "B_") {
            return this.bottomFoldAtlas.getSpriteFrame(spriteFrameName);
        } else if (pre == "L_") {
            return this.leftAtlas.getSpriteFrame(spriteFrameName);
        } else if (pre == "R_") {
            return this.rightAtlas.getSpriteFrame(spriteFrameName);
        }
    },

    getAudioURLByMJID: function getAudioURLByMJID(id) {
        var realId = 0;
        if (id >= 0 && id < 9) {
            realId = id + 21;
        } else if (id >= 9 && id < 18) {
            realId = id - 8;
        } else if (id >= 18 && id < 27) {
            realId = id - 7;
        }
        if (id == 30) {
            realId = 31;
        }

        if (id == 31) {
            realId = 41;
        }

        if (id == 32) {
            realId = 51;
        }

        if (id == 33) {
            realId = 61;
        }

        if (id == 27) {
            realId = 71;
        }

        if (id == 28) {
            realId = 81;
        }

        if (id == 29) {
            realId = 91;
        }

        return "nv/" + realId + ".mp3";
    },

    getEmptySpriteFrame: function getEmptySpriteFrame(side) {
        if (side == "up") {
            return this.emptyAtlas.getSpriteFrame("e_mj_b_up");
        } else if (side == "myself") {
            return this.emptyAtlas.getSpriteFrame("e_mj_b_bottom");
        } else if (side == "left") {
            return this.emptyAtlas.getSpriteFrame("e_mj_b_left");
        } else if (side == "right") {
            return this.emptyAtlas.getSpriteFrame("e_mj_b_right");
        }
    },

    getHoldsEmptySpriteFrame: function getHoldsEmptySpriteFrame(side) {
        if (side == "up") {
            return this.emptyAtlas.getSpriteFrame("e_mj_up");
        } else if (side == "myself") {
            return null;
        } else if (side == "left") {
            return this.emptyAtlas.getSpriteFrame("e_mj_left");
        } else if (side == "right") {
            return this.emptyAtlas.getSpriteFrame("e_mj_right");
        }
    },

    sortMJ: function sortMJ(mahjongs, dingque) {
        var self = this;
        mahjongs.sort(function (a, b) {
            if (dingque >= 0) {
                var t1 = self.getMahjongType(a);
                var t2 = self.getMahjongType(b);
                if (t1 != t2) {
                    if (dingque == t1) {
                        return 1;
                    } else if (dingque == t2) {
                        return -1;
                    }
                }
            }
            return a - b;
        });
    },

    getSide: function getSide(localIndex) {
        return this._sides[localIndex];
    },

    getPre: function getPre(localIndex) {
        return this._pres[localIndex];
    },

    getFoldPre: function getFoldPre(localIndex) {
        return this._foldPres[localIndex];
    }
});

cc._RF.pop();
},{}],"Net":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'b1cc9yRd15CXqFg0vTGKZUk', 'Net');
// scripts/Net.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (window.io == null) {
    window.io = require("socket-io");
}

var Global = cc.Class({
    extends: cc.Component,
    statics: {
        ip: "",
        sio: null,
        isPinging: false,
        fnDisconnect: null,
        handlers: {},
        addHandler: function addHandler(event, fn) {
            if (this.handlers[event]) {
                console.log("event:" + event + "' handler has been registered.");
                return;
            }

            var handler = function handler(data) {
                //console.log(event + "(" + typeof(data) + "):" + (data? data.toString():"null"));
                if (event != "disconnect" && typeof data == "string") {
                    data = JSON.parse(data);
                }
                fn(data);
            };

            this.handlers[event] = handler;
            if (this.sio) {
                console.log("register:function " + event);
                this.sio.on(event, handler);
            }
        },
        connect: function connect(fnConnect, fnError) {
            var self = this;

            var opts = {
                'reconnection': false,
                'force new connection': true,
                'transports': ['websocket', 'polling']
            };
            this.sio = window.io.connect(this.ip, opts);
            this.sio.on('reconnect', function () {
                console.log('reconnection');
            });
            this.sio.on('connect', function (data) {
                self.sio.connected = true;
                fnConnect(data);
            });

            this.sio.on('disconnect', function (data) {
                console.log("disconnect");
                self.sio.connected = false;
                self.close();
            });

            this.sio.on('connect_failed', function () {
                console.log('connect_failed');
            });

            for (var key in this.handlers) {
                var value = this.handlers[key];
                if (typeof value == "function") {
                    if (key == 'disconnect') {
                        this.fnDisconnect = value;
                    } else {
                        console.log("register:function " + key);
                        this.sio.on(key, value);
                    }
                }
            }

            this.startHearbeat();
        },

        startHearbeat: function startHearbeat() {
            this.sio.on('game_pong', function () {
                console.log('game_pong');
                self.lastRecieveTime = Date.now();
            });
            this.lastRecieveTime = Date.now();
            var self = this;
            console.log(1);
            if (!self.isPinging) {
                console.log(1);
                self.isPinging = true;
                setInterval(function () {
                    console.log(3);
                    if (self.sio) {
                        console.log(4);
                        if (Date.now() - self.lastRecieveTime > 10000) {
                            self.close();
                        } else {
                            self.ping();
                        }
                    }
                }, 5000);
            }
        },
        send: function send(event, data) {
            if (this.sio.connected) {
                if (data != null && (typeof data === "undefined" ? "undefined" : _typeof(data)) == "object") {
                    data = JSON.stringify(data);
                    //console.log(data);              
                }
                this.sio.emit(event, data);
            }
        },

        ping: function ping() {
            this.send('game_ping');
        },

        close: function close() {
            console.log('close');
            if (this.sio && this.sio.connected) {
                this.sio.connected = false;
                this.sio.disconnect();
                this.sio = null;
            }
            if (this.fnDisconnect) {
                this.fnDisconnect();
                this.fnDisconnect = null;
            }
        },

        test: function test(fnResult) {
            var xhr = null;
            var fn = function fn(ret) {
                fnResult(ret.isonline);
                xhr = null;
            };

            var arr = this.ip.split(':');
            var data = {
                account: cc.vv.userMgr.account,
                sign: cc.vv.userMgr.sign,
                ip: arr[0],
                port: arr[1]
            };
            xhr = cc.vv.http.sendRequest("/is_server_online", data, fn);
            setTimeout(function () {
                if (xhr) {
                    xhr.abort();
                    fnResult(false);
                }
            }, 1500);
            /*
            var opts = {
                'reconnection':false,
                'force new connection': true,
                'transports':['websocket', 'polling']
            }
            var self = this;
            this.testsio = window.io.connect(this.ip,opts);
            this.testsio.on('connect',function(){
                console.log('connect');
                self.testsio.close();
                self.testsio = null;
                fnResult(true);
            });
            this.testsio.on('connect_error',function(){
                console.log('connect_failed');
                self.testsio = null;
                fnResult(false);
            });
            */
        }
    }
});

cc._RF.pop();
},{"socket-io":"socket-io"}],"NoticeTip":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'df61b4+FzFDvbpO5g8UNVIM', 'NoticeTip');
// scripts/components/NoticeTip.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _guohu: null,
        _info: null,
        _guohuTime: -1
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._guohu = cc.find("Canvas/tip_notice");
        this._guohu.active = false;

        this._info = cc.find("Canvas/tip_notice/info").getComponent(cc.Label);

        var self = this;
        this.node.on('push_notice', function (data) {
            var data = data.detail;
            self._guohu.active = true;
            self._guohuTime = data.time;
            self._info.string = data.info;
        });
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._guohuTime > 0) {
            this._guohuTime -= dt;
            if (this._guohuTime < 0) {
                this._guohu.active = false;
            }
        }
    }
});

cc._RF.pop();
},{}],"OnBack":[function(require,module,exports){
"use strict";
cc._RF.push(module, '6fd982Tyi5NOYJWt/fGY8Lj', 'OnBack');
// scripts/components/OnBack.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {
        var btn = this.node.getChildByName("btn_back");
        cc.vv.utils.addClickEvent(btn, this.node, "OnBack", "onBtnClicked");
    },

    onBtnClicked: function onBtnClicked(event) {
        if (event.target.name == "btn_back") {
            this.node.active = false;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"PengGangs":[function(require,module,exports){
"use strict";
cc._RF.push(module, '279d9pNFGRB3rD/ngr1LIXQ', 'PengGangs');
// scripts/components/PengGangs.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (!cc.vv) {
            return;
        }

        this.hidehuas();

        var gameChild = this.node.getChildByName("game");
        var myself = gameChild.getChildByName("myself");
        var pengangroot = myself.getChildByName("penggangs");
        var realwidth = cc.director.getVisibleSize().width;
        var scale = realwidth / 1280;
        pengangroot.scaleX *= scale;
        pengangroot.scaleY *= scale;

        var self = this;
        this.node.on('peng_notify', function (data) {
            //刷新所有的牌
            console.log("penggang plat");
            console.log(data.detail);
            var data = data.detail;
            self.onPengGangChanged(data);
        });

        this.node.on('gang_notify', function (data) {
            //刷新所有的牌
            //console.log(data.detail);
            var data = data.detail;
            self.onPengGangChanged(data.seatData);
        });

        this.node.on('chi_notify', function (data) {
            //刷新所有的牌
            console.log("penggang plat");
            console.log(data.detail);
            var data = data.detail;
            self.onPengGangChanged(data);
        });

        this.node.on('gethua_notify', function (data) {
            console.log("gethua_notify accept");
            //刷新所有的牌
            var data = data.detail;
            self.onHuaChanged(data);
        });

        this.node.on('game_begin', function (data) {
            self.onGameBein();
        });

        var seats = cc.vv.gameNetMgr.seats;
        for (var i in seats) {
            this.onPengGangChanged(seats[i]);
        }
    },

    //隐藏所有花牌
    hidehuas: function hidehuas() {
        //隐藏所有花牌
        var gameChild = this.node.getChildByName("game");
        var sides = new Array("right", "left", "up", "myself");
        for (var j = 0; j < 4; j++) {
            var side = gameChild.getChildByName(sides[j]);
            var huasroot = side.getChildByName("huas");
            for (var i = 0; i < huasroot.childrenCount; i++) {
                huasroot.children[i].active = false;
            }
        }
    },

    onGameBein: function onGameBein() {
        this.hideSide("myself");
        this.hideSide("right");
        this.hideSide("up");
        this.hideSide("left");
        this.hidehuas();
    },

    hideSide: function hideSide(side) {
        var gameChild = this.node.getChildByName("game");
        var myself = gameChild.getChildByName(side);
        var pengangroot = myself.getChildByName("penggangs");
        if (pengangroot) {
            for (var i = 0; i < pengangroot.childrenCount; ++i) {
                pengangroot.children[i].active = false;
            }
        }
    },

    onPengGangChanged: function onPengGangChanged(seatData) {

        if (seatData.angangs == null && seatData.diangangs == null && seatData.wangangs == null && seatData.pengs == null && seatData.chis == null) {
            return;
        }
        var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatData.seatindex);
        var side = cc.vv.mahjongmgr.getSide(localIndex);
        var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);

        console.log("localIndex = " + localIndex);
        console.log("side = " + side);
        console.log("pre = " + pre);
        console.log("onPengGangChanged" + localIndex);

        var gameChild = this.node.getChildByName("game");
        var myself = gameChild.getChildByName(side);
        var pengangroot = myself.getChildByName("penggangs");

        for (var i = 0; i < pengangroot.childrenCount; ++i) {
            pengangroot.children[i].active = false;
        }
        //初始化杠牌
        var index = 0;

        var gangs = seatData.angangs;
        for (var i = 0; i < gangs.length; ++i) {
            var mjid = gangs[i];
            this.initPengAndGangs(pengangroot, side, pre, index, mjid, "angang");
            index++;
        }
        var gangs = seatData.diangangs;
        for (var i = 0; i < gangs.length; ++i) {
            var mjid = gangs[i];
            this.initPengAndGangs(pengangroot, side, pre, index, mjid, "diangang");
            index++;
        }

        var gangs = seatData.wangangs;
        for (var i = 0; i < gangs.length; ++i) {
            var mjid = gangs[i];
            this.initPengAndGangs(pengangroot, side, pre, index, mjid, "wangang");
            index++;
        }

        //初始化碰牌
        var pengs = seatData.pengs;
        if (pengs) {
            for (var i = 0; i < pengs.length; ++i) {
                var mjid = pengs[i];
                this.initPengAndGangs(pengangroot, side, pre, index, mjid, "peng");
                index++;
            }
        }

        //初始化吃牌
        console.log("初始化吃牌");
        console.log(seatData);
        var chis = seatData.chis;
        if (chis) {
            for (var i = 0; i < chis.length; ++i) {
                var mjid = chis[i];
                this.initPengAndGangs(pengangroot, side, pre, index, mjid, "chi");
                index++;
            }
        }

        //初始化花牌
        console.log("初始化花牌");
        console.log(seatData);
        var huas = seatData.huas;
        if (huas) {
            for (var i = 0; i < huas.length; ++i) {
                var mjid = huas[i];
                this.onHuaChanged(seatData);
                index++;
            }
        }
    },

    initPengAndGangs: function initPengAndGangs(pengangroot, side, pre, index, mjid, flag) {
        var pgroot = null;
        if (pengangroot.childrenCount <= index) {
            if (side == "left" || side == "right") {
                pgroot = cc.instantiate(cc.vv.mahjongmgr.pengPrefabLeft);
            } else {
                pgroot = cc.instantiate(cc.vv.mahjongmgr.pengPrefabSelf);
            }

            pengangroot.addChild(pgroot);
        } else {
            pgroot = pengangroot.children[index];
            pgroot.active = true;
        }

        if (side == "left") {
            pgroot.y = -(index * 25 * 3);
        } else if (side == "right") {
            pgroot.y = index * 25 * 3;
            pgroot.setLocalZOrder(-index);
        } else if (side == "myself") {
            pgroot.x = index * 55 * 3 + index * 10;
        } else {
            pgroot.x = -(index * 55 * 3);
        }

        var sprites = pgroot.getComponentsInChildren(cc.Sprite);
        // if(flag == "chi"){
        //     console.log("排列吃！");
        //     console.log(mjid);
        //     for(var s = 0; s < 3; s++){
        //         var sprite = sprites[s];
        //         sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre,mjid[s]);
        //     }
        //     return;
        // }
        if (flag == "chi") {
            var mjid1 = [].concat(mjid);
            var pai = mjid1.pop();
            mjid1.sort(function (a, b) {
                return parseInt(a) - parseInt(b);
            });

            mjid1[2] = mjid1[1];
            mjid1[1] = mjid1[0];
            mjid1[0] = pai;
        }
        for (var s = 0; s < sprites.length; ++s) {
            console.log("in xunhuan");
            var sprite = sprites[s];
            if (sprite.node.name == "gang") {
                var isGang = flag != "peng";
                sprite.node.active = isGang;
                sprite.node.scaleX = 1.0;
                sprite.node.scaleY = 1.0;
                if (flag == "angang") {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getEmptySpriteFrame(side);
                    if (side == "myself" || side == "up") {
                        sprite.node.scaleX = 1.4;
                        sprite.node.scaleY = 1.4;
                    }
                } else {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, mjid);
                }
            } else {
                if (flag == "peng") {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, mjid);
                } else if (flag == "chi") {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, mjid1[s]);
                } else {
                    sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, mjid);
                }
            }
        }
    },

    onHuaChanged: function onHuaChanged(seatData) {
        console.log("onHuaChanged!!!");
        console.log(seatData);
        var localIndex = cc.vv.gameNetMgr.getLocalIndex(seatData.seatindex);
        var side = cc.vv.mahjongmgr.getSide(localIndex);
        var pre = cc.vv.mahjongmgr.getFoldPre(localIndex);

        var gameChild = this.node.getChildByName("game");
        var side = gameChild.getChildByName(side);
        var huas = side.getChildByName("huas");

        console.log(side);
        console.log(huas);

        for (var i = 0; i < seatData.huas.length; i++) {
            console.log("show hua!" + seatData.huas[i]);
            var nowchild = huas.children[i];
            nowchild.active = true;
            console.log(nowchild.active);
            var sprite = nowchild.getComponent(cc.Sprite);
            sprite.spriteFrame = cc.vv.mahjongmgr.getSpriteFrameByMJID(pre, seatData.huas[i]);
        }
    },

    initHuas: function initHuas() {}

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"PopupMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'bc0d2VLgL1Avo166tHLsjCJ', 'PopupMgr');
// scripts/components/PopupMgr.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _popuproot: null,
        _settings: null,
        _dissolveNotice: null,

        _endTime: -1,
        _extraInfo: null,
        _noticeLabel: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        cc.vv.popupMgr = this;

        this._popuproot = cc.find("Canvas/popups");
        this._settings = cc.find("Canvas/popups/settings");
        this._dissolveNotice = cc.find("Canvas/popups/dissolve_notice");
        this._noticeLabel = this._dissolveNotice.getChildByName("info").getComponent(cc.Label);

        this.closeAll();

        this.addBtnHandler("settings/btn_close");
        this.addBtnHandler("settings/btn_sqjsfj");
        this.addBtnHandler("dissolve_notice/btn_agree");
        this.addBtnHandler("dissolve_notice/btn_reject");
        this.addBtnHandler("dissolve_notice/btn_ok");

        var self = this;
        this.node.on("dissolve_notice", function (event) {
            var data = event.detail;
            self.showDissolveNotice(data);
        });

        this.node.on("dissolve_cancel", function (event) {
            self.closeAll();
        });
    },

    start: function start() {
        if (cc.vv.gameNetMgr.dissoveData) {
            this.showDissolveNotice(cc.vv.gameNetMgr.dissoveData);
        }
    },

    addBtnHandler: function addBtnHandler(btnName) {
        var btn = cc.find("Canvas/popups/" + btnName);
        this.addClickEvent(btn, this.node, "PopupMgr", "onBtnClicked");
    },

    addClickEvent: function addClickEvent(node, target, component, handler) {
        var eventHandler = new cc.Component.EventHandler();
        eventHandler.target = target;
        eventHandler.component = component;
        eventHandler.handler = handler;

        var clickEvents = node.getComponent(cc.Button).clickEvents;
        clickEvents.push(eventHandler);
    },

    onBtnClicked: function onBtnClicked(event) {
        this.closeAll();
        var btnName = event.target.name;
        if (btnName == "btn_agree") {
            cc.vv.net.send("dissolve_agree");
        } else if (btnName == "btn_reject") {
            cc.vv.net.send("dissolve_reject");
        } else if (btnName == "btn_sqjsfj") {
            cc.vv.net.send("dissolve_request");
        }
    },

    closeAll: function closeAll() {
        this._popuproot.active = false;
        this._settings.active = false;
        this._dissolveNotice.active = false;
    },

    showSettings: function showSettings() {
        this.closeAll();
        this._popuproot.active = true;
        this._settings.active = true;
    },

    showDissolveRequest: function showDissolveRequest() {
        this.closeAll();
        this._popuproot.active = true;
    },

    showDissolveNotice: function showDissolveNotice(data) {
        this._endTime = Date.now() / 1000 + data.time;
        this._extraInfo = "";
        for (var i = 0; i < data.states.length; ++i) {
            var b = data.states[i];
            var name = cc.vv.gameNetMgr.seats[i].name;
            if (b) {
                this._extraInfo += "\n[已同意] " + name;
            } else {
                this._extraInfo += "\n[待确认] " + name;
            }
        }
        this.closeAll();
        this._popuproot.active = true;
        this._dissolveNotice.active = true;;
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._endTime > 0) {
            var lastTime = this._endTime - Date.now() / 1000;
            if (lastTime < 0) {
                this._endTime = -1;
            }

            var m = Math.floor(lastTime / 60);
            var s = Math.ceil(lastTime - m * 60);

            var str = "";
            if (m > 0) {
                str += m + "分";
            }

            this._noticeLabel.string = str + s + "秒后房间将自动解散" + this._extraInfo;
        }
    }
});

cc._RF.pop();
},{}],"RadioButton":[function(require,module,exports){
"use strict";
cc._RF.push(module, '8d571y2U+9AiKntO+TSf0Fb', 'RadioButton');
// scripts/components/RadioButton.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        target: cc.Node,
        sprite: cc.SpriteFrame,
        checkedSprite: cc.SpriteFrame,
        checked: false,
        groupId: -1
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }
        if (cc.vv.radiogroupmgr == null) {
            var RadioGroupMgr = require("RadioGroupMgr");
            cc.vv.radiogroupmgr = new RadioGroupMgr();
            cc.vv.radiogroupmgr.init();
        }
        console.log(_typeof(cc.vv.radiogroupmgr.add));
        cc.vv.radiogroupmgr.add(this);

        this.refresh();
    },

    refresh: function refresh() {
        var targetSprite = this.target.getComponent(cc.Sprite);
        if (this.checked) {
            targetSprite.spriteFrame = this.checkedSprite;
        } else {
            targetSprite.spriteFrame = this.sprite;
        }
    },

    check: function check(value) {
        this.checked = value;
        this.refresh();
    },

    onClicked: function onClicked() {
        cc.vv.radiogroupmgr.check(this);
    },

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    onDestroy: function onDestroy() {
        if (cc.vv && cc.vv.radiogroupmgr) {
            cc.vv.radiogroupmgr.del(this);
        }
    }
});

cc._RF.pop();
},{"RadioGroupMgr":"RadioGroupMgr"}],"RadioGroupMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '824eapeRYNKY4RJzg2Z4YA2', 'RadioGroupMgr');
// scripts/components/RadioGroupMgr.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _groups: null
    },

    // use this for initialization
    init: function init() {
        this._groups = {};
    },

    add: function add(radioButton) {
        var groupId = radioButton.groupId;
        var buttons = this._groups[groupId];
        if (buttons == null) {
            buttons = [];
            this._groups[groupId] = buttons;
        }
        buttons.push(radioButton);
    },

    del: function del(radioButton) {
        var groupId = radioButton.groupId;
        var buttons = this._groups[groupId];
        if (buttons == null) {
            return;
        }
        var idx = buttons.indexOf(radioButton);
        if (idx != -1) {
            buttons.splice(idx, 1);
        }
        if (buttons.length == 0) {
            delete this._groups[groupId];
        }
    },

    check: function check(radioButton) {
        var groupId = radioButton.groupId;
        var buttons = this._groups[groupId];
        if (buttons == null) {
            return;
        }
        for (var i = 0; i < buttons.length; ++i) {
            var btn = buttons[i];
            if (btn == radioButton) {
                btn.check(true);
            } else {
                btn.check(false);
            }
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"ReConnect":[function(require,module,exports){
"use strict";
cc._RF.push(module, '7f553G0boRH6KrTE7wACaXx', 'ReConnect');
// scripts/components/ReConnect.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _reconnect: null,
        _lblTip: null,
        _lastPing: 0
    },

    // use this for initialization
    onLoad: function onLoad() {
        this._reconnect = cc.find("Canvas/reconnect");
        this._lblTip = cc.find("Canvas/reconnect/tip").getComponent(cc.Label);
        var self = this;

        var fnTestServerOn = function fnTestServerOn() {
            cc.vv.net.test(function (ret) {
                if (ret) {
                    var roomId = cc.vv.userMgr.oldRoomId;
                    if (roomId != null) {
                        cc.vv.userMgr.oldRoomId = null;
                        cc.vv.userMgr.enterRoom(roomId);
                    } else {
                        cc.director.loadScene('hall');
                    }
                    //cc.director.loadScene('hall');  
                    //cc.director.loadScene('mjgame');  
                } else {
                    setTimeout(fnTestServerOn, 10000);
                }
            });
        };

        var fn = function fn(data) {
            self.node.off('disconnect', fn);
            self._reconnect.active = true;
            fnTestServerOn();
        };
        console.log("adasfdasdfsdf");
        this.node.on('disconnect', fn);
    },
    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._reconnect.active) {
            var t = Math.floor(Date.now() / 1000) % 4;
            this._lblTip.string = "与服务器断开连接，正在尝试重连";
            for (var i = 0; i < t; ++i) {
                this._lblTip.string += '.';
            }
        }
    }
});

cc._RF.pop();
},{}],"ReplayCtrl":[function(require,module,exports){
"use strict";
cc._RF.push(module, '21e6a+ajGNDTJwDHbV3A72m', 'ReplayCtrl');
// scripts/components/ReplayCtrl.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _nextPlayTime: 1,
        _replay: null,
        _isPlaying: true
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this._replay = cc.find("Canvas/replay");
        this._replay.active = cc.vv.replayMgr.isReplay();
    },

    onBtnPauseClicked: function onBtnPauseClicked() {
        this._isPlaying = false;
    },

    onBtnPlayClicked: function onBtnPlayClicked() {
        this._isPlaying = true;
    },

    onBtnBackClicked: function onBtnBackClicked() {
        cc.vv.replayMgr.clear();
        cc.vv.gameNetMgr.reset();
        cc.vv.gameNetMgr.roomId = null;
        cc.director.loadScene("hall");
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (cc.vv) {
            if (this._isPlaying && cc.vv.replayMgr.isReplay() == true && this._nextPlayTime > 0) {
                this._nextPlayTime -= dt;
                if (this._nextPlayTime < 0) {
                    this._nextPlayTime = cc.vv.replayMgr.takeAction();
                }
            }
        }
    }
});

cc._RF.pop();
},{}],"ReplayMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '1a6a1p86NFL6KZEZCnbu7tt', 'ReplayMgr');
// scripts/ReplayMgr.js

"use strict";

var ACTION_CHUPAI = 1;
var ACTION_MOPAI = 2;
var ACTION_PENG = 3;
var ACTION_GANG = 4;
var ACTION_HU = 5;
var ACTION_CHI = 7;
var ACTION_BUHUA = 8;

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _lastAction: null,
        _actionRecords: null,
        _currentIndex: 0
    },

    // use this for initialization
    onLoad: function onLoad() {},

    clear: function clear() {
        this._lastAction = null;
        this._actionRecords = null;
        this._currentIndex = 0;
    },

    init: function init(data) {
        this._actionRecords = data.action_records;
        if (this._actionRecords == null) {
            this._actionRecords = {};
        }
        this._currentIndex = 0;
        this._lastAction = null;
    },

    isReplay: function isReplay() {
        return this._actionRecords != null;
    },

    getNextAction: function getNextAction() {
        var actions = [].concat(this._actionRecords);
        actions.splice(0, this._currentIndex);
        console.log(actions);

        if (this._currentIndex >= this._actionRecords.length) {
            return null;
        }

        var si = this._actionRecords[this._currentIndex++];
        var action = this._actionRecords[this._currentIndex++];
        if (action != ACTION_CHI && action != ACTION_BUHUA) {
            var pai = this._actionRecords[this._currentIndex++];
            return { si: si, type: action, pai: pai };
        } else if (action == ACTION_CHI) {
            var pai = this._actionRecords[this._currentIndex++];
            var chigroup = this._actionRecords[this._currentIndex++];
            return { si: si, type: action, pai: pai, chigroup: chigroup };
        } else if (action == ACTION_BUHUA) {
            var buhuas = this._actionRecords[this._currentIndex++];
            var holds = this._actionRecords[this._currentIndex++];
            return { si: si, type: action, buhuas: buhuas, holds: holds };
        }
    },

    takeAction: function takeAction() {
        var action = this.getNextAction();
        if (this._lastAction != null && this._lastAction.type == ACTION_CHUPAI) {
            if (action != null && action.type != ACTION_PENG && action.type != ACTION_GANG && action.type != ACTION_HU) {
                cc.vv.gameNetMgr.doGuo(this._lastAction.si, this._lastAction.pai);
            }
        }
        this._lastAction = action;
        if (action == null) {
            return -1;
        }
        var nextActionDelay = 1.0;
        if (action.type == ACTION_CHUPAI) {
            console.log("chupai" + action.pai);
            cc.vv.gameNetMgr.doChupai(action.si, action.pai);
            return 1.0;
        } else if (action.type == ACTION_MOPAI) {
            console.log("mopai" + action.pai);
            cc.vv.gameNetMgr.doMopai(action.si, action.pai);
            cc.vv.gameNetMgr.doTurnChange(action.si);
            return 0.5;
        } else if (action.type == ACTION_PENG) {
            console.log("peng" + action.pai);
            cc.vv.gameNetMgr.doPeng(action.si, action.pai);
            cc.vv.gameNetMgr.doTurnChange(action.si);
            return 1.0;
        } else if (action.type == ACTION_GANG) {
            console.log("gang" + action.pai);
            cc.vv.gameNetMgr.dispatchEvent('hangang_notify', action.si);
            cc.vv.gameNetMgr.doGang(action.si, action.pai);
            cc.vv.gameNetMgr.doTurnChange(action.si);
            return 1.0;
        } else if (action.type == ACTION_HU) {
            console.log("hu" + action.pai);
            cc.vv.gameNetMgr.doHu({ seatindex: action.si, hupai: action.pai, iszimo: false });
            return 1.5;
        } else if (action.type == ACTION_CHI) {
            console.log("chi" + action.pai);
            cc.vv.gameNetMgr.doChi(action.si, action.pai, action.chigroup);
            return 1.5;
        } else if (action.type == ACTION_BUHUA) {
            console.log("chi" + action.pai);
            cc.vv.gameNetMgr.doBuhuaforme(action.si, action.holds, action.buhuas);
            cc.vv.gameNetMgr.doBuhua(action.si, action.buhuas);
            return 1.5;
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"Seat":[function(require,module,exports){
"use strict";
cc._RF.push(module, '820870ltMZNDYlvzr+qCDEJ', 'Seat');
// scripts/components/Seat.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        _sprIcon: null,
        _zhuang: null,
        _ready: null,
        _offline: null,
        _lblName: null,
        _lblScore: null,
        _scoreBg: null,
        _nddayingjia: null,
        _voicemsg: null,

        _chatBubble: null,
        _emoji: null,
        _lastChatTime: -1,

        _userName: "",
        _score: 0,
        _dayingjia: false,
        _isOffline: false,
        _isReady: false,
        _isZhuang: false,
        _userId: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this._sprIcon = this.node.getChildByName("icon").getComponent("ImageLoader");
        this._lblName = this.node.getChildByName("name").getComponent(cc.Label);
        this._lblScore = this.node.getChildByName("score").getComponent(cc.Label);
        this._voicemsg = this.node.getChildByName("voicemsg");
        this._xuanpai = this.node.getChildByName("xuanpai");
        this.refreshXuanPaiState();

        if (this._voicemsg) {
            this._voicemsg.active = false;
        }

        if (this._sprIcon && this._sprIcon.getComponent(cc.Button)) {
            cc.vv.utils.addClickEvent(this._sprIcon, this.node, "Seat", "onIconClicked");
        }

        this._offline = this.node.getChildByName("offline");

        this._ready = this.node.getChildByName("ready");

        this._zhuang = this.node.getChildByName("zhuang");

        this._scoreBg = this.node.getChildByName("Z_money_frame");
        this._nddayingjia = this.node.getChildByName("dayingjia");

        this._chatBubble = this.node.getChildByName("ChatBubble");
        if (this._chatBubble != null) {
            this._chatBubble.active = false;
        }

        this._emoji = this.node.getChildByName("emoji");
        if (this._emoji != null) {
            this._emoji.active = false;
        }

        this.refresh();

        if (this._sprIcon && this._userId) {
            this._sprIcon.setUserID(this._userId);
        }
    },

    onIconClicked: function onIconClicked() {
        var iconSprite = this._sprIcon.node.getComponent(cc.Sprite);
        if (this._userId != null && this._userId > 0) {
            var seat = cc.vv.gameNetMgr.getSeatByID(this._userId);
            var sex = 0;
            if (cc.vv.baseInfoMap) {
                var info = cc.vv.baseInfoMap[this._userId];
                if (info) {
                    sex = info.sex;
                }
            }
            cc.vv.userinfoShow.show(seat.name, seat.userid, iconSprite, sex, seat.ip);
        }
    },

    refresh: function refresh() {
        if (this._lblName != null) {
            this._lblName.string = this._userName;
        }

        if (this._lblScore != null) {
            this._lblScore.string = this._score;
        }

        if (this._nddayingjia != null) {
            this._nddayingjia.active = this._dayingjia == true;
        }

        if (this._offline) {
            this._offline.active = this._isOffline && this._userName != "";
        }

        if (this._ready) {
            this._ready.active = this._isReady && cc.vv.gameNetMgr.numOfGames > 0;
        }

        if (this._zhuang) {
            this._zhuang.active = this._isZhuang;
        }

        this.node.active = this._userName != null && this._userName != "";
    },

    setInfo: function setInfo(name, score, dayingjia) {
        this._userName = name;
        this._score = score;
        if (this._score == null) {
            this._score = 0;
        }
        this._dayingjia = dayingjia;

        if (this._scoreBg != null) {
            this._scoreBg.active = this._score != null;
        }

        if (this._lblScore != null) {
            this._lblScore.node.active = this._score != null;
        }

        this.refresh();
    },


    setZhuang: function setZhuang(value) {
        if (this._zhuang) {
            this._zhuang.active = value;
        }
    },

    setReady: function setReady(isReady) {
        this._isReady = isReady;
        if (this._ready) {
            this._ready.active = this._isReady && cc.vv.gameNetMgr.numOfGames > 0;
        }
    },

    setID: function setID(id) {
        var idNode = this.node.getChildByName("id");
        if (idNode) {
            var lbl = idNode.getComponent(cc.Label);
            lbl.string = "ID:" + id;
        }

        this._userId = id;
        if (this._sprIcon) {
            this._sprIcon.setUserID(id);
        }
    },

    setOffline: function setOffline(isOffline) {
        this._isOffline = isOffline;
        if (this._offline) {
            this._offline.active = this._isOffline && this._userName != "";
        }
    },

    chat: function chat(content) {
        if (this._chatBubble == null || this._emoji == null) {
            return;
        }
        this._emoji.active = false;
        this._chatBubble.active = true;
        this._chatBubble.getComponent(cc.Label).string = content;
        this._chatBubble.getChildByName("New Label").getComponent(cc.Label).string = content;
        this._lastChatTime = 3;
    },

    emoji: function emoji(_emoji) {
        //emoji = JSON.parse(emoji);
        if (this._emoji == null || this._emoji == null) {
            return;
        }
        console.log(_emoji);
        this._chatBubble.active = false;
        this._emoji.active = true;
        this._emoji.getComponent(cc.Animation).play(_emoji);
        this._lastChatTime = 3;
    },

    voiceMsg: function voiceMsg(show) {
        if (this._voicemsg) {
            this._voicemsg.active = show;
        }
    },

    refreshXuanPaiState: function refreshXuanPaiState() {
        if (this._xuanpai == null) {
            return;
        }

        this._xuanpai.active = cc.vv.gameNetMgr.isHuanSanZhang;
        if (cc.vv.gameNetMgr.isHuanSanZhang == false) {
            return;
        }

        this._xuanpai.getChildByName("xz").active = false;
        this._xuanpai.getChildByName("xd").active = false;

        var seat = cc.vv.gameNetMgr.getSeatByID(this._userId);
        if (seat) {
            if (seat.huanpais == null) {
                this._xuanpai.getChildByName("xz").active = true;
            } else {
                this._xuanpai.getChildByName("xd").active = true;
            }
        }
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._lastChatTime > 0) {
            this._lastChatTime -= dt;
            if (this._lastChatTime < 0) {
                this._chatBubble.active = false;
                this._emoji.active = false;
                this._emoji.getComponent(cc.Animation).stop();
            }
        }
    }
});

cc._RF.pop();
},{}],"Settings":[function(require,module,exports){
"use strict";
cc._RF.push(module, '4c04fyd89JAZY7qGjvubi+f', 'Settings');
// scripts/components/Settings.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _btnYXOpen: null,
        _btnYXClose: null,
        _btnYYOpen: null,
        _btnYYClose: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this._btnYXOpen = this.node.getChildByName("yinxiao").getChildByName("btn_yx_open");
        this._btnYXClose = this.node.getChildByName("yinxiao").getChildByName("btn_yx_close");

        this._btnYYOpen = this.node.getChildByName("yinyue").getChildByName("btn_yy_open");
        this._btnYYClose = this.node.getChildByName("yinyue").getChildByName("btn_yy_close");

        this.initButtonHandler(this.node.getChildByName("btn_close"));
        this.initButtonHandler(this.node.getChildByName("btn_exit"));

        this.initButtonHandler(this._btnYXOpen);
        this.initButtonHandler(this._btnYXClose);
        this.initButtonHandler(this._btnYYOpen);
        this.initButtonHandler(this._btnYYClose);

        var slider = this.node.getChildByName("yinxiao").getChildByName("progress");
        cc.vv.utils.addSlideEvent(slider, this.node, "Settings", "onSlided");

        var slider = this.node.getChildByName("yinyue").getChildByName("progress");
        cc.vv.utils.addSlideEvent(slider, this.node, "Settings", "onSlided");

        this.refreshVolume();
    },

    onSlided: function onSlided(slider) {
        if (slider.node.parent.name == "yinxiao") {
            cc.vv.audioMgr.setSFXVolume(slider.progress);
        } else if (slider.node.parent.name == "yinyue") {
            cc.vv.audioMgr.setBGMVolume(slider.progress);
        }
        this.refreshVolume();
    },

    initButtonHandler: function initButtonHandler(btn) {
        cc.vv.utils.addClickEvent(btn, this.node, "Settings", "onBtnClicked");
    },

    refreshVolume: function refreshVolume() {

        this._btnYXClose.active = cc.vv.audioMgr.sfxVolume > 0;
        this._btnYXOpen.active = !this._btnYXClose.active;

        var yx = this.node.getChildByName("yinxiao");
        var width = 368 * cc.vv.audioMgr.sfxVolume;
        var progress = yx.getChildByName("progress");
        progress.getComponent(cc.Slider).progress = cc.vv.audioMgr.sfxVolume;
        progress.getChildByName("progress").width = width;
        //yx.getChildByName("btn_progress").x = progress.x + width;


        this._btnYYClose.active = cc.vv.audioMgr.bgmVolume > 0;
        this._btnYYOpen.active = !this._btnYYClose.active;
        var yy = this.node.getChildByName("yinyue");
        var width = 368 * cc.vv.audioMgr.bgmVolume;
        var progress = yy.getChildByName("progress");
        progress.getComponent(cc.Slider).progress = cc.vv.audioMgr.bgmVolume;

        progress.getChildByName("progress").width = width;
        //yy.getChildByName("btn_progress").x = progress.x + width;
    },

    onBtnClicked: function onBtnClicked(event) {
        if (event.target.name == "btn_close") {
            this.node.active = false;
        } else if (event.target.name == "btn_exit") {
            cc.sys.localStorage.removeItem("wx_account");
            cc.sys.localStorage.removeItem("wx_sign");
            cc.director.loadScene("login");
        } else if (event.target.name == "btn_yx_open") {
            cc.vv.audioMgr.setSFXVolume(1.0);
            this.refreshVolume();
        } else if (event.target.name == "btn_yx_close") {
            cc.vv.audioMgr.setSFXVolume(0);
            this.refreshVolume();
        } else if (event.target.name == "btn_yy_open") {
            cc.vv.audioMgr.setBGMVolume(1);
            this.refreshVolume();
        } else if (event.target.name == "btn_yy_close") {
            cc.vv.audioMgr.setBGMVolume(0);
            this.refreshVolume();
        }
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"TimePointer":[function(require,module,exports){
"use strict";
cc._RF.push(module, '5b586erPK1H5bFfrMKWs+Y6', 'TimePointer');
// scripts/components/TimePointer.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        _arrow: null,
        _pointer: null,
        _timeLabel: null,
        _time: -1,
        _alertTime: -1
    },

    // use this for initialization
    onLoad: function onLoad() {
        var gameChild = this.node.getChildByName("game");
        this._arrow = gameChild.getChildByName("arrow");
        this._pointer = this._arrow.getChildByName("pointer");
        this.initPointer();

        this._timeLabel = this._arrow.getChildByName("lblTime").getComponent(cc.Label);
        this._timeLabel.string = "00";

        var self = this;

        this.node.on('game_begin', function (data) {
            self.initPointer();
        });

        this.node.on('game_chupai', function (data) {
            self.initPointer();
            self._time = 10;
            self._alertTime = 3;
        });
    },

    initPointer: function initPointer() {

        if (cc.vv == null) {
            return;
        }

        this._arrow.active = cc.vv.gameNetMgr.gamestate == "playing";
        if (!this._arrow.active) {
            return;
        }
        var turn = cc.vv.gameNetMgr.turn;
        var localIndex = cc.vv.gameNetMgr.getLocalIndex(turn);
        for (var i = 0; i < this._pointer.children.length; ++i) {
            this._pointer.children[i].active = i == localIndex;
        }

        //旋转风向
        var button = cc.vv.gameNetMgr.button;
        var seatindex = cc.vv.gameNetMgr.seatIndex;
        var arrow_frame = this._arrow.getChildByName("Z_arrow_frame");
        var dis = seatindex - button;
        arrow_frame.rotation = dis * 90;
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._time > 0) {
            this._time -= dt;
            if (this._alertTime > 0 && this._time < this._alertTime) {
                cc.vv.audioMgr.playSFX("timeup_alarm.mp3");
                this._alertTime = -1;
            }
            var pre = "";
            if (this._time < 0) {
                this._time = 0;
            }

            var t = Math.ceil(this._time);
            if (t < 10) {
                pre = "0";
            }
            this._timeLabel.string = pre + t;
        }
    }
});

cc._RF.pop();
},{}],"UserInfoShow":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'fe4f16CAmpBlZphnpsH1ETv', 'UserInfoShow');
// scripts/components/UserInfoShow.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _userinfo: null
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return;
        }

        this._userinfo = cc.find("Canvas/userinfo");
        this._userinfo.active = false;
        cc.vv.utils.addClickEvent(this._userinfo, this.node, "UserInfoShow", "onClicked");

        cc.vv.userinfoShow = this;
    },

    show: function show(name, userId, iconSprite, sex, ip) {
        if (userId != null && userId > 0) {
            this._userinfo.active = true;
            this._userinfo.getChildByName("icon").getComponent(cc.Sprite).spriteFrame = iconSprite.spriteFrame;
            this._userinfo.getChildByName("name").getComponent(cc.Label).string = name;
            this._userinfo.getChildByName("ip").getComponent(cc.Label).string = "IP: " + ip.replace("::ffff:", "");
            this._userinfo.getChildByName("id").getComponent(cc.Label).string = "ID: " + userId;

            var sex_female = this._userinfo.getChildByName("sex_female");
            sex_female.active = false;

            var sex_male = this._userinfo.getChildByName("sex_male");
            sex_male.active = false;

            if (sex == 1) {
                sex_male.active = true;
            } else if (sex == 2) {
                sex_female.active = true;
            }
        }
    },

    onClicked: function onClicked() {
        this._userinfo.active = false;
    }

    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },
});

cc._RF.pop();
},{}],"UserMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '74d78JBqHdDKY6hckY2YuL+', 'UserMgr');
// scripts/UserMgr.js

"use strict";

cc.Class({
    extends: cc.Component,
    properties: {
        account: null,
        userId: null,
        userName: null,
        lv: 0,
        exp: 0,
        coins: 0,
        gems: 0,
        sign: 0,
        ip: "",
        sex: 0,
        roomData: null,
        oldRoomId: null
    },

    guestAuth: function guestAuth() {
        var account = cc.args["account"];
        if (account == null) {
            account = cc.sys.localStorage.getItem("account");
        }

        if (account == null) {
            account = Date.now();
            cc.sys.localStorage.setItem("account", account);
        }

        cc.vv.http.sendRequest("/guest", { account: account }, this.onAuth);
    },

    onAuth: function onAuth(ret) {
        var self = cc.vv.userMgr;
        if (ret.errcode !== 0) {
            console.log(ret.errmsg);
        } else {
            self.account = ret.account;
            self.sign = ret.sign;
            cc.vv.http.url = "http://" + cc.vv.SI.hall;
            self.login();
        }
    },

    login: function login() {
        var self = this;
        var onLogin = function onLogin(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                if (!ret.userid) {
                    //jump to register user info.
                    cc.director.loadScene("createrole");
                } else {
                    console.log(ret);
                    self.account = ret.account;
                    self.userId = ret.userid;
                    self.userName = ret.name;
                    self.lv = ret.lv;
                    self.exp = ret.exp;
                    self.coins = ret.coins;
                    self.gems = ret.gems;
                    self.roomData = ret.roomid;
                    self.sex = ret.sex;
                    self.ip = ret.ip;
                    cc.director.loadScene("hall");
                }
            }
        };
        cc.vv.wc.show("正在登录游戏");
        cc.vv.http.sendRequest("/login", { account: this.account, sign: this.sign }, onLogin);
    },

    create: function create(name) {
        var self = this;
        var onCreate = function onCreate(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                self.login();
            }
        };

        var data = {
            account: this.account,
            sign: this.sign,
            name: name
        };
        cc.vv.http.sendRequest("/create_user", data, onCreate);
    },

    enterRoom: function enterRoom(roomId, callback) {
        var self = this;
        var onEnter = function onEnter(ret) {
            if (ret.errcode !== 0) {
                if (ret.errcode == -1) {
                    setTimeout(function () {
                        self.enterRoom(roomId, callback);
                    }, 5000);
                } else {
                    cc.vv.wc.hide();
                    if (callback != null) {
                        callback(ret);
                    }
                }
            } else {
                if (callback != null) {
                    callback(ret);
                }
                cc.vv.gameNetMgr.connectGameServer(ret);
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            roomid: roomId
        };
        cc.vv.wc.show("正在进入房间 " + roomId);
        cc.vv.http.sendRequest("/enter_private_room", data, onEnter);
    },
    getHistoryList: function getHistoryList(callback) {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                console.log(ret.history);
                if (callback != null) {
                    callback(ret.history);
                }
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign
        };
        cc.vv.http.sendRequest("/get_history_list", data, onGet);
    },
    getGamesOfRoom: function getGamesOfRoom(uuid, callback) {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                console.log(ret.data);
                callback(ret.data);
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            uuid: uuid
        };
        cc.vv.http.sendRequest("/get_games_of_room", data, onGet);
    },

    getDetailOfGame: function getDetailOfGame(uuid, index, callback) {
        var self = this;
        var onGet = function onGet(ret) {
            if (ret.errcode !== 0) {
                console.log(ret.errmsg);
            } else {
                console.log(ret.data);
                callback(ret.data);
            }
        };

        var data = {
            account: cc.vv.userMgr.account,
            sign: cc.vv.userMgr.sign,
            uuid: uuid,
            index: index
        };
        cc.vv.http.sendRequest("/get_detail_of_game", data, onGet);
    }
});

cc._RF.pop();
},{}],"Utils":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'b717fzww0hNzIqvNbb1t9wx', 'Utils');
// scripts/Utils.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        showAct: true
    },

    addClickEvent: function addClickEvent(node, target, component, handler) {
        console.log(component + ":" + handler);
        var eventHandler = new cc.Component.EventHandler();
        eventHandler.target = target;
        eventHandler.component = component;
        eventHandler.handler = handler;

        var clickEvents = node.getComponent(cc.Button).clickEvents;
        clickEvents.push(eventHandler);
    },

    addSlideEvent: function addSlideEvent(node, target, component, handler) {
        var eventHandler = new cc.Component.EventHandler();
        eventHandler.target = target;
        eventHandler.component = component;
        eventHandler.handler = handler;

        var slideEvents = node.getComponent(cc.Slider).slideEvents;
        slideEvents.push(eventHandler);
    }

});

cc._RF.pop();
},{}],"VoiceMgr":[function(require,module,exports){
"use strict";
cc._RF.push(module, '1f066RbLAxKGJZtkDFO2kq/', 'VoiceMgr');
// scripts/VoiceMgr.js

"use strict";

var radix = 12;
var base = 128 - radix;
function crypto(value) {
    value -= base;
    var h = Math.floor(value / radix) + base;
    var l = value % radix + base;
    return String.fromCharCode(h) + String.fromCharCode(l);
}

var encodermap = {};
var decodermap = {};
for (var i = 0; i < 256; ++i) {
    var code = null;
    var v = i + 1;
    if (v >= base) {
        code = crypto(v);
    } else {
        code = String.fromCharCode(v);
    }

    encodermap[i] = code;
    decodermap[code] = i;
}

function encode(data) {
    var content = "";
    var len = data.length;
    var a = len >> 24 & 0xff;
    var b = len >> 16 & 0xff;
    var c = len >> 8 & 0xff;
    var d = len & 0xff;
    content += encodermap[a];
    content += encodermap[b];
    content += encodermap[c];
    content += encodermap[d];
    for (var i = 0; i < data.length; ++i) {
        content += encodermap[data[i]];
    }
    return content;
}

function getCode(content, index) {
    var c = content.charCodeAt(index);
    if (c >= base) {
        c = content.charAt(index) + content.charAt(index + 1);
    } else {
        c = content.charAt(index);
    }
    return c;
}
function decode(content) {
    var index = 0;
    var len = 0;
    for (var i = 0; i < 4; ++i) {
        var c = getCode(content, index);
        index += c.length;
        var v = decodermap[c];
        len |= v << (3 - i) * 8;
    }

    var newData = new Uint8Array(len);
    var cnt = 0;
    while (index < content.length) {
        var c = getCode(content, index);
        index += c.length;
        newData[cnt] = decodermap[c];
        cnt++;
    }
    return newData;
}

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        onPlayCallback: null,
        _voiceMediaPath: null
    },

    // use this for initialization
    init: function init() {
        /*
        var url = cc.url.raw("resources/test.amr");
        var fileData = jsb.fileUtils.getDataFromFile(url);
        var content = "";
        var sep = "";
        for(var i = 0; i < fileData.length; ++i){
            content += sep + fileData[i];
            sep = ",";
        }
        
        var url = cc.url.raw("resources/test.txt");
        jsb.fileUtils.writeStringToFile(content,url);
        
        var url = cc.url.raw("resources/test2.amrs");
        var content = encode(fileData);
        jsb.fileUtils.writeStringToFile(content,url);
        
        var url = cc.url.raw("resources/test2.amr");
        jsb.fileUtils.writeDataToFile(decode(content),url);
        */

        if (cc.sys.isNative) {
            this._voiceMediaPath = jsb.fileUtils.getWritablePath() + "/voicemsgs/";
            this.setStorageDir(this._voiceMediaPath);
        }
    },

    prepare: function prepare(filename) {
        if (!cc.sys.isNative) {
            return;
        }
        cc.vv.audioMgr.pauseAll();
        this.clearCache(filename);
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoiceRecorder", "prepare", "(Ljava/lang/String;)V", filename);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "prepareRecord:", filename);
        }
    },

    release: function release() {
        if (!cc.sys.isNative) {
            return;
        }
        cc.vv.audioMgr.resumeAll();
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoiceRecorder", "release", "()V");
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "finishRecord");
        }
    },

    cancel: function cancel() {
        if (!cc.sys.isNative) {
            return;
        }
        cc.vv.audioMgr.resumeAll();
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoiceRecorder", "cancel", "()V");
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "cancelRecord");
        }
    },

    writeVoice: function writeVoice(filename, voiceData) {
        if (!cc.sys.isNative) {
            return;
        }
        if (voiceData && voiceData.length > 0) {
            var fileData = decode(voiceData);
            var url = this._voiceMediaPath + filename;
            this.clearCache(filename);
            jsb.fileUtils.writeDataToFile(fileData, url);
        }
    },

    clearCache: function clearCache(filename) {
        if (cc.sys.isNative) {
            var url = this._voiceMediaPath + filename;
            //console.log("check file:" + url);
            if (jsb.fileUtils.isFileExist(url)) {
                //console.log("remove:" + url);
                jsb.fileUtils.removeFile(url);
            }
            if (jsb.fileUtils.isFileExist(url + ".wav")) {
                //console.log("remove:" + url + ".wav");
                jsb.fileUtils.removeFile(url + ".wav");
            }
        }
    },

    play: function play(filename) {
        if (!cc.sys.isNative) {
            return;
        }
        cc.vv.audioMgr.pauseAll();
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoicePlayer", "play", "(Ljava/lang/String;)V", filename);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "play:", filename);
        } else {}
    },

    stop: function stop() {
        if (!cc.sys.isNative) {
            return;
        }
        cc.vv.audioMgr.resumeAll();
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoicePlayer", "stop", "()V");
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "stopPlay");
        } else {}
    },

    getVoiceLevel: function getVoiceLevel(maxLevel) {
        return Math.floor(Math.random() * maxLevel + 1);
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            return jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoiceRecorder", "getVoiceLevel", "(I)I", maxLevel);
        } else if (cc.sys.os == cc.sys.OS_IOS) {} else {
            return Math.floor(Math.random() * maxLevel + 1);
        }
    },

    getVoiceData: function getVoiceData(filename) {
        if (cc.sys.isNative) {
            var url = this._voiceMediaPath + filename;
            console.log("getVoiceData:" + url);
            var fileData = jsb.fileUtils.getDataFromFile(url);
            if (fileData) {
                var content = encode(fileData);
                return content;
            }
        }
        return "";
    },

    download: function download() {},
    // called every frame, uncomment this function to activate update callback
    // update: function (dt) {

    // },

    setStorageDir: function setStorageDir(dir) {
        if (!cc.sys.isNative) {
            return;
        }
        if (cc.sys.os == cc.sys.OS_ANDROID) {
            jsb.reflection.callStaticMethod("com/vivigames/voicesdk/VoiceRecorder", "setStorageDir", "(Ljava/lang/String;)V", dir);
        } else if (cc.sys.os == cc.sys.OS_IOS) {
            jsb.reflection.callStaticMethod("VoiceSDK", "setStorageDir:", dir);
            if (!jsb.fileUtils.isDirectoryExist(dir)) {
                jsb.fileUtils.createDirectory(dir);
            }
        }
    }
});

cc._RF.pop();
},{}],"Voice":[function(require,module,exports){
"use strict";
cc._RF.push(module, 'f6db9z0CxdEzpRVgU569dDu', 'Voice');
// scripts/components/Voice.js

"use strict";

cc.Class({
    extends: cc.Component,

    properties: {
        // foo: {
        //    default: null,      // The default value will be used only when the component attaching
        //                           to a node for the first time
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _lastTouchTime: null,
        _voice: null,
        _volume: null,
        _voice_failed: null,
        _lastCheckTime: -1,
        _timeBar: null,
        MAX_TIME: 15000
    },

    // use this for initialization
    onLoad: function onLoad() {

        this._voice = cc.find("Canvas/voice");
        this._voice.active = false;

        this._voice_failed = cc.find("Canvas/voice/voice_failed");
        this._voice_failed.active = false;

        this._timeBar = cc.find("Canvas/voice/time");
        this._timeBar.scaleX = 0.0;

        this._volume = cc.find("Canvas/voice/volume");
        for (var i = 1; i < this._volume.children.length; ++i) {
            this._volume.children[i].active = false;
        }

        var btnVoice = cc.find("Canvas/voice/voice_failed/btn_ok");
        if (btnVoice) {
            cc.vv.utils.addClickEvent(btnVoice, this.node, "Voice", "onBtnOKClicked");
        }

        var self = this;
        var btnVoice = cc.find("Canvas/btn_voice");
        if (btnVoice) {
            btnVoice.on(cc.Node.EventType.TOUCH_START, function () {
                console.log("cc.Node.EventType.TOUCH_START");
                cc.vv.voiceMgr.prepare("record.amr");
                self._lastTouchTime = Date.now();
                self._voice.active = true;
                self._voice_failed.active = false;
            });

            btnVoice.on(cc.Node.EventType.TOUCH_MOVE, function () {
                console.log("cc.Node.EventType.TOUCH_MOVE");
            });

            btnVoice.on(cc.Node.EventType.TOUCH_END, function () {
                console.log("cc.Node.EventType.TOUCH_END");
                if (Date.now() - self._lastTouchTime < 1000) {
                    self._voice_failed.active = true;
                    cc.vv.voiceMgr.cancel();
                } else {
                    self.onVoiceOK();
                }
                self._lastTouchTime = null;
            });

            btnVoice.on(cc.Node.EventType.TOUCH_CANCEL, function () {
                console.log("cc.Node.EventType.TOUCH_CANCEL");
                cc.vv.voiceMgr.cancel();
                self._lastTouchTime = null;
                self._voice.active = false;
            });
        }
    },

    onVoiceOK: function onVoiceOK() {
        if (this._lastTouchTime != null) {
            cc.vv.voiceMgr.release();
            var time = Date.now() - this._lastTouchTime;
            var msg = cc.vv.voiceMgr.getVoiceData("record.amr");
            cc.vv.net.send("voice_msg", { msg: msg, time: time });
        }
        this._voice.active = false;
    },

    onBtnOKClicked: function onBtnOKClicked() {
        this._voice.active = false;
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        if (this._voice.active == true && this._voice_failed.active == false) {
            if (Date.now() - this._lastCheckTime > 300) {
                for (var i = 0; i < this._volume.children.length; ++i) {
                    this._volume.children[i].active = false;
                }
                var v = cc.vv.voiceMgr.getVoiceLevel(7);
                if (v >= 1 && v <= 7) {
                    this._volume.children[v - 1].active = true;
                }
                this._lastCheckTime = Date.now();
            }
        }

        if (this._lastTouchTime) {
            var time = Date.now() - this._lastTouchTime;
            if (time >= this.MAX_TIME) {
                this.onVoiceOK();
                this._lastTouchTime = null;
            } else {
                var percent = time / this.MAX_TIME;
                this._timeBar.scaleX = 1 - percent;
            }
        }
    }
});

cc._RF.pop();
},{}],"WaitingConnection":[function(require,module,exports){
"use strict";
cc._RF.push(module, '10e32jDstpLhIGHWrQEq2vN', 'WaitingConnection');
// scripts/components/WaitingConnection.js

"use strict";

cc.Class({
    extends: cc.Component,
    properties: {
        target: cc.Node,
        // foo: {
        //    default: null,
        //    url: cc.Texture2D,  // optional, default is typeof default
        //    serializable: true, // optional, default is true
        //    visible: true,      // optional, default is true
        //    displayName: 'Foo', // optional
        //    readonly: false,    // optional, default is false
        // },
        // ...
        _isShow: false,
        lblContent: cc.Label
    },

    // use this for initialization
    onLoad: function onLoad() {
        if (cc.vv == null) {
            return null;
        }

        cc.vv.wc = this;
        this.node.active = this._isShow;
    },

    // called every frame, uncomment this function to activate update callback
    update: function update(dt) {
        this.target.rotation = this.target.rotation - dt * 45;
    },

    show: function show(content) {
        this._isShow = true;
        if (this.node) {
            this.node.active = this._isShow;
        }
        if (this.lblContent) {
            if (content == null) {
                content = "";
            }
            this.lblContent.string = content;
        }
    },
    hide: function hide() {
        this._isShow = false;
        if (this.node) {
            this.node.active = this._isShow;
        }
    }
});

cc._RF.pop();
},{}],"socket-io":[function(require,module,exports){
(function (global){
"use strict";
cc._RF.push(module, '393290vPc1IIYfh8FrmxcNZ', 'socket-io');
// scripts/3rdparty/socket-io.js

"use strict";

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (!CC_JSB && !cc.sys.isNative) {
	(function (f) {
		if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
			module.exports = f();
		} else if (typeof define === "function" && define.amd) {
			define([], f);
		} else {
			var g;if (typeof window !== "undefined") {
				g = window;
			} else if (typeof global !== "undefined") {
				g = global;
			} else if (typeof self !== "undefined") {
				g = self;
			} else {
				g = this;
			}g.io = f();
		}
	})(function () {
		var define, module, exports;return function e(t, n, r) {
			function s(o, u) {
				if (!n[o]) {
					if (!t[o]) {
						var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
					}var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
						var n = t[o][1][e];return s(n ? n : e);
					}, l, l.exports, e, t, n, r);
				}return n[o].exports;
			}var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) {
				s(r[o]);
			}return s;
		}({ 1: [function (_dereq_, module, exports) {

				module.exports = _dereq_('./lib/');
			}, { "./lib/": 2 }], 2: [function (_dereq_, module, exports) {

				module.exports = _dereq_('./socket');

				/**
     * Exports parser
     *
     * @api public
     *
     */
				module.exports.parser = _dereq_('engine.io-parser');
			}, { "./socket": 3, "engine.io-parser": 19 }], 3: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Module dependencies.
      */

					var transports = _dereq_('./transports');
					var Emitter = _dereq_('component-emitter');
					var debug = _dereq_('debug')('engine.io-client:socket');
					var index = _dereq_('indexof');
					var parser = _dereq_('engine.io-parser');
					var parseuri = _dereq_('parseuri');
					var parsejson = _dereq_('parsejson');
					var parseqs = _dereq_('parseqs');

					/**
      * Module exports.
      */

					module.exports = Socket;

					/**
      * Noop function.
      *
      * @api private
      */

					function noop() {}

					/**
      * Socket constructor.
      *
      * @param {String|Object} uri or options
      * @param {Object} options
      * @api public
      */

					function Socket(uri, opts) {
						if (!(this instanceof Socket)) return new Socket(uri, opts);

						opts = opts || {};

						if (uri && 'object' == (typeof uri === "undefined" ? "undefined" : _typeof(uri))) {
							opts = uri;
							uri = null;
						}

						if (uri) {
							uri = parseuri(uri);
							opts.hostname = uri.host;
							opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
							opts.port = uri.port;
							if (uri.query) opts.query = uri.query;
						} else if (opts.host) {
							opts.hostname = parseuri(opts.host).host;
						}

						this.secure = null != opts.secure ? opts.secure : global.location && 'https:' == location.protocol;

						if (opts.hostname && !opts.port) {
							// if no port is specified manually, use the protocol default
							opts.port = this.secure ? '443' : '80';
						}

						this.agent = opts.agent || false;
						this.hostname = opts.hostname || (global.location ? location.hostname : 'localhost');
						this.port = opts.port || (global.location && location.port ? location.port : this.secure ? 443 : 80);
						this.query = opts.query || {};
						if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
						this.upgrade = false !== opts.upgrade;
						this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
						this.forceJSONP = !!opts.forceJSONP;
						this.jsonp = false !== opts.jsonp;
						this.forceBase64 = !!opts.forceBase64;
						this.enablesXDR = !!opts.enablesXDR;
						this.timestampParam = opts.timestampParam || 't';
						this.timestampRequests = opts.timestampRequests;
						this.transports = opts.transports || ['polling', 'websocket'];
						this.readyState = '';
						this.writeBuffer = [];
						this.policyPort = opts.policyPort || 843;
						this.rememberUpgrade = opts.rememberUpgrade || false;
						this.binaryType = null;
						this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
						this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;

						if (true === this.perMessageDeflate) this.perMessageDeflate = {};
						if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
							this.perMessageDeflate.threshold = 1024;
						}

						// SSL options for Node.js client
						this.pfx = opts.pfx || null;
						this.key = opts.key || null;
						this.passphrase = opts.passphrase || null;
						this.cert = opts.cert || null;
						this.ca = opts.ca || null;
						this.ciphers = opts.ciphers || null;
						this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;

						// other options for Node.js client
						var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global;
						if (freeGlobal.global === freeGlobal) {
							if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
								this.extraHeaders = opts.extraHeaders;
							}
						}

						this.open();
					}

					Socket.priorWebsocketSuccess = false;

					/**
      * Mix in `Emitter`.
      */

					Emitter(Socket.prototype);

					/**
      * Protocol version.
      *
      * @api public
      */

					Socket.protocol = parser.protocol; // this is an int

					/**
      * Expose deps for legacy compatibility
      * and standalone browser access.
      */

					Socket.Socket = Socket;
					Socket.Transport = _dereq_('./transport');
					Socket.transports = _dereq_('./transports');
					Socket.parser = _dereq_('engine.io-parser');

					/**
      * Creates transport of the given type.
      *
      * @param {String} transport name
      * @return {Transport}
      * @api private
      */

					Socket.prototype.createTransport = function (name) {
						debug('creating transport "%s"', name);
						var query = clone(this.query);

						// append engine.io protocol identifier
						query.EIO = parser.protocol;

						// transport name
						query.transport = name;

						// session id if we already have one
						if (this.id) query.sid = this.id;

						var transport = new transports[name]({
							agent: this.agent,
							hostname: this.hostname,
							port: this.port,
							secure: this.secure,
							path: this.path,
							query: query,
							forceJSONP: this.forceJSONP,
							jsonp: this.jsonp,
							forceBase64: this.forceBase64,
							enablesXDR: this.enablesXDR,
							timestampRequests: this.timestampRequests,
							timestampParam: this.timestampParam,
							policyPort: this.policyPort,
							socket: this,
							pfx: this.pfx,
							key: this.key,
							passphrase: this.passphrase,
							cert: this.cert,
							ca: this.ca,
							ciphers: this.ciphers,
							rejectUnauthorized: this.rejectUnauthorized,
							perMessageDeflate: this.perMessageDeflate,
							extraHeaders: this.extraHeaders
						});

						return transport;
					};

					function clone(obj) {
						var o = {};
						for (var i in obj) {
							if (obj.hasOwnProperty(i)) {
								o[i] = obj[i];
							}
						}
						return o;
					}

					/**
      * Initializes transport to use and starts probe.
      *
      * @api private
      */
					Socket.prototype.open = function () {
						var transport;
						if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
							transport = 'websocket';
						} else if (0 === this.transports.length) {
							// Emit error on next tick so it can be listened to
							var self = this;
							setTimeout(function () {
								self.emit('error', 'No transports available');
							}, 0);
							return;
						} else {
							transport = this.transports[0];
						}
						this.readyState = 'opening';

						// Retry with the next transport if the transport is disabled (jsonp: false)
						try {
							transport = this.createTransport(transport);
						} catch (e) {
							this.transports.shift();
							this.open();
							return;
						}

						transport.open();
						this.setTransport(transport);
					};

					/**
      * Sets the current transport. Disables the existing one (if any).
      *
      * @api private
      */

					Socket.prototype.setTransport = function (transport) {
						debug('setting transport %s', transport.name);
						var self = this;

						if (this.transport) {
							debug('clearing existing transport %s', this.transport.name);
							this.transport.removeAllListeners();
						}

						// set up transport
						this.transport = transport;

						// set up transport listeners
						transport.on('drain', function () {
							self.onDrain();
						}).on('packet', function (packet) {
							self.onPacket(packet);
						}).on('error', function (e) {
							self.onError(e);
						}).on('close', function () {
							self.onClose('transport close');
						});
					};

					/**
      * Probes a transport.
      *
      * @param {String} transport name
      * @api private
      */

					Socket.prototype.probe = function (name) {
						debug('probing transport "%s"', name);
						var transport = this.createTransport(name, { probe: 1 }),
						    failed = false,
						    self = this;

						Socket.priorWebsocketSuccess = false;

						function onTransportOpen() {
							if (self.onlyBinaryUpgrades) {
								var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
								failed = failed || upgradeLosesBinary;
							}
							if (failed) return;

							debug('probe transport "%s" opened', name);
							transport.send([{ type: 'ping', data: 'probe' }]);
							transport.once('packet', function (msg) {
								if (failed) return;
								if ('pong' == msg.type && 'probe' == msg.data) {
									debug('probe transport "%s" pong', name);
									self.upgrading = true;
									self.emit('upgrading', transport);
									if (!transport) return;
									Socket.priorWebsocketSuccess = 'websocket' == transport.name;

									debug('pausing current transport "%s"', self.transport.name);
									self.transport.pause(function () {
										if (failed) return;
										if ('closed' == self.readyState) return;
										debug('changing transport and sending upgrade packet');

										cleanup();

										self.setTransport(transport);
										transport.send([{ type: 'upgrade' }]);
										self.emit('upgrade', transport);
										transport = null;
										self.upgrading = false;
										self.flush();
									});
								} else {
									debug('probe transport "%s" failed', name);
									var err = new Error('probe error');
									err.transport = transport.name;
									self.emit('upgradeError', err);
								}
							});
						}

						function freezeTransport() {
							if (failed) return;

							// Any callback called by transport should be ignored since now
							failed = true;

							cleanup();

							transport.close();
							transport = null;
						}

						//Handle any error that happens while probing
						function onerror(err) {
							var error = new Error('probe error: ' + err);
							error.transport = transport.name;

							freezeTransport();

							debug('probe transport "%s" failed because of error: %s', name, err);

							self.emit('upgradeError', error);
						}

						function onTransportClose() {
							onerror("transport closed");
						}

						//When the socket is closed while we're probing
						function onclose() {
							onerror("socket closed");
						}

						//When the socket is upgraded while we're probing
						function onupgrade(to) {
							if (transport && to.name != transport.name) {
								debug('"%s" works - aborting "%s"', to.name, transport.name);
								freezeTransport();
							}
						}

						//Remove all listeners on the transport and on self
						function cleanup() {
							transport.removeListener('open', onTransportOpen);
							transport.removeListener('error', onerror);
							transport.removeListener('close', onTransportClose);
							self.removeListener('close', onclose);
							self.removeListener('upgrading', onupgrade);
						}

						transport.once('open', onTransportOpen);
						transport.once('error', onerror);
						transport.once('close', onTransportClose);

						this.once('close', onclose);
						this.once('upgrading', onupgrade);

						transport.open();
					};

					/**
      * Called when connection is deemed open.
      *
      * @api public
      */

					Socket.prototype.onOpen = function () {
						debug('socket open');
						this.readyState = 'open';
						Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
						this.emit('open');
						this.flush();

						// we check for `readyState` in case an `open`
						// listener already closed the socket
						if ('open' == this.readyState && this.upgrade && this.transport.pause) {
							debug('starting upgrade probes');
							for (var i = 0, l = this.upgrades.length; i < l; i++) {
								this.probe(this.upgrades[i]);
							}
						}
					};

					/**
      * Handles a packet.
      *
      * @api private
      */

					Socket.prototype.onPacket = function (packet) {
						if ('opening' == this.readyState || 'open' == this.readyState) {
							debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

							this.emit('packet', packet);

							// Socket is live - any packet counts
							this.emit('heartbeat');

							switch (packet.type) {
								case 'open':
									this.onHandshake(parsejson(packet.data));
									break;

								case 'pong':
									this.setPing();
									this.emit('pong');
									break;

								case 'error':
									var err = new Error('server error');
									err.code = packet.data;
									this.onError(err);
									break;

								case 'message':
									this.emit('data', packet.data);
									this.emit('message', packet.data);
									break;
							}
						} else {
							debug('packet received with socket readyState "%s"', this.readyState);
						}
					};

					/**
      * Called upon handshake completion.
      *
      * @param {Object} handshake obj
      * @api private
      */

					Socket.prototype.onHandshake = function (data) {
						this.emit('handshake', data);
						this.id = data.sid;
						this.transport.query.sid = data.sid;
						this.upgrades = this.filterUpgrades(data.upgrades);
						this.pingInterval = data.pingInterval;
						this.pingTimeout = data.pingTimeout;
						this.onOpen();
						// In case open handler closes socket
						if ('closed' == this.readyState) return;
						this.setPing();

						// Prolong liveness of socket on heartbeat
						this.removeListener('heartbeat', this.onHeartbeat);
						this.on('heartbeat', this.onHeartbeat);
					};

					/**
      * Resets ping timeout.
      *
      * @api private
      */

					Socket.prototype.onHeartbeat = function (timeout) {
						clearTimeout(this.pingTimeoutTimer);
						var self = this;
						self.pingTimeoutTimer = setTimeout(function () {
							if ('closed' == self.readyState) return;
							self.onClose('ping timeout');
						}, timeout || self.pingInterval + self.pingTimeout);
					};

					/**
      * Pings server every `this.pingInterval` and expects response
      * within `this.pingTimeout` or closes connection.
      *
      * @api private
      */

					Socket.prototype.setPing = function () {
						var self = this;
						clearTimeout(self.pingIntervalTimer);
						self.pingIntervalTimer = setTimeout(function () {
							debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
							self.ping();
							self.onHeartbeat(self.pingTimeout);
						}, self.pingInterval);
					};

					/**
     * Sends a ping packet.
     *
     * @api private
     */

					Socket.prototype.ping = function () {
						var self = this;
						this.sendPacket('ping', function () {
							self.emit('ping');
						});
					};

					/**
      * Called on `drain` event
      *
      * @api private
      */

					Socket.prototype.onDrain = function () {
						this.writeBuffer.splice(0, this.prevBufferLen);

						// setting prevBufferLen = 0 is very important
						// for example, when upgrading, upgrade packet is sent over,
						// and a nonzero prevBufferLen could cause problems on `drain`
						this.prevBufferLen = 0;

						if (0 === this.writeBuffer.length) {
							this.emit('drain');
						} else {
							this.flush();
						}
					};

					/**
      * Flush write buffers.
      *
      * @api private
      */

					Socket.prototype.flush = function () {
						if ('closed' != this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
							debug('flushing %d packets in socket', this.writeBuffer.length);
							this.transport.send(this.writeBuffer);
							// keep track of current length of writeBuffer
							// splice writeBuffer and callbackBuffer on `drain`
							this.prevBufferLen = this.writeBuffer.length;
							this.emit('flush');
						}
					};

					/**
      * Sends a message.
      *
      * @param {String} message.
      * @param {Function} callback function.
      * @param {Object} options.
      * @return {Socket} for chaining.
      * @api public
      */

					Socket.prototype.write = Socket.prototype.send = function (msg, options, fn) {
						this.sendPacket('message', msg, options, fn);
						return this;
					};

					/**
      * Sends a packet.
      *
      * @param {String} packet type.
      * @param {String} data.
      * @param {Object} options.
      * @param {Function} callback function.
      * @api private
      */

					Socket.prototype.sendPacket = function (type, data, options, fn) {
						if ('function' == typeof data) {
							fn = data;
							data = undefined;
						}

						if ('function' == typeof options) {
							fn = options;
							options = null;
						}

						if ('closing' == this.readyState || 'closed' == this.readyState) {
							return;
						}

						options = options || {};
						options.compress = false !== options.compress;

						var packet = {
							type: type,
							data: data,
							options: options
						};
						this.emit('packetCreate', packet);
						this.writeBuffer.push(packet);
						if (fn) this.once('flush', fn);
						this.flush();
					};

					/**
      * Closes the connection.
      *
      * @api private
      */

					Socket.prototype.close = function () {
						if ('opening' == this.readyState || 'open' == this.readyState) {
							this.readyState = 'closing';

							var self = this;

							if (this.writeBuffer.length) {
								this.once('drain', function () {
									if (this.upgrading) {
										waitForUpgrade();
									} else {
										close();
									}
								});
							} else if (this.upgrading) {
								waitForUpgrade();
							} else {
								close();
							}
						}

						function close() {
							self.onClose('forced close');
							debug('socket closing - telling transport to close');
							self.transport.close();
						}

						function cleanupAndClose() {
							self.removeListener('upgrade', cleanupAndClose);
							self.removeListener('upgradeError', cleanupAndClose);
							close();
						}

						function waitForUpgrade() {
							// wait for upgrade to finish since we can't send packets while pausing a transport
							self.once('upgrade', cleanupAndClose);
							self.once('upgradeError', cleanupAndClose);
						}

						return this;
					};

					/**
      * Called upon transport error
      *
      * @api private
      */

					Socket.prototype.onError = function (err) {
						debug('socket error %j', err);
						Socket.priorWebsocketSuccess = false;
						this.emit('error', err);
						this.onClose('transport error', err);
					};

					/**
      * Called upon transport close.
      *
      * @api private
      */

					Socket.prototype.onClose = function (reason, desc) {
						if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
							debug('socket close with reason: "%s"', reason);
							var self = this;

							// clear timers
							clearTimeout(this.pingIntervalTimer);
							clearTimeout(this.pingTimeoutTimer);

							// stop event from firing again for transport
							this.transport.removeAllListeners('close');

							// ensure transport won't stay open
							this.transport.close();

							// ignore further transport communication
							this.transport.removeAllListeners();

							// set ready state
							this.readyState = 'closed';

							// clear session id
							this.id = null;

							// emit close event
							this.emit('close', reason, desc);

							// clean buffers after, so users can still
							// grab the buffers on `close` event
							self.writeBuffer = [];
							self.prevBufferLen = 0;
						}
					};

					/**
      * Filters upgrades, returning only those matching client transports.
      *
      * @param {Array} server upgrades
      * @api private
      *
      */

					Socket.prototype.filterUpgrades = function (upgrades) {
						var filteredUpgrades = [];
						for (var i = 0, j = upgrades.length; i < j; i++) {
							if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
						}
						return filteredUpgrades;
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./transport": 4, "./transports": 5, "component-emitter": 15, "debug": 17, "engine.io-parser": 19, "indexof": 23, "parsejson": 26, "parseqs": 27, "parseuri": 28 }], 4: [function (_dereq_, module, exports) {
				/**
     * Module dependencies.
     */

				var parser = _dereq_('engine.io-parser');
				var Emitter = _dereq_('component-emitter');

				/**
     * Module exports.
     */

				module.exports = Transport;

				/**
     * Transport abstract constructor.
     *
     * @param {Object} options.
     * @api private
     */

				function Transport(opts) {
					this.path = opts.path;
					this.hostname = opts.hostname;
					this.port = opts.port;
					this.secure = opts.secure;
					this.query = opts.query;
					this.timestampParam = opts.timestampParam;
					this.timestampRequests = opts.timestampRequests;
					this.readyState = '';
					this.agent = opts.agent || false;
					this.socket = opts.socket;
					this.enablesXDR = opts.enablesXDR;

					// SSL options for Node.js client
					this.pfx = opts.pfx;
					this.key = opts.key;
					this.passphrase = opts.passphrase;
					this.cert = opts.cert;
					this.ca = opts.ca;
					this.ciphers = opts.ciphers;
					this.rejectUnauthorized = opts.rejectUnauthorized;

					// other options for Node.js client
					this.extraHeaders = opts.extraHeaders;
				}

				/**
     * Mix in `Emitter`.
     */

				Emitter(Transport.prototype);

				/**
     * Emits an error.
     *
     * @param {String} str
     * @return {Transport} for chaining
     * @api public
     */

				Transport.prototype.onError = function (msg, desc) {
					var err = new Error(msg);
					err.type = 'TransportError';
					err.description = desc;
					this.emit('error', err);
					return this;
				};

				/**
     * Opens the transport.
     *
     * @api public
     */

				Transport.prototype.open = function () {
					if ('closed' == this.readyState || '' == this.readyState) {
						this.readyState = 'opening';
						this.doOpen();
					}

					return this;
				};

				/**
     * Closes the transport.
     *
     * @api private
     */

				Transport.prototype.close = function () {
					if ('opening' == this.readyState || 'open' == this.readyState) {
						this.doClose();
						this.onClose();
					}

					return this;
				};

				/**
     * Sends multiple packets.
     *
     * @param {Array} packets
     * @api private
     */

				Transport.prototype.send = function (packets) {
					if ('open' == this.readyState) {
						this.write(packets);
					} else {
						throw new Error('Transport not open');
					}
				};

				/**
     * Called upon open
     *
     * @api private
     */

				Transport.prototype.onOpen = function () {
					this.readyState = 'open';
					this.writable = true;
					this.emit('open');
				};

				/**
     * Called with data.
     *
     * @param {String} data
     * @api private
     */

				Transport.prototype.onData = function (data) {
					var packet = parser.decodePacket(data, this.socket.binaryType);
					this.onPacket(packet);
				};

				/**
     * Called with a decoded packet.
     */

				Transport.prototype.onPacket = function (packet) {
					this.emit('packet', packet);
				};

				/**
     * Called upon close.
     *
     * @api private
     */

				Transport.prototype.onClose = function () {
					this.readyState = 'closed';
					this.emit('close');
				};
			}, { "component-emitter": 15, "engine.io-parser": 19 }], 5: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Module dependencies
      */

					var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
					var XHR = _dereq_('./polling-xhr');
					var JSONP = _dereq_('./polling-jsonp');
					var websocket = _dereq_('./websocket');

					/**
      * Export transports.
      */

					exports.polling = polling;
					exports.websocket = websocket;

					/**
      * Polling transport polymorphic constructor.
      * Decides on xhr vs jsonp based on feature detection.
      *
      * @api private
      */

					function polling(opts) {
						var xhr;
						var xd = false;
						var xs = false;
						var jsonp = false !== opts.jsonp;

						if (global.location) {
							var isSSL = 'https:' == location.protocol;
							var port = location.port;

							// some user agents have empty `location.port`
							if (!port) {
								port = isSSL ? 443 : 80;
							}

							xd = opts.hostname != location.hostname || port != opts.port;
							xs = opts.secure != isSSL;
						}

						opts.xdomain = xd;
						opts.xscheme = xs;
						xhr = new XMLHttpRequest(opts);

						if ('open' in xhr && !opts.forceJSONP) {
							return new XHR(opts);
						} else {
							if (!jsonp) throw new Error('JSONP disabled');
							return new JSONP(opts);
						}
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./polling-jsonp": 6, "./polling-xhr": 7, "./websocket": 9, "xmlhttprequest-ssl": 10 }], 6: [function (_dereq_, module, exports) {
				(function (global) {

					/**
      * Module requirements.
      */

					var Polling = _dereq_('./polling');
					var inherit = _dereq_('component-inherit');

					/**
      * Module exports.
      */

					module.exports = JSONPPolling;

					/**
      * Cached regular expressions.
      */

					var rNewline = /\n/g;
					var rEscapedNewline = /\\n/g;

					/**
      * Global JSONP callbacks.
      */

					var callbacks;

					/**
      * Callbacks count.
      */

					var index = 0;

					/**
      * Noop.
      */

					function empty() {}

					/**
      * JSONP Polling constructor.
      *
      * @param {Object} opts.
      * @api public
      */

					function JSONPPolling(opts) {
						Polling.call(this, opts);

						this.query = this.query || {};

						// define global callbacks array if not present
						// we do this here (lazily) to avoid unneeded global pollution
						if (!callbacks) {
							// we need to consider multiple engines in the same page
							if (!global.___eio) global.___eio = [];
							callbacks = global.___eio;
						}

						// callback identifier
						this.index = callbacks.length;

						// add callback to jsonp global
						var self = this;
						callbacks.push(function (msg) {
							self.onData(msg);
						});

						// append to query string
						this.query.j = this.index;

						// prevent spurious errors from being emitted when the window is unloaded
						if (global.document && global.addEventListener) {
							global.addEventListener('beforeunload', function () {
								if (self.script) self.script.onerror = empty;
							}, false);
						}
					}

					/**
      * Inherits from Polling.
      */

					inherit(JSONPPolling, Polling);

					/*
      * JSONP only supports binary as base64 encoded strings
      */

					JSONPPolling.prototype.supportsBinary = false;

					/**
      * Closes the socket.
      *
      * @api private
      */

					JSONPPolling.prototype.doClose = function () {
						if (this.script) {
							this.script.parentNode.removeChild(this.script);
							this.script = null;
						}

						if (this.form) {
							this.form.parentNode.removeChild(this.form);
							this.form = null;
							this.iframe = null;
						}

						Polling.prototype.doClose.call(this);
					};

					/**
      * Starts a poll cycle.
      *
      * @api private
      */

					JSONPPolling.prototype.doPoll = function () {
						var self = this;
						var script = document.createElement('script');

						if (this.script) {
							this.script.parentNode.removeChild(this.script);
							this.script = null;
						}

						script.async = true;
						script.src = this.uri();
						script.onerror = function (e) {
							self.onError('jsonp poll error', e);
						};

						var insertAt = document.getElementsByTagName('script')[0];
						if (insertAt) {
							insertAt.parentNode.insertBefore(script, insertAt);
						} else {
							(document.head || document.body).appendChild(script);
						}
						this.script = script;

						var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);

						if (isUAgecko) {
							setTimeout(function () {
								var iframe = document.createElement('iframe');
								document.body.appendChild(iframe);
								document.body.removeChild(iframe);
							}, 100);
						}
					};

					/**
      * Writes with a hidden iframe.
      *
      * @param {String} data to send
      * @param {Function} called upon flush.
      * @api private
      */

					JSONPPolling.prototype.doWrite = function (data, fn) {
						var self = this;

						if (!this.form) {
							var form = document.createElement('form');
							var area = document.createElement('textarea');
							var id = this.iframeId = 'eio_iframe_' + this.index;
							var iframe;

							form.className = 'socketio';
							form.style.position = 'absolute';
							form.style.top = '-1000px';
							form.style.left = '-1000px';
							form.target = id;
							form.method = 'POST';
							form.setAttribute('accept-charset', 'utf-8');
							area.name = 'd';
							form.appendChild(area);
							document.body.appendChild(form);

							this.form = form;
							this.area = area;
						}

						this.form.action = this.uri();

						function complete() {
							initIframe();
							fn();
						}

						function initIframe() {
							if (self.iframe) {
								try {
									self.form.removeChild(self.iframe);
								} catch (e) {
									self.onError('jsonp polling iframe removal error', e);
								}
							}

							try {
								// ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
								var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
								iframe = document.createElement(html);
							} catch (e) {
								iframe = document.createElement('iframe');
								iframe.name = self.iframeId;
								iframe.src = 'javascript:0';
							}

							iframe.id = self.iframeId;

							self.form.appendChild(iframe);
							self.iframe = iframe;
						}

						initIframe();

						// escape \n to prevent it from being converted into \r\n by some UAs
						// double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
						data = data.replace(rEscapedNewline, '\\\n');
						this.area.value = data.replace(rNewline, '\\n');

						try {
							this.form.submit();
						} catch (e) {}

						if (this.iframe.attachEvent) {
							this.iframe.onreadystatechange = function () {
								if (self.iframe.readyState == 'complete') {
									complete();
								}
							};
						} else {
							this.iframe.onload = complete;
						}
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./polling": 8, "component-inherit": 16 }], 7: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Module requirements.
      */

					var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
					var Polling = _dereq_('./polling');
					var Emitter = _dereq_('component-emitter');
					var inherit = _dereq_('component-inherit');
					var debug = _dereq_('debug')('engine.io-client:polling-xhr');

					/**
      * Module exports.
      */

					module.exports = XHR;
					module.exports.Request = Request;

					/**
      * Empty function
      */

					function empty() {}

					/**
      * XHR Polling constructor.
      *
      * @param {Object} opts
      * @api public
      */

					function XHR(opts) {
						Polling.call(this, opts);

						if (global.location) {
							var isSSL = 'https:' == location.protocol;
							var port = location.port;

							// some user agents have empty `location.port`
							if (!port) {
								port = isSSL ? 443 : 80;
							}

							this.xd = opts.hostname != global.location.hostname || port != opts.port;
							this.xs = opts.secure != isSSL;
						} else {
							this.extraHeaders = opts.extraHeaders;
						}
					}

					/**
      * Inherits from Polling.
      */

					inherit(XHR, Polling);

					/**
      * XHR supports binary
      */

					XHR.prototype.supportsBinary = true;

					/**
      * Creates a request.
      *
      * @param {String} method
      * @api private
      */

					XHR.prototype.request = function (opts) {
						opts = opts || {};
						opts.uri = this.uri();
						opts.xd = this.xd;
						opts.xs = this.xs;
						opts.agent = this.agent || false;
						opts.supportsBinary = this.supportsBinary;
						opts.enablesXDR = this.enablesXDR;

						// SSL options for Node.js client
						opts.pfx = this.pfx;
						opts.key = this.key;
						opts.passphrase = this.passphrase;
						opts.cert = this.cert;
						opts.ca = this.ca;
						opts.ciphers = this.ciphers;
						opts.rejectUnauthorized = this.rejectUnauthorized;

						// other options for Node.js client
						opts.extraHeaders = this.extraHeaders;

						return new Request(opts);
					};

					/**
      * Sends data.
      *
      * @param {String} data to send.
      * @param {Function} called upon flush.
      * @api private
      */

					XHR.prototype.doWrite = function (data, fn) {
						var isBinary = typeof data !== 'string' && data !== undefined;
						var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
						var self = this;
						req.on('success', fn);
						req.on('error', function (err) {
							self.onError('xhr post error', err);
						});
						this.sendXhr = req;
					};

					/**
      * Starts a poll cycle.
      *
      * @api private
      */

					XHR.prototype.doPoll = function () {
						debug('xhr poll');
						var req = this.request();
						var self = this;
						req.on('data', function (data) {
							self.onData(data);
						});
						req.on('error', function (err) {
							self.onError('xhr poll error', err);
						});
						this.pollXhr = req;
					};

					/**
      * Request constructor
      *
      * @param {Object} options
      * @api public
      */

					function Request(opts) {
						this.method = opts.method || 'GET';
						this.uri = opts.uri;
						this.xd = !!opts.xd;
						this.xs = !!opts.xs;
						this.async = false !== opts.async;
						this.data = undefined != opts.data ? opts.data : null;
						this.agent = opts.agent;
						this.isBinary = opts.isBinary;
						this.supportsBinary = opts.supportsBinary;
						this.enablesXDR = opts.enablesXDR;

						// SSL options for Node.js client
						this.pfx = opts.pfx;
						this.key = opts.key;
						this.passphrase = opts.passphrase;
						this.cert = opts.cert;
						this.ca = opts.ca;
						this.ciphers = opts.ciphers;
						this.rejectUnauthorized = opts.rejectUnauthorized;

						// other options for Node.js client
						this.extraHeaders = opts.extraHeaders;

						this.create();
					}

					/**
      * Mix in `Emitter`.
      */

					Emitter(Request.prototype);

					/**
      * Creates the XHR object and sends the request.
      *
      * @api private
      */

					Request.prototype.create = function () {
						var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

						// SSL options for Node.js client
						opts.pfx = this.pfx;
						opts.key = this.key;
						opts.passphrase = this.passphrase;
						opts.cert = this.cert;
						opts.ca = this.ca;
						opts.ciphers = this.ciphers;
						opts.rejectUnauthorized = this.rejectUnauthorized;

						var xhr = this.xhr = new XMLHttpRequest(opts);
						var self = this;

						try {
							debug('xhr open %s: %s', this.method, this.uri);
							xhr.open(this.method, this.uri, this.async);
							try {
								if (this.extraHeaders) {
									xhr.setDisableHeaderCheck(true);
									for (var i in this.extraHeaders) {
										if (this.extraHeaders.hasOwnProperty(i)) {
											xhr.setRequestHeader(i, this.extraHeaders[i]);
										}
									}
								}
							} catch (e) {}
							if (this.supportsBinary) {
								// This has to be done after open because Firefox is stupid
								// http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
								xhr.responseType = 'arraybuffer';
							}

							if ('POST' == this.method) {
								try {
									if (this.isBinary) {
										xhr.setRequestHeader('Content-type', 'application/octet-stream');
									} else {
										xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
									}
								} catch (e) {}
							}

							// ie6 check
							if ('withCredentials' in xhr) {
								xhr.withCredentials = true;
							}

							if (this.hasXDR()) {
								xhr.onload = function () {
									self.onLoad();
								};
								xhr.onerror = function () {
									self.onError(xhr.responseText);
								};
							} else {
								xhr.onreadystatechange = function () {
									if (4 != xhr.readyState) return;
									if (200 == xhr.status || 1223 == xhr.status) {
										self.onLoad();
									} else {
										// make sure the `error` event handler that's user-set
										// does not throw in the same tick and gets caught here
										setTimeout(function () {
											self.onError(xhr.status);
										}, 0);
									}
								};
							}

							debug('xhr data %s', this.data);
							xhr.send(this.data);
						} catch (e) {
							// Need to defer since .create() is called directly fhrom the constructor
							// and thus the 'error' event can only be only bound *after* this exception
							// occurs.  Therefore, also, we cannot throw here at all.
							setTimeout(function () {
								self.onError(e);
							}, 0);
							return;
						}

						if (global.document) {
							this.index = Request.requestsCount++;
							Request.requests[this.index] = this;
						}
					};

					/**
      * Called upon successful response.
      *
      * @api private
      */

					Request.prototype.onSuccess = function () {
						this.emit('success');
						this.cleanup();
					};

					/**
      * Called if we have data.
      *
      * @api private
      */

					Request.prototype.onData = function (data) {
						this.emit('data', data);
						this.onSuccess();
					};

					/**
      * Called upon error.
      *
      * @api private
      */

					Request.prototype.onError = function (err) {
						this.emit('error', err);
						this.cleanup(true);
					};

					/**
      * Cleans up house.
      *
      * @api private
      */

					Request.prototype.cleanup = function (fromError) {
						if ('undefined' == typeof this.xhr || null === this.xhr) {
							return;
						}
						// xmlhttprequest
						if (this.hasXDR()) {
							this.xhr.onload = this.xhr.onerror = empty;
						} else {
							this.xhr.onreadystatechange = empty;
						}

						if (fromError) {
							try {
								this.xhr.abort();
							} catch (e) {}
						}

						if (global.document) {
							delete Request.requests[this.index];
						}

						this.xhr = null;
					};

					/**
      * Called upon load.
      *
      * @api private
      */

					Request.prototype.onLoad = function () {
						var data;
						try {
							var contentType;
							try {
								contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
							} catch (e) {}
							if (contentType === 'application/octet-stream') {
								data = this.xhr.response;
							} else {
								if (!this.supportsBinary) {
									data = this.xhr.responseText;
								} else {
									try {
										data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
									} catch (e) {
										var ui8Arr = new Uint8Array(this.xhr.response);
										var dataArray = [];
										for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
											dataArray.push(ui8Arr[idx]);
										}

										data = String.fromCharCode.apply(null, dataArray);
									}
								}
							}
						} catch (e) {
							this.onError(e);
						}
						if (null != data) {
							this.onData(data);
						}
					};

					/**
      * Check if it has XDomainRequest.
      *
      * @api private
      */

					Request.prototype.hasXDR = function () {
						return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
					};

					/**
      * Aborts the request.
      *
      * @api public
      */

					Request.prototype.abort = function () {
						this.cleanup();
					};

					/**
      * Aborts pending requests when unloading the window. This is needed to prevent
      * memory leaks (e.g. when using IE) and to ensure that no spurious error is
      * emitted.
      */

					if (global.document) {
						Request.requestsCount = 0;
						Request.requests = {};
						if (global.attachEvent) {
							global.attachEvent('onunload', unloadHandler);
						} else if (global.addEventListener) {
							global.addEventListener('beforeunload', unloadHandler, false);
						}
					}

					function unloadHandler() {
						for (var i in Request.requests) {
							if (Request.requests.hasOwnProperty(i)) {
								Request.requests[i].abort();
							}
						}
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./polling": 8, "component-emitter": 15, "component-inherit": 16, "debug": 17, "xmlhttprequest-ssl": 10 }], 8: [function (_dereq_, module, exports) {
				/**
     * Module dependencies.
     */

				var Transport = _dereq_('../transport');
				var parseqs = _dereq_('parseqs');
				var parser = _dereq_('engine.io-parser');
				var inherit = _dereq_('component-inherit');
				var yeast = _dereq_('yeast');
				var debug = _dereq_('debug')('engine.io-client:polling');

				/**
     * Module exports.
     */

				module.exports = Polling;

				/**
     * Is XHR2 supported?
     */

				var hasXHR2 = function () {
					var XMLHttpRequest = _dereq_('xmlhttprequest-ssl');
					var xhr = new XMLHttpRequest({ xdomain: false });
					return null != xhr.responseType;
				}();

				/**
     * Polling interface.
     *
     * @param {Object} opts
     * @api private
     */

				function Polling(opts) {
					var forceBase64 = opts && opts.forceBase64;
					if (!hasXHR2 || forceBase64) {
						this.supportsBinary = false;
					}
					Transport.call(this, opts);
				}

				/**
     * Inherits from Transport.
     */

				inherit(Polling, Transport);

				/**
     * Transport name.
     */

				Polling.prototype.name = 'polling';

				/**
     * Opens the socket (triggers polling). We write a PING message to determine
     * when the transport is open.
     *
     * @api private
     */

				Polling.prototype.doOpen = function () {
					this.poll();
				};

				/**
     * Pauses polling.
     *
     * @param {Function} callback upon buffers are flushed and transport is paused
     * @api private
     */

				Polling.prototype.pause = function (onPause) {
					var pending = 0;
					var self = this;

					this.readyState = 'pausing';

					function pause() {
						debug('paused');
						self.readyState = 'paused';
						onPause();
					}

					if (this.polling || !this.writable) {
						var total = 0;

						if (this.polling) {
							debug('we are currently polling - waiting to pause');
							total++;
							this.once('pollComplete', function () {
								debug('pre-pause polling complete');
								--total || pause();
							});
						}

						if (!this.writable) {
							debug('we are currently writing - waiting to pause');
							total++;
							this.once('drain', function () {
								debug('pre-pause writing complete');
								--total || pause();
							});
						}
					} else {
						pause();
					}
				};

				/**
     * Starts polling cycle.
     *
     * @api public
     */

				Polling.prototype.poll = function () {
					debug('polling');
					this.polling = true;
					this.doPoll();
					this.emit('poll');
				};

				/**
     * Overloads onData to detect payloads.
     *
     * @api private
     */

				Polling.prototype.onData = function (data) {
					var self = this;
					debug('polling got data %s', data);
					var callback = function callback(packet, index, total) {
						// if its the first message we consider the transport open
						if ('opening' == self.readyState) {
							self.onOpen();
						}

						// if its a close packet, we close the ongoing requests
						if ('close' == packet.type) {
							self.onClose();
							return false;
						}

						// otherwise bypass onData and handle the message
						self.onPacket(packet);
					};

					// decode payload
					parser.decodePayload(data, this.socket.binaryType, callback);

					// if an event did not trigger closing
					if ('closed' != this.readyState) {
						// if we got data we're not polling
						this.polling = false;
						this.emit('pollComplete');

						if ('open' == this.readyState) {
							this.poll();
						} else {
							debug('ignoring poll - transport state "%s"', this.readyState);
						}
					}
				};

				/**
     * For polling, send a close packet.
     *
     * @api private
     */

				Polling.prototype.doClose = function () {
					var self = this;

					function close() {
						debug('writing close packet');
						self.write([{ type: 'close' }]);
					}

					if ('open' == this.readyState) {
						debug('transport open - closing');
						close();
					} else {
						// in case we're trying to close while
						// handshaking is in progress (GH-164)
						debug('transport not open - deferring close');
						this.once('open', close);
					}
				};

				/**
     * Writes a packets payload.
     *
     * @param {Array} data packets
     * @param {Function} drain callback
     * @api private
     */

				Polling.prototype.write = function (packets) {
					var self = this;
					this.writable = false;
					var callbackfn = function callbackfn() {
						self.writable = true;
						self.emit('drain');
					};

					var self = this;
					parser.encodePayload(packets, this.supportsBinary, function (data) {
						self.doWrite(data, callbackfn);
					});
				};

				/**
     * Generates uri for connection.
     *
     * @api private
     */

				Polling.prototype.uri = function () {
					var query = this.query || {};
					var schema = this.secure ? 'https' : 'http';
					var port = '';

					// cache busting is forced
					if (false !== this.timestampRequests) {
						query[this.timestampParam] = yeast();
					}

					if (!this.supportsBinary && !query.sid) {
						query.b64 = 1;
					}

					query = parseqs.encode(query);

					// avoid port if default for schema
					if (this.port && ('https' == schema && this.port != 443 || 'http' == schema && this.port != 80)) {
						port = ':' + this.port;
					}

					// prepend ? to query
					if (query.length) {
						query = '?' + query;
					}

					var ipv6 = this.hostname.indexOf(':') !== -1;
					return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
				};
			}, { "../transport": 4, "component-inherit": 16, "debug": 17, "engine.io-parser": 19, "parseqs": 27, "xmlhttprequest-ssl": 10, "yeast": 30 }], 9: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Module dependencies.
      */

					var Transport = _dereq_('../transport');
					var parser = _dereq_('engine.io-parser');
					var parseqs = _dereq_('parseqs');
					var inherit = _dereq_('component-inherit');
					var yeast = _dereq_('yeast');
					var debug = _dereq_('debug')('engine.io-client:websocket');
					var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

					/**
      * Get either the `WebSocket` or `MozWebSocket` globals
      * in the browser or try to resolve WebSocket-compatible
      * interface exposed by `ws` for Node-like environment.
      */

					var WebSocket = BrowserWebSocket;
					if (!WebSocket && typeof window === 'undefined') {
						try {
							WebSocket = _dereq_('ws');
						} catch (e) {}
					}

					/**
      * Module exports.
      */

					module.exports = WS;

					/**
      * WebSocket transport constructor.
      *
      * @api {Object} connection options
      * @api public
      */

					function WS(opts) {
						var forceBase64 = opts && opts.forceBase64;
						if (forceBase64) {
							this.supportsBinary = false;
						}
						this.perMessageDeflate = opts.perMessageDeflate;
						Transport.call(this, opts);
					}

					/**
      * Inherits from Transport.
      */

					inherit(WS, Transport);

					/**
      * Transport name.
      *
      * @api public
      */

					WS.prototype.name = 'websocket';

					/*
      * WebSockets support binary
      */

					WS.prototype.supportsBinary = true;

					/**
      * Opens socket.
      *
      * @api private
      */

					WS.prototype.doOpen = function () {
						if (!this.check()) {
							// let probe timeout
							return;
						}

						var self = this;
						var uri = this.uri();
						var protocols = void 0;
						var opts = {
							agent: this.agent,
							perMessageDeflate: this.perMessageDeflate
						};

						// SSL options for Node.js client
						opts.pfx = this.pfx;
						opts.key = this.key;
						opts.passphrase = this.passphrase;
						opts.cert = this.cert;
						opts.ca = this.ca;
						opts.ciphers = this.ciphers;
						opts.rejectUnauthorized = this.rejectUnauthorized;
						if (this.extraHeaders) {
							opts.headers = this.extraHeaders;
						}

						this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

						if (this.ws.binaryType === undefined) {
							this.supportsBinary = false;
						}

						if (this.ws.supports && this.ws.supports.binary) {
							this.supportsBinary = true;
							this.ws.binaryType = 'buffer';
						} else {
							this.ws.binaryType = 'arraybuffer';
						}

						this.addEventListeners();
					};

					/**
      * Adds event listeners to the socket
      *
      * @api private
      */

					WS.prototype.addEventListeners = function () {
						var self = this;

						this.ws.onopen = function () {
							self.onOpen();
						};
						this.ws.onclose = function () {
							self.onClose();
						};
						this.ws.onmessage = function (ev) {
							self.onData(ev.data);
						};
						this.ws.onerror = function (e) {
							self.onError('websocket error', e);
						};
					};

					/**
      * Override `onData` to use a timer on iOS.
      * See: https://gist.github.com/mloughran/2052006
      *
      * @api private
      */

					if ('undefined' != typeof navigator && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
						WS.prototype.onData = function (data) {
							var self = this;
							setTimeout(function () {
								Transport.prototype.onData.call(self, data);
							}, 0);
						};
					}

					/**
      * Writes data to socket.
      *
      * @param {Array} array of packets.
      * @api private
      */

					WS.prototype.write = function (packets) {
						var self = this;
						this.writable = false;

						// encodePacket efficient as it uses WS framing
						// no need for encodePayload
						var total = packets.length;
						for (var i = 0, l = total; i < l; i++) {
							(function (packet) {
								parser.encodePacket(packet, self.supportsBinary, function (data) {
									if (!BrowserWebSocket) {
										// always create a new object (GH-437)
										var opts = {};
										if (packet.options) {
											opts.compress = packet.options.compress;
										}

										if (self.perMessageDeflate) {
											var len = 'string' == typeof data ? global.Buffer.byteLength(data) : data.length;
											if (len < self.perMessageDeflate.threshold) {
												opts.compress = false;
											}
										}
									}

									//Sometimes the websocket has already been closed but the browser didn't
									//have a chance of informing us about it yet, in that case send will
									//throw an error
									try {
										if (BrowserWebSocket) {
											// TypeError is thrown when passing the second argument on Safari
											self.ws.send(data);
										} else {
											self.ws.send(data, opts);
										}
									} catch (e) {
										debug('websocket closed before onclose event');
									}

									--total || done();
								});
							})(packets[i]);
						}

						function done() {
							self.emit('flush');

							// fake drain
							// defer to next tick to allow Socket to clear writeBuffer
							setTimeout(function () {
								self.writable = true;
								self.emit('drain');
							}, 0);
						}
					};

					/**
      * Called upon close
      *
      * @api private
      */

					WS.prototype.onClose = function () {
						Transport.prototype.onClose.call(this);
					};

					/**
      * Closes socket.
      *
      * @api private
      */

					WS.prototype.doClose = function () {
						if (typeof this.ws !== 'undefined') {
							this.ws.close();
						}
					};

					/**
      * Generates uri for connection.
      *
      * @api private
      */

					WS.prototype.uri = function () {
						var query = this.query || {};
						var schema = this.secure ? 'wss' : 'ws';
						var port = '';

						// avoid port if default for schema
						if (this.port && ('wss' == schema && this.port != 443 || 'ws' == schema && this.port != 80)) {
							port = ':' + this.port;
						}

						// append timestamp to URI
						if (this.timestampRequests) {
							query[this.timestampParam] = yeast();
						}

						// communicate binary support capabilities
						if (!this.supportsBinary) {
							query.b64 = 1;
						}

						query = parseqs.encode(query);

						// prepend ? to query
						if (query.length) {
							query = '?' + query;
						}

						var ipv6 = this.hostname.indexOf(':') !== -1;
						return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
					};

					/**
      * Feature detection for WebSocket.
      *
      * @return {Boolean} whether this transport is available.
      * @api public
      */

					WS.prototype.check = function () {
						return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "../transport": 4, "component-inherit": 16, "debug": 17, "engine.io-parser": 19, "parseqs": 27, "ws": undefined, "yeast": 30 }], 10: [function (_dereq_, module, exports) {
				// browser shim for xmlhttprequest module
				var hasCORS = _dereq_('has-cors');

				module.exports = function (opts) {
					var xdomain = opts.xdomain;

					// scheme must be same when usign XDomainRequest
					// http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
					var xscheme = opts.xscheme;

					// XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
					// https://github.com/Automattic/engine.io-client/pull/217
					var enablesXDR = opts.enablesXDR;

					// XMLHttpRequest can be disabled on IE
					try {
						if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
							return new XMLHttpRequest();
						}
					} catch (e) {}

					// Use XDomainRequest for IE8 if enablesXDR is true
					// because loading bar keeps flashing when using jsonp-polling
					// https://github.com/yujiosaka/socke.io-ie8-loading-example
					try {
						if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
							return new XDomainRequest();
						}
					} catch (e) {}

					if (!xdomain) {
						try {
							return new ActiveXObject('Microsoft.XMLHTTP');
						} catch (e) {}
					}
				};
			}, { "has-cors": 22 }], 11: [function (_dereq_, module, exports) {
				module.exports = after;

				function after(count, callback, err_cb) {
					var bail = false;
					err_cb = err_cb || noop;
					proxy.count = count;

					return count === 0 ? callback() : proxy;

					function proxy(err, result) {
						if (proxy.count <= 0) {
							throw new Error('after called too many times');
						}
						--proxy.count;

						// after first error, rest are passed to err_cb
						if (err) {
							bail = true;
							callback(err);
							// future error callbacks will go to error handler
							callback = err_cb;
						} else if (proxy.count === 0 && !bail) {
							callback(null, result);
						}
					}
				}

				function noop() {}
			}, {}], 12: [function (_dereq_, module, exports) {
				/**
     * An abstraction for slicing an arraybuffer even when
     * ArrayBuffer.prototype.slice is not supported
     *
     * @api public
     */

				module.exports = function (arraybuffer, start, end) {
					var bytes = arraybuffer.byteLength;
					start = start || 0;
					end = end || bytes;

					if (arraybuffer.slice) {
						return arraybuffer.slice(start, end);
					}

					if (start < 0) {
						start += bytes;
					}
					if (end < 0) {
						end += bytes;
					}
					if (end > bytes) {
						end = bytes;
					}

					if (start >= bytes || start >= end || bytes === 0) {
						return new ArrayBuffer(0);
					}

					var abv = new Uint8Array(arraybuffer);
					var result = new Uint8Array(end - start);
					for (var i = start, ii = 0; i < end; i++, ii++) {
						result[ii] = abv[i];
					}
					return result.buffer;
				};
			}, {}], 13: [function (_dereq_, module, exports) {
				/*
     * base64-arraybuffer
     * https://github.com/niklasvh/base64-arraybuffer
     *
     * Copyright (c) 2012 Niklas von Hertzen
     * Licensed under the MIT license.
     */
				(function (chars) {
					"use strict";

					exports.encode = function (arraybuffer) {
						var bytes = new Uint8Array(arraybuffer),
						    i,
						    len = bytes.length,
						    base64 = "";

						for (i = 0; i < len; i += 3) {
							base64 += chars[bytes[i] >> 2];
							base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
							base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
							base64 += chars[bytes[i + 2] & 63];
						}

						if (len % 3 === 2) {
							base64 = base64.substring(0, base64.length - 1) + "=";
						} else if (len % 3 === 1) {
							base64 = base64.substring(0, base64.length - 2) + "==";
						}

						return base64;
					};

					exports.decode = function (base64) {
						var bufferLength = base64.length * 0.75,
						    len = base64.length,
						    i,
						    p = 0,
						    encoded1,
						    encoded2,
						    encoded3,
						    encoded4;

						if (base64[base64.length - 1] === "=") {
							bufferLength--;
							if (base64[base64.length - 2] === "=") {
								bufferLength--;
							}
						}

						var arraybuffer = new ArrayBuffer(bufferLength),
						    bytes = new Uint8Array(arraybuffer);

						for (i = 0; i < len; i += 4) {
							encoded1 = chars.indexOf(base64[i]);
							encoded2 = chars.indexOf(base64[i + 1]);
							encoded3 = chars.indexOf(base64[i + 2]);
							encoded4 = chars.indexOf(base64[i + 3]);

							bytes[p++] = encoded1 << 2 | encoded2 >> 4;
							bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
							bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
						}

						return arraybuffer;
					};
				})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
			}, {}], 14: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Create a blob builder even when vendor prefixes exist
      */

					var BlobBuilder = global.BlobBuilder || global.WebKitBlobBuilder || global.MSBlobBuilder || global.MozBlobBuilder;

					/**
      * Check if Blob constructor is supported
      */

					var blobSupported = function () {
						try {
							var a = new Blob(['hi']);
							return a.size === 2;
						} catch (e) {
							return false;
						}
					}();

					/**
      * Check if Blob constructor supports ArrayBufferViews
      * Fails in Safari 6, so we need to map to ArrayBuffers there.
      */

					var blobSupportsArrayBufferView = blobSupported && function () {
						try {
							var b = new Blob([new Uint8Array([1, 2])]);
							return b.size === 2;
						} catch (e) {
							return false;
						}
					}();

					/**
      * Check if BlobBuilder is supported
      */

					var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;

					/**
      * Helper function that maps ArrayBufferViews to ArrayBuffers
      * Used by BlobBuilder constructor and old browsers that didn't
      * support it in the Blob constructor.
      */

					function mapArrayBufferViews(ary) {
						for (var i = 0; i < ary.length; i++) {
							var chunk = ary[i];
							if (chunk.buffer instanceof ArrayBuffer) {
								var buf = chunk.buffer;

								// if this is a subarray, make a copy so we only
								// include the subarray region from the underlying buffer
								if (chunk.byteLength !== buf.byteLength) {
									var copy = new Uint8Array(chunk.byteLength);
									copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
									buf = copy.buffer;
								}

								ary[i] = buf;
							}
						}
					}

					function BlobBuilderConstructor(ary, options) {
						options = options || {};

						var bb = new BlobBuilder();
						mapArrayBufferViews(ary);

						for (var i = 0; i < ary.length; i++) {
							bb.append(ary[i]);
						}

						return options.type ? bb.getBlob(options.type) : bb.getBlob();
					};

					function BlobConstructor(ary, options) {
						mapArrayBufferViews(ary);
						return new Blob(ary, options || {});
					};

					module.exports = function () {
						if (blobSupported) {
							return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
						} else if (blobBuilderSupported) {
							return BlobBuilderConstructor;
						} else {
							return undefined;
						}
					}();
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, {}], 15: [function (_dereq_, module, exports) {

				/**
     * Expose `Emitter`.
     */

				module.exports = Emitter;

				/**
     * Initialize a new `Emitter`.
     *
     * @api public
     */

				function Emitter(obj) {
					if (obj) return mixin(obj);
				};

				/**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

				function mixin(obj) {
					for (var key in Emitter.prototype) {
						obj[key] = Emitter.prototype[key];
					}
					return obj;
				}

				/**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
					this._callbacks = this._callbacks || {};
					(this._callbacks[event] = this._callbacks[event] || []).push(fn);
					return this;
				};

				/**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.once = function (event, fn) {
					var self = this;
					this._callbacks = this._callbacks || {};

					function on() {
						self.off(event, on);
						fn.apply(this, arguments);
					}

					on.fn = fn;
					this.on(event, on);
					return this;
				};

				/**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
					this._callbacks = this._callbacks || {};

					// all
					if (0 == arguments.length) {
						this._callbacks = {};
						return this;
					}

					// specific event
					var callbacks = this._callbacks[event];
					if (!callbacks) return this;

					// remove all handlers
					if (1 == arguments.length) {
						delete this._callbacks[event];
						return this;
					}

					// remove specific handler
					var cb;
					for (var i = 0; i < callbacks.length; i++) {
						cb = callbacks[i];
						if (cb === fn || cb.fn === fn) {
							callbacks.splice(i, 1);
							break;
						}
					}
					return this;
				};

				/**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */

				Emitter.prototype.emit = function (event) {
					this._callbacks = this._callbacks || {};
					var args = [].slice.call(arguments, 1),
					    callbacks = this._callbacks[event];

					if (callbacks) {
						callbacks = callbacks.slice(0);
						for (var i = 0, len = callbacks.length; i < len; ++i) {
							callbacks[i].apply(this, args);
						}
					}

					return this;
				};

				/**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */

				Emitter.prototype.listeners = function (event) {
					this._callbacks = this._callbacks || {};
					return this._callbacks[event] || [];
				};

				/**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */

				Emitter.prototype.hasListeners = function (event) {
					return !!this.listeners(event).length;
				};
			}, {}], 16: [function (_dereq_, module, exports) {

				module.exports = function (a, b) {
					var fn = function fn() {};
					fn.prototype = b.prototype;
					a.prototype = new fn();
					a.prototype.constructor = a;
				};
			}, {}], 17: [function (_dereq_, module, exports) {

				/**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

				exports = module.exports = _dereq_('./debug');
				exports.log = log;
				exports.formatArgs = formatArgs;
				exports.save = save;
				exports.load = load;
				exports.useColors = useColors;
				exports.storage = 'undefined' != typeof chrome && 'undefined' != typeof chrome.storage ? chrome.storage.local : localstorage();

				/**
     * Colors.
     */

				exports.colors = ['lightseagreen', 'forestgreen', 'goldenrod', 'dodgerblue', 'darkorchid', 'crimson'];

				/**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

				function useColors() {
					// is webkit? http://stackoverflow.com/a/16459606/376773
					return 'WebkitAppearance' in document.documentElement.style ||
					// is firebug? http://stackoverflow.com/a/398120/376773
					window.console && (console.firebug || console.exception && console.table) ||
					// is firefox >= v31?
					// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
					navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31;
				}

				/**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

				exports.formatters.j = function (v) {
					return JSON.stringify(v);
				};

				/**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

				function formatArgs() {
					var args = arguments;
					var useColors = this.useColors;

					args[0] = (useColors ? '%c' : '') + this.namespace + (useColors ? ' %c' : ' ') + args[0] + (useColors ? '%c ' : ' ') + '+' + exports.humanize(this.diff);

					if (!useColors) return args;

					var c = 'color: ' + this.color;
					args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

					// the final "%c" is somewhat tricky, because there could be other
					// arguments passed either before or after the %c, so we need to
					// figure out the correct index to insert the CSS into
					var index = 0;
					var lastC = 0;
					args[0].replace(/%[a-z%]/g, function (match) {
						if ('%%' === match) return;
						index++;
						if ('%c' === match) {
							// we only are interested in the *last* %c
							// (the user may have provided their own)
							lastC = index;
						}
					});

					args.splice(lastC, 0, c);
					return args;
				}

				/**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

				function log() {
					// this hackery is required for IE8/9, where
					// the `console.log` function doesn't have 'apply'
					return 'object' === (typeof console === "undefined" ? "undefined" : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
				}

				/**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

				function save(namespaces) {
					try {
						if (null == namespaces) {
							exports.storage.removeItem('debug');
						} else {
							exports.storage.debug = namespaces;
						}
					} catch (e) {}
				}

				/**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

				function load() {
					var r;
					try {
						r = exports.storage.debug;
					} catch (e) {}
					return r;
				}

				/**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

				exports.enable(load());

				/**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

				function localstorage() {
					try {
						return window.localStorage;
					} catch (e) {}
				}
			}, { "./debug": 18 }], 18: [function (_dereq_, module, exports) {

				/**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

				exports = module.exports = debug;
				exports.coerce = coerce;
				exports.disable = disable;
				exports.enable = enable;
				exports.enabled = enabled;
				exports.humanize = _dereq_('ms');

				/**
     * The currently active debug mode names, and names to skip.
     */

				exports.names = [];
				exports.skips = [];

				/**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lowercased letter, i.e. "n".
     */

				exports.formatters = {};

				/**
     * Previously assigned color.
     */

				var prevColor = 0;

				/**
     * Previous log timestamp.
     */

				var prevTime;

				/**
     * Select a color.
     *
     * @return {Number}
     * @api private
     */

				function selectColor() {
					return exports.colors[prevColor++ % exports.colors.length];
				}

				/**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

				function debug(namespace) {

					// define the `disabled` version
					function disabled() {}
					disabled.enabled = false;

					// define the `enabled` version
					function enabled() {

						var self = enabled;

						// set `diff` timestamp
						var curr = +new Date();
						var ms = curr - (prevTime || curr);
						self.diff = ms;
						self.prev = prevTime;
						self.curr = curr;
						prevTime = curr;

						// add the `color` if not set
						if (null == self.useColors) self.useColors = exports.useColors();
						if (null == self.color && self.useColors) self.color = selectColor();

						var args = Array.prototype.slice.call(arguments);

						args[0] = exports.coerce(args[0]);

						if ('string' !== typeof args[0]) {
							// anything else let's inspect with %o
							args = ['%o'].concat(args);
						}

						// apply any `formatters` transformations
						var index = 0;
						args[0] = args[0].replace(/%([a-z%])/g, function (match, format) {
							// if we encounter an escaped % then don't increase the array index
							if (match === '%%') return match;
							index++;
							var formatter = exports.formatters[format];
							if ('function' === typeof formatter) {
								var val = args[index];
								match = formatter.call(self, val);

								// now we need to remove `args[index]` since it's inlined in the `format`
								args.splice(index, 1);
								index--;
							}
							return match;
						});

						if ('function' === typeof exports.formatArgs) {
							args = exports.formatArgs.apply(self, args);
						}
						var logFn = enabled.log || exports.log || console.log.bind(console);
						logFn.apply(self, args);
					}
					enabled.enabled = true;

					var fn = exports.enabled(namespace) ? enabled : disabled;

					fn.namespace = namespace;

					return fn;
				}

				/**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

				function enable(namespaces) {
					exports.save(namespaces);

					var split = (namespaces || '').split(/[\s,]+/);
					var len = split.length;

					for (var i = 0; i < len; i++) {
						if (!split[i]) continue; // ignore empty strings
						namespaces = split[i].replace(/\*/g, '.*?');
						if (namespaces[0] === '-') {
							exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
						} else {
							exports.names.push(new RegExp('^' + namespaces + '$'));
						}
					}
				}

				/**
     * Disable debug output.
     *
     * @api public
     */

				function disable() {
					exports.enable('');
				}

				/**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

				function enabled(name) {
					var i, len;
					for (i = 0, len = exports.skips.length; i < len; i++) {
						if (exports.skips[i].test(name)) {
							return false;
						}
					}
					for (i = 0, len = exports.names.length; i < len; i++) {
						if (exports.names[i].test(name)) {
							return true;
						}
					}
					return false;
				}

				/**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

				function coerce(val) {
					if (val instanceof Error) return val.stack || val.message;
					return val;
				}
			}, { "ms": 25 }], 19: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * Module dependencies.
      */

					var keys = _dereq_('./keys');
					var hasBinary = _dereq_('has-binary');
					var sliceBuffer = _dereq_('arraybuffer.slice');
					var base64encoder = _dereq_('base64-arraybuffer');
					var after = _dereq_('after');
					var utf8 = _dereq_('utf8');

					/**
      * Check if we are running an android browser. That requires us to use
      * ArrayBuffer with polling transports...
      *
      * http://ghinda.net/jpeg-blob-ajax-android/
      */

					var isAndroid = navigator.userAgent.match(/Android/i);

					/**
      * Check if we are running in PhantomJS.
      * Uploading a Blob with PhantomJS does not work correctly, as reported here:
      * https://github.com/ariya/phantomjs/issues/11395
      * @type boolean
      */
					var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

					/**
      * When true, avoids using Blobs to encode payloads.
      * @type boolean
      */
					var dontSendBlobs = isAndroid || isPhantomJS;

					/**
      * Current protocol version.
      */

					exports.protocol = 3;

					/**
      * Packet types.
      */

					var packets = exports.packets = {
						open: 0 // non-ws
						, close: 1 // non-ws
						, ping: 2,
						pong: 3,
						message: 4,
						upgrade: 5,
						noop: 6
					};

					var packetslist = keys(packets);

					/**
      * Premade error packet.
      */

					var err = { type: 'error', data: 'parser error' };

					/**
      * Create a blob api even for blob builder when vendor prefixes exist
      */

					var Blob = _dereq_('blob');

					/**
      * Encodes a packet.
      *
      *     <packet type id> [ <data> ]
      *
      * Example:
      *
      *     5hello world
      *     3
      *     4
      *
      * Binary is encoded in an identical principle
      *
      * @api private
      */

					exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
						if ('function' == typeof supportsBinary) {
							callback = supportsBinary;
							supportsBinary = false;
						}

						if ('function' == typeof utf8encode) {
							callback = utf8encode;
							utf8encode = null;
						}

						var data = packet.data === undefined ? undefined : packet.data.buffer || packet.data;

						if (global.ArrayBuffer && data instanceof ArrayBuffer) {
							return encodeArrayBuffer(packet, supportsBinary, callback);
						} else if (Blob && data instanceof global.Blob) {
							return encodeBlob(packet, supportsBinary, callback);
						}

						// might be an object with { base64: true, data: dataAsBase64String }
						if (data && data.base64) {
							return encodeBase64Object(packet, callback);
						}

						// Sending data as a utf-8 string
						var encoded = packets[packet.type];

						// data fragment is optional
						if (undefined !== packet.data) {
							encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
						}

						return callback('' + encoded);
					};

					function encodeBase64Object(packet, callback) {
						// packet data is an object { base64: true, data: dataAsBase64String }
						var message = 'b' + exports.packets[packet.type] + packet.data.data;
						return callback(message);
					}

					/**
      * Encode packet helpers for binary types
      */

					function encodeArrayBuffer(packet, supportsBinary, callback) {
						if (!supportsBinary) {
							return exports.encodeBase64Packet(packet, callback);
						}

						var data = packet.data;
						var contentArray = new Uint8Array(data);
						var resultBuffer = new Uint8Array(1 + data.byteLength);

						resultBuffer[0] = packets[packet.type];
						for (var i = 0; i < contentArray.length; i++) {
							resultBuffer[i + 1] = contentArray[i];
						}

						return callback(resultBuffer.buffer);
					}

					function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
						if (!supportsBinary) {
							return exports.encodeBase64Packet(packet, callback);
						}

						var fr = new FileReader();
						fr.onload = function () {
							packet.data = fr.result;
							exports.encodePacket(packet, supportsBinary, true, callback);
						};
						return fr.readAsArrayBuffer(packet.data);
					}

					function encodeBlob(packet, supportsBinary, callback) {
						if (!supportsBinary) {
							return exports.encodeBase64Packet(packet, callback);
						}

						if (dontSendBlobs) {
							return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
						}

						var length = new Uint8Array(1);
						length[0] = packets[packet.type];
						var blob = new Blob([length.buffer, packet.data]);

						return callback(blob);
					}

					/**
      * Encodes a packet with binary data in a base64 string
      *
      * @param {Object} packet, has `type` and `data`
      * @return {String} base64 encoded message
      */

					exports.encodeBase64Packet = function (packet, callback) {
						var message = 'b' + exports.packets[packet.type];
						if (Blob && packet.data instanceof global.Blob) {
							var fr = new FileReader();
							fr.onload = function () {
								var b64 = fr.result.split(',')[1];
								callback(message + b64);
							};
							return fr.readAsDataURL(packet.data);
						}

						var b64data;
						try {
							b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
						} catch (e) {
							// iPhone Safari doesn't let you apply with typed arrays
							var typed = new Uint8Array(packet.data);
							var basic = new Array(typed.length);
							for (var i = 0; i < typed.length; i++) {
								basic[i] = typed[i];
							}
							b64data = String.fromCharCode.apply(null, basic);
						}
						message += global.btoa(b64data);
						return callback(message);
					};

					/**
      * Decodes a packet. Changes format to Blob if requested.
      *
      * @return {Object} with `type` and `data` (if any)
      * @api private
      */

					exports.decodePacket = function (data, binaryType, utf8decode) {
						// String data
						if (typeof data == 'string' || data === undefined) {
							if (data.charAt(0) == 'b') {
								return exports.decodeBase64Packet(data.substr(1), binaryType);
							}

							if (utf8decode) {
								try {
									data = utf8.decode(data);
								} catch (e) {
									return err;
								}
							}
							var type = data.charAt(0);

							if (Number(type) != type || !packetslist[type]) {
								return err;
							}

							if (data.length > 1) {
								return { type: packetslist[type], data: data.substring(1) };
							} else {
								return { type: packetslist[type] };
							}
						}

						var asArray = new Uint8Array(data);
						var type = asArray[0];
						var rest = sliceBuffer(data, 1);
						if (Blob && binaryType === 'blob') {
							rest = new Blob([rest]);
						}
						return { type: packetslist[type], data: rest };
					};

					/**
      * Decodes a packet encoded in a base64 string
      *
      * @param {String} base64 encoded message
      * @return {Object} with `type` and `data` (if any)
      */

					exports.decodeBase64Packet = function (msg, binaryType) {
						var type = packetslist[msg.charAt(0)];
						if (!global.ArrayBuffer) {
							return { type: type, data: { base64: true, data: msg.substr(1) } };
						}

						var data = base64encoder.decode(msg.substr(1));

						if (binaryType === 'blob' && Blob) {
							data = new Blob([data]);
						}

						return { type: type, data: data };
					};

					/**
      * Encodes multiple messages (payload).
      *
      *     <length>:data
      *
      * Example:
      *
      *     11:hello world2:hi
      *
      * If any contents are binary, they will be encoded as base64 strings. Base64
      * encoded strings are marked with a b before the length specifier
      *
      * @param {Array} packets
      * @api private
      */

					exports.encodePayload = function (packets, supportsBinary, callback) {
						if (typeof supportsBinary == 'function') {
							callback = supportsBinary;
							supportsBinary = null;
						}

						var isBinary = hasBinary(packets);

						if (supportsBinary && isBinary) {
							if (Blob && !dontSendBlobs) {
								return exports.encodePayloadAsBlob(packets, callback);
							}

							return exports.encodePayloadAsArrayBuffer(packets, callback);
						}

						if (!packets.length) {
							return callback('0:');
						}

						function setLengthHeader(message) {
							return message.length + ':' + message;
						}

						function encodeOne(packet, doneCallback) {
							exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function (message) {
								doneCallback(null, setLengthHeader(message));
							});
						}

						map(packets, encodeOne, function (err, results) {
							return callback(results.join(''));
						});
					};

					/**
      * Async array map using after
      */

					function map(ary, each, done) {
						var result = new Array(ary.length);
						var next = after(ary.length, done);

						var eachWithIndex = function eachWithIndex(i, el, cb) {
							each(el, function (error, msg) {
								result[i] = msg;
								cb(error, result);
							});
						};

						for (var i = 0; i < ary.length; i++) {
							eachWithIndex(i, ary[i], next);
						}
					}

					/*
      * Decodes data when a payload is maybe expected. Possible binary contents are
      * decoded from their base64 representation
      *
      * @param {String} data, callback method
      * @api public
      */

					exports.decodePayload = function (data, binaryType, callback) {
						if (typeof data != 'string') {
							return exports.decodePayloadAsBinary(data, binaryType, callback);
						}

						if (typeof binaryType === 'function') {
							callback = binaryType;
							binaryType = null;
						}

						var packet;
						if (data == '') {
							// parser error - ignoring payload
							return callback(err, 0, 1);
						}

						var length = '',
						    n,
						    msg;

						for (var i = 0, l = data.length; i < l; i++) {
							var chr = data.charAt(i);

							if (':' != chr) {
								length += chr;
							} else {
								if ('' == length || length != (n = Number(length))) {
									// parser error - ignoring payload
									return callback(err, 0, 1);
								}

								msg = data.substr(i + 1, n);

								if (length != msg.length) {
									// parser error - ignoring payload
									return callback(err, 0, 1);
								}

								if (msg.length) {
									packet = exports.decodePacket(msg, binaryType, true);

									if (err.type == packet.type && err.data == packet.data) {
										// parser error in individual packet - ignoring payload
										return callback(err, 0, 1);
									}

									var ret = callback(packet, i + n, l);
									if (false === ret) return;
								}

								// advance cursor
								i += n;
								length = '';
							}
						}

						if (length != '') {
							// parser error - ignoring payload
							return callback(err, 0, 1);
						}
					};

					/**
      * Encodes multiple messages (payload) as binary.
      *
      * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
      * 255><data>
      *
      * Example:
      * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
      *
      * @param {Array} packets
      * @return {ArrayBuffer} encoded payload
      * @api private
      */

					exports.encodePayloadAsArrayBuffer = function (packets, callback) {
						if (!packets.length) {
							return callback(new ArrayBuffer(0));
						}

						function encodeOne(packet, doneCallback) {
							exports.encodePacket(packet, true, true, function (data) {
								return doneCallback(null, data);
							});
						}

						map(packets, encodeOne, function (err, encodedPackets) {
							var totalLength = encodedPackets.reduce(function (acc, p) {
								var len;
								if (typeof p === 'string') {
									len = p.length;
								} else {
									len = p.byteLength;
								}
								return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
							}, 0);

							var resultArray = new Uint8Array(totalLength);

							var bufferIndex = 0;
							encodedPackets.forEach(function (p) {
								var isString = typeof p === 'string';
								var ab = p;
								if (isString) {
									var view = new Uint8Array(p.length);
									for (var i = 0; i < p.length; i++) {
										view[i] = p.charCodeAt(i);
									}
									ab = view.buffer;
								}

								if (isString) {
									// not true binary
									resultArray[bufferIndex++] = 0;
								} else {
									// true binary
									resultArray[bufferIndex++] = 1;
								}

								var lenStr = ab.byteLength.toString();
								for (var i = 0; i < lenStr.length; i++) {
									resultArray[bufferIndex++] = parseInt(lenStr[i]);
								}
								resultArray[bufferIndex++] = 255;

								var view = new Uint8Array(ab);
								for (var i = 0; i < view.length; i++) {
									resultArray[bufferIndex++] = view[i];
								}
							});

							return callback(resultArray.buffer);
						});
					};

					/**
      * Encode as Blob
      */

					exports.encodePayloadAsBlob = function (packets, callback) {
						function encodeOne(packet, doneCallback) {
							exports.encodePacket(packet, true, true, function (encoded) {
								var binaryIdentifier = new Uint8Array(1);
								binaryIdentifier[0] = 1;
								if (typeof encoded === 'string') {
									var view = new Uint8Array(encoded.length);
									for (var i = 0; i < encoded.length; i++) {
										view[i] = encoded.charCodeAt(i);
									}
									encoded = view.buffer;
									binaryIdentifier[0] = 0;
								}

								var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;

								var lenStr = len.toString();
								var lengthAry = new Uint8Array(lenStr.length + 1);
								for (var i = 0; i < lenStr.length; i++) {
									lengthAry[i] = parseInt(lenStr[i]);
								}
								lengthAry[lenStr.length] = 255;

								if (Blob) {
									var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
									doneCallback(null, blob);
								}
							});
						}

						map(packets, encodeOne, function (err, results) {
							return callback(new Blob(results));
						});
					};

					/*
      * Decodes data when a payload is maybe expected. Strings are decoded by
      * interpreting each byte as a key code for entries marked to start with 0. See
      * description of encodePayloadAsBinary
      *
      * @param {ArrayBuffer} data, callback method
      * @api public
      */

					exports.decodePayloadAsBinary = function (data, binaryType, callback) {
						if (typeof binaryType === 'function') {
							callback = binaryType;
							binaryType = null;
						}

						var bufferTail = data;
						var buffers = [];

						var numberTooLong = false;
						while (bufferTail.byteLength > 0) {
							var tailArray = new Uint8Array(bufferTail);
							var isString = tailArray[0] === 0;
							var msgLength = '';

							for (var i = 1;; i++) {
								if (tailArray[i] == 255) break;

								if (msgLength.length > 310) {
									numberTooLong = true;
									break;
								}

								msgLength += tailArray[i];
							}

							if (numberTooLong) return callback(err, 0, 1);

							bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
							msgLength = parseInt(msgLength);

							var msg = sliceBuffer(bufferTail, 0, msgLength);
							if (isString) {
								try {
									msg = String.fromCharCode.apply(null, new Uint8Array(msg));
								} catch (e) {
									// iPhone Safari doesn't let you apply to typed arrays
									var typed = new Uint8Array(msg);
									msg = '';
									for (var i = 0; i < typed.length; i++) {
										msg += String.fromCharCode(typed[i]);
									}
								}
							}

							buffers.push(msg);
							bufferTail = sliceBuffer(bufferTail, msgLength);
						}

						var total = buffers.length;
						buffers.forEach(function (buffer, i) {
							callback(exports.decodePacket(buffer, binaryType, true), i, total);
						});
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./keys": 20, "after": 11, "arraybuffer.slice": 12, "base64-arraybuffer": 13, "blob": 14, "has-binary": 21, "utf8": 29 }], 20: [function (_dereq_, module, exports) {

				/**
     * Gets the keys for an object.
     *
     * @return {Array} keys
     * @api private
     */

				module.exports = Object.keys || function keys(obj) {
					var arr = [];
					var has = Object.prototype.hasOwnProperty;

					for (var i in obj) {
						if (has.call(obj, i)) {
							arr.push(i);
						}
					}
					return arr;
				};
			}, {}], 21: [function (_dereq_, module, exports) {
				(function (global) {

					/*
      * Module requirements.
      */

					var isArray = _dereq_('isarray');

					/**
      * Module exports.
      */

					module.exports = hasBinary;

					/**
      * Checks for binary data.
      *
      * Right now only Buffer and ArrayBuffer are supported..
      *
      * @param {Object} anything
      * @api public
      */

					function hasBinary(data) {

						function _hasBinary(obj) {
							if (!obj) return false;

							if (global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
								return true;
							}

							if (isArray(obj)) {
								for (var i = 0; i < obj.length; i++) {
									if (_hasBinary(obj[i])) {
										return true;
									}
								}
							} else if (obj && 'object' == (typeof obj === "undefined" ? "undefined" : _typeof(obj))) {
								if (obj.toJSON) {
									obj = obj.toJSON();
								}

								for (var key in obj) {
									if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
										return true;
									}
								}
							}

							return false;
						}

						return _hasBinary(data);
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "isarray": 24 }], 22: [function (_dereq_, module, exports) {

				/**
     * Module exports.
     *
     * Logic borrowed from Modernizr:
     *
     *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
     */

				try {
					module.exports = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();
				} catch (err) {
					// if XMLHttp support is disabled in IE then it will throw
					// when trying to create
					module.exports = false;
				}
			}, {}], 23: [function (_dereq_, module, exports) {

				var indexOf = [].indexOf;

				module.exports = function (arr, obj) {
					if (indexOf) return arr.indexOf(obj);
					for (var i = 0; i < arr.length; ++i) {
						if (arr[i] === obj) return i;
					}
					return -1;
				};
			}, {}], 24: [function (_dereq_, module, exports) {
				module.exports = Array.isArray || function (arr) {
					return Object.prototype.toString.call(arr) == '[object Array]';
				};
			}, {}], 25: [function (_dereq_, module, exports) {
				/**
     * Helpers.
     */

				var s = 1000;
				var m = s * 60;
				var h = m * 60;
				var d = h * 24;
				var y = d * 365.25;

				/**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} options
     * @return {String|Number}
     * @api public
     */

				module.exports = function (val, options) {
					options = options || {};
					if ('string' == typeof val) return parse(val);
					return options.long ? long(val) : short(val);
				};

				/**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

				function parse(str) {
					str = '' + str;
					if (str.length > 10000) return;
					var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
					if (!match) return;
					var n = parseFloat(match[1]);
					var type = (match[2] || 'ms').toLowerCase();
					switch (type) {
						case 'years':
						case 'year':
						case 'yrs':
						case 'yr':
						case 'y':
							return n * y;
						case 'days':
						case 'day':
						case 'd':
							return n * d;
						case 'hours':
						case 'hour':
						case 'hrs':
						case 'hr':
						case 'h':
							return n * h;
						case 'minutes':
						case 'minute':
						case 'mins':
						case 'min':
						case 'm':
							return n * m;
						case 'seconds':
						case 'second':
						case 'secs':
						case 'sec':
						case 's':
							return n * s;
						case 'milliseconds':
						case 'millisecond':
						case 'msecs':
						case 'msec':
						case 'ms':
							return n;
					}
				}

				/**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

				function short(ms) {
					if (ms >= d) return Math.round(ms / d) + 'd';
					if (ms >= h) return Math.round(ms / h) + 'h';
					if (ms >= m) return Math.round(ms / m) + 'm';
					if (ms >= s) return Math.round(ms / s) + 's';
					return ms + 'ms';
				}

				/**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

				function long(ms) {
					return plural(ms, d, 'day') || plural(ms, h, 'hour') || plural(ms, m, 'minute') || plural(ms, s, 'second') || ms + ' ms';
				}

				/**
     * Pluralization helper.
     */

				function plural(ms, n, name) {
					if (ms < n) return;
					if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
					return Math.ceil(ms / n) + ' ' + name + 's';
				}
			}, {}], 26: [function (_dereq_, module, exports) {
				(function (global) {
					/**
      * JSON parse.
      *
      * @see Based on jQuery#parseJSON (MIT) and JSON2
      * @api private
      */

					var rvalidchars = /^[\],:{}\s]*$/;
					var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
					var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
					var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
					var rtrimLeft = /^\s+/;
					var rtrimRight = /\s+$/;

					module.exports = function parsejson(data) {
						if ('string' != typeof data || !data) {
							return null;
						}

						data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

						// Attempt to parse using the native JSON parser first
						if (global.JSON && JSON.parse) {
							return JSON.parse(data);
						}

						if (rvalidchars.test(data.replace(rvalidescape, '@').replace(rvalidtokens, ']').replace(rvalidbraces, ''))) {
							return new Function('return ' + data)();
						}
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, {}], 27: [function (_dereq_, module, exports) {
				/**
     * Compiles a querystring
     * Returns string representation of the object
     *
     * @param {Object}
     * @api private
     */

				exports.encode = function (obj) {
					var str = '';

					for (var i in obj) {
						if (obj.hasOwnProperty(i)) {
							if (str.length) str += '&';
							str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
						}
					}

					return str;
				};

				/**
     * Parses a simple querystring into an object
     *
     * @param {String} qs
     * @api private
     */

				exports.decode = function (qs) {
					var qry = {};
					var pairs = qs.split('&');
					for (var i = 0, l = pairs.length; i < l; i++) {
						var pair = pairs[i].split('=');
						qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
					}
					return qry;
				};
			}, {}], 28: [function (_dereq_, module, exports) {
				/**
     * Parses an URI
     *
     * @author Steven Levithan <stevenlevithan.com> (MIT license)
     * @api private
     */

				var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

				var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];

				module.exports = function parseuri(str) {
					var src = str,
					    b = str.indexOf('['),
					    e = str.indexOf(']');

					if (b != -1 && e != -1) {
						str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
					}

					var m = re.exec(str || ''),
					    uri = {},
					    i = 14;

					while (i--) {
						uri[parts[i]] = m[i] || '';
					}

					if (b != -1 && e != -1) {
						uri.source = src;
						uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
						uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
						uri.ipv6uri = true;
					}

					return uri;
				};
			}, {}], 29: [function (_dereq_, module, exports) {
				(function (global) {
					/*! https://mths.be/utf8js v2.0.0 by @mathias */
					;(function (root) {

						// Detect free variables `exports`
						var freeExports = (typeof exports === "undefined" ? "undefined" : _typeof(exports)) == 'object' && exports;

						// Detect free variable `module`
						var freeModule = (typeof module === "undefined" ? "undefined" : _typeof(module)) == 'object' && module && module.exports == freeExports && module;

						// Detect free variable `global`, from Node.js or Browserified code,
						// and use it as `root`
						var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global;
						if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
							root = freeGlobal;
						}

						/*--------------------------------------------------------------------------*/

						var stringFromCharCode = String.fromCharCode;

						// Taken from https://mths.be/punycode
						function ucs2decode(string) {
							var output = [];
							var counter = 0;
							var length = string.length;
							var value;
							var extra;
							while (counter < length) {
								value = string.charCodeAt(counter++);
								if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
									// high surrogate, and there is a next character
									extra = string.charCodeAt(counter++);
									if ((extra & 0xFC00) == 0xDC00) {
										// low surrogate
										output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
									} else {
										// unmatched surrogate; only append this code unit, in case the next
										// code unit is the high surrogate of a surrogate pair
										output.push(value);
										counter--;
									}
								} else {
									output.push(value);
								}
							}
							return output;
						}

						// Taken from https://mths.be/punycode
						function ucs2encode(array) {
							var length = array.length;
							var index = -1;
							var value;
							var output = '';
							while (++index < length) {
								value = array[index];
								if (value > 0xFFFF) {
									value -= 0x10000;
									output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
									value = 0xDC00 | value & 0x3FF;
								}
								output += stringFromCharCode(value);
							}
							return output;
						}

						function checkScalarValue(codePoint) {
							if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
								throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
							}
						}
						/*--------------------------------------------------------------------------*/

						function createByte(codePoint, shift) {
							return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
						}

						function encodeCodePoint(codePoint) {
							if ((codePoint & 0xFFFFFF80) == 0) {
								// 1-byte sequence
								return stringFromCharCode(codePoint);
							}
							var symbol = '';
							if ((codePoint & 0xFFFFF800) == 0) {
								// 2-byte sequence
								symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
							} else if ((codePoint & 0xFFFF0000) == 0) {
								// 3-byte sequence
								checkScalarValue(codePoint);
								symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
								symbol += createByte(codePoint, 6);
							} else if ((codePoint & 0xFFE00000) == 0) {
								// 4-byte sequence
								symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
								symbol += createByte(codePoint, 12);
								symbol += createByte(codePoint, 6);
							}
							symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
							return symbol;
						}

						function utf8encode(string) {
							var codePoints = ucs2decode(string);
							var length = codePoints.length;
							var index = -1;
							var codePoint;
							var byteString = '';
							while (++index < length) {
								codePoint = codePoints[index];
								byteString += encodeCodePoint(codePoint);
							}
							return byteString;
						}

						/*--------------------------------------------------------------------------*/

						function readContinuationByte() {
							if (byteIndex >= byteCount) {
								throw Error('Invalid byte index');
							}

							var continuationByte = byteArray[byteIndex] & 0xFF;
							byteIndex++;

							if ((continuationByte & 0xC0) == 0x80) {
								return continuationByte & 0x3F;
							}

							// If we end up here, it’s not a continuation byte
							throw Error('Invalid continuation byte');
						}

						function decodeSymbol() {
							var byte1;
							var byte2;
							var byte3;
							var byte4;
							var codePoint;

							if (byteIndex > byteCount) {
								throw Error('Invalid byte index');
							}

							if (byteIndex == byteCount) {
								return false;
							}

							// Read first byte
							byte1 = byteArray[byteIndex] & 0xFF;
							byteIndex++;

							// 1-byte sequence (no continuation bytes)
							if ((byte1 & 0x80) == 0) {
								return byte1;
							}

							// 2-byte sequence
							if ((byte1 & 0xE0) == 0xC0) {
								var byte2 = readContinuationByte();
								codePoint = (byte1 & 0x1F) << 6 | byte2;
								if (codePoint >= 0x80) {
									return codePoint;
								} else {
									throw Error('Invalid continuation byte');
								}
							}

							// 3-byte sequence (may include unpaired surrogates)
							if ((byte1 & 0xF0) == 0xE0) {
								byte2 = readContinuationByte();
								byte3 = readContinuationByte();
								codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;
								if (codePoint >= 0x0800) {
									checkScalarValue(codePoint);
									return codePoint;
								} else {
									throw Error('Invalid continuation byte');
								}
							}

							// 4-byte sequence
							if ((byte1 & 0xF8) == 0xF0) {
								byte2 = readContinuationByte();
								byte3 = readContinuationByte();
								byte4 = readContinuationByte();
								codePoint = (byte1 & 0x0F) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
								if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
									return codePoint;
								}
							}

							throw Error('Invalid UTF-8 detected');
						}

						var byteArray;
						var byteCount;
						var byteIndex;
						function utf8decode(byteString) {
							byteArray = ucs2decode(byteString);
							byteCount = byteArray.length;
							byteIndex = 0;
							var codePoints = [];
							var tmp;
							while ((tmp = decodeSymbol()) !== false) {
								codePoints.push(tmp);
							}
							return ucs2encode(codePoints);
						}

						/*--------------------------------------------------------------------------*/

						var utf8 = {
							'version': '2.0.0',
							'encode': utf8encode,
							'decode': utf8decode
						};

						// Some AMD build optimizers, like r.js, check for specific condition patterns
						// like the following:
						if (typeof define == 'function' && _typeof(define.amd) == 'object' && define.amd) {
							define(function () {
								return utf8;
							});
						} else if (freeExports && !freeExports.nodeType) {
							if (freeModule) {
								// in Node.js or RingoJS v0.8.0+
								freeModule.exports = utf8;
							} else {
								// in Narwhal or RingoJS v0.7.0-
								var object = {};
								var hasOwnProperty = object.hasOwnProperty;
								for (var key in utf8) {
									hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
								}
							}
						} else {
							// in Rhino or a web browser
							root.utf8 = utf8;
						}
					})(this);
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, {}], 30: [function (_dereq_, module, exports) {
				'use strict';

				var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
				    length = 64,
				    map = {},
				    seed = 0,
				    i = 0,
				    prev;

				/**
     * Return a string representing the specified number.
     *
     * @param {Number} num The number to convert.
     * @returns {String} The string representation of the number.
     * @api public
     */
				function encode(num) {
					var encoded = '';

					do {
						encoded = alphabet[num % length] + encoded;
						num = Math.floor(num / length);
					} while (num > 0);

					return encoded;
				}

				/**
     * Return the integer value specified by the given string.
     *
     * @param {String} str The string to convert.
     * @returns {Number} The integer value represented by the string.
     * @api public
     */
				function decode(str) {
					var decoded = 0;

					for (i = 0; i < str.length; i++) {
						decoded = decoded * length + map[str.charAt(i)];
					}

					return decoded;
				}

				/**
     * Yeast: A tiny growing id generator.
     *
     * @returns {String} A unique id.
     * @api public
     */
				function yeast() {
					var now = encode(+new Date());

					if (now !== prev) return seed = 0, prev = now;
					return now + '.' + encode(seed++);
				}

				//
				// Map each character to its index.
				//
				for (; i < length; i++) {
					map[alphabet[i]] = i;
				} //
				// Expose the `yeast`, `encode` and `decode` functions.
				//
				yeast.encode = encode;
				yeast.decode = decode;
				module.exports = yeast;
			}, {}], 31: [function (_dereq_, module, exports) {

				/**
     * Module dependencies.
     */

				var url = _dereq_('./url');
				var parser = _dereq_('socket.io-parser');
				var Manager = _dereq_('./manager');
				var debug = _dereq_('debug')('socket.io-client');

				/**
     * Module exports.
     */

				module.exports = exports = lookup;

				/**
     * Managers cache.
     */

				var cache = exports.managers = {};

				/**
     * Looks up an existing `Manager` for multiplexing.
     * If the user summons:
     *
     *   `io('http://localhost/a');`
     *   `io('http://localhost/b');`
     *
     * We reuse the existing instance based on same scheme/port/host,
     * and we initialize sockets for each namespace.
     *
     * @api public
     */

				function lookup(uri, opts) {
					if ((typeof uri === "undefined" ? "undefined" : _typeof(uri)) == 'object') {
						opts = uri;
						uri = undefined;
					}

					opts = opts || {};

					var parsed = url(uri);
					var source = parsed.source;
					var id = parsed.id;
					var path = parsed.path;
					var sameNamespace = cache[id] && path in cache[id].nsps;
					var newConnection = opts.forceNew || opts['force new connection'] || false === opts.multiplex || sameNamespace;

					var io;

					if (newConnection) {
						debug('ignoring socket cache for %s', source);
						io = Manager(source, opts);
					} else {
						if (!cache[id]) {
							debug('new io instance for %s', source);
							cache[id] = Manager(source, opts);
						}
						io = cache[id];
					}

					return io.socket(parsed.path);
				}

				/**
     * Protocol version.
     *
     * @api public
     */

				exports.protocol = parser.protocol;

				/**
     * `connect`.
     *
     * @param {String} uri
     * @api public
     */

				exports.connect = lookup;

				/**
     * Expose constructors for standalone build.
     *
     * @api public
     */

				exports.Manager = _dereq_('./manager');
				exports.Socket = _dereq_('./socket');
			}, { "./manager": 32, "./socket": 34, "./url": 35, "debug": 39, "socket.io-parser": 47 }], 32: [function (_dereq_, module, exports) {

				/**
     * Module dependencies.
     */

				var eio = _dereq_('engine.io-client');
				var Socket = _dereq_('./socket');
				var Emitter = _dereq_('component-emitter');
				var parser = _dereq_('socket.io-parser');
				var on = _dereq_('./on');
				var bind = _dereq_('component-bind');
				var debug = _dereq_('debug')('socket.io-client:manager');
				var indexOf = _dereq_('indexof');
				var Backoff = _dereq_('backo2');

				/**
     * IE6+ hasOwnProperty
     */

				var has = Object.prototype.hasOwnProperty;

				/**
     * Module exports
     */

				module.exports = Manager;

				/**
     * `Manager` constructor.
     *
     * @param {String} engine instance or engine uri/opts
     * @param {Object} options
     * @api public
     */

				function Manager(uri, opts) {
					if (!(this instanceof Manager)) return new Manager(uri, opts);
					if (uri && 'object' == (typeof uri === "undefined" ? "undefined" : _typeof(uri))) {
						opts = uri;
						uri = undefined;
					}
					opts = opts || {};

					opts.path = opts.path || '/socket.io';
					this.nsps = {};
					this.subs = [];
					this.opts = opts;
					this.reconnection(opts.reconnection !== false);
					this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
					this.reconnectionDelay(opts.reconnectionDelay || 1000);
					this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
					this.randomizationFactor(opts.randomizationFactor || 0.5);
					this.backoff = new Backoff({
						min: this.reconnectionDelay(),
						max: this.reconnectionDelayMax(),
						jitter: this.randomizationFactor()
					});
					this.timeout(null == opts.timeout ? 20000 : opts.timeout);
					this.readyState = 'closed';
					this.uri = uri;
					this.connecting = [];
					this.lastPing = null;
					this.encoding = false;
					this.packetBuffer = [];
					this.encoder = new parser.Encoder();
					this.decoder = new parser.Decoder();
					this.autoConnect = opts.autoConnect !== false;
					if (this.autoConnect) this.open();
				}

				/**
     * Propagate given event to sockets and emit on `this`
     *
     * @api private
     */

				Manager.prototype.emitAll = function () {
					this.emit.apply(this, arguments);
					for (var nsp in this.nsps) {
						if (has.call(this.nsps, nsp)) {
							this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
						}
					}
				};

				/**
     * Update `socket.id` of all sockets
     *
     * @api private
     */

				Manager.prototype.updateSocketIds = function () {
					for (var nsp in this.nsps) {
						if (has.call(this.nsps, nsp)) {
							this.nsps[nsp].id = this.engine.id;
						}
					}
				};

				/**
     * Mix in `Emitter`.
     */

				Emitter(Manager.prototype);

				/**
     * Sets the `reconnection` config.
     *
     * @param {Boolean} true/false if it should automatically reconnect
     * @return {Manager} self or value
     * @api public
     */

				Manager.prototype.reconnection = function (v) {
					if (!arguments.length) return this._reconnection;
					this._reconnection = !!v;
					return this;
				};

				/**
     * Sets the reconnection attempts config.
     *
     * @param {Number} max reconnection attempts before giving up
     * @return {Manager} self or value
     * @api public
     */

				Manager.prototype.reconnectionAttempts = function (v) {
					if (!arguments.length) return this._reconnectionAttempts;
					this._reconnectionAttempts = v;
					return this;
				};

				/**
     * Sets the delay between reconnections.
     *
     * @param {Number} delay
     * @return {Manager} self or value
     * @api public
     */

				Manager.prototype.reconnectionDelay = function (v) {
					if (!arguments.length) return this._reconnectionDelay;
					this._reconnectionDelay = v;
					this.backoff && this.backoff.setMin(v);
					return this;
				};

				Manager.prototype.randomizationFactor = function (v) {
					if (!arguments.length) return this._randomizationFactor;
					this._randomizationFactor = v;
					this.backoff && this.backoff.setJitter(v);
					return this;
				};

				/**
     * Sets the maximum delay between reconnections.
     *
     * @param {Number} delay
     * @return {Manager} self or value
     * @api public
     */

				Manager.prototype.reconnectionDelayMax = function (v) {
					if (!arguments.length) return this._reconnectionDelayMax;
					this._reconnectionDelayMax = v;
					this.backoff && this.backoff.setMax(v);
					return this;
				};

				/**
     * Sets the connection timeout. `false` to disable
     *
     * @return {Manager} self or value
     * @api public
     */

				Manager.prototype.timeout = function (v) {
					if (!arguments.length) return this._timeout;
					this._timeout = v;
					return this;
				};

				/**
     * Starts trying to reconnect if reconnection is enabled and we have not
     * started reconnecting yet
     *
     * @api private
     */

				Manager.prototype.maybeReconnectOnOpen = function () {
					// Only try to reconnect if it's the first time we're connecting
					if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
						// keeps reconnection from firing twice for the same reconnection loop
						this.reconnect();
					}
				};

				/**
     * Sets the current transport `socket`.
     *
     * @param {Function} optional, callback
     * @return {Manager} self
     * @api public
     */

				Manager.prototype.open = Manager.prototype.connect = function (fn) {
					debug('readyState %s', this.readyState);
					if (~this.readyState.indexOf('open')) return this;

					debug('opening %s', this.uri);
					this.engine = eio(this.uri, this.opts);
					var socket = this.engine;
					var self = this;
					this.readyState = 'opening';
					this.skipReconnect = false;

					// emit `open`
					var openSub = on(socket, 'open', function () {
						self.onopen();
						fn && fn();
					});

					// emit `connect_error`
					var errorSub = on(socket, 'error', function (data) {
						debug('connect_error');
						self.cleanup();
						self.readyState = 'closed';
						self.emitAll('connect_error', data);
						if (fn) {
							var err = new Error('Connection error');
							err.data = data;
							fn(err);
						} else {
							// Only do this if there is no fn to handle the error
							self.maybeReconnectOnOpen();
						}
					});

					// emit `connect_timeout`
					if (false !== this._timeout) {
						var timeout = this._timeout;
						debug('connect attempt will timeout after %d', timeout);

						// set timer
						var timer = setTimeout(function () {
							debug('connect attempt timed out after %d', timeout);
							openSub.destroy();
							socket.close();
							socket.emit('error', 'timeout');
							self.emitAll('connect_timeout', timeout);
						}, timeout);

						this.subs.push({
							destroy: function destroy() {
								clearTimeout(timer);
							}
						});
					}

					this.subs.push(openSub);
					this.subs.push(errorSub);

					return this;
				};

				/**
     * Called upon transport open.
     *
     * @api private
     */

				Manager.prototype.onopen = function () {
					debug('open');

					// clear old subs
					this.cleanup();

					// mark as open
					this.readyState = 'open';
					this.emit('open');

					// add new subs
					var socket = this.engine;
					this.subs.push(on(socket, 'data', bind(this, 'ondata')));
					this.subs.push(on(socket, 'ping', bind(this, 'onping')));
					this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
					this.subs.push(on(socket, 'error', bind(this, 'onerror')));
					this.subs.push(on(socket, 'close', bind(this, 'onclose')));
					this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
				};

				/**
     * Called upon a ping.
     *
     * @api private
     */

				Manager.prototype.onping = function () {
					this.lastPing = new Date();
					this.emitAll('ping');
				};

				/**
     * Called upon a packet.
     *
     * @api private
     */

				Manager.prototype.onpong = function () {
					this.emitAll('pong', new Date() - this.lastPing);
				};

				/**
     * Called with data.
     *
     * @api private
     */

				Manager.prototype.ondata = function (data) {
					this.decoder.add(data);
				};

				/**
     * Called when parser fully decodes a packet.
     *
     * @api private
     */

				Manager.prototype.ondecoded = function (packet) {
					this.emit('packet', packet);
				};

				/**
     * Called upon socket error.
     *
     * @api private
     */

				Manager.prototype.onerror = function (err) {
					debug('error', err);
					this.emitAll('error', err);
				};

				/**
     * Creates a new socket for the given `nsp`.
     *
     * @return {Socket}
     * @api public
     */

				Manager.prototype.socket = function (nsp) {
					var socket = this.nsps[nsp];
					if (!socket) {
						socket = new Socket(this, nsp);
						this.nsps[nsp] = socket;
						var self = this;
						socket.on('connecting', onConnecting);
						socket.on('connect', function () {
							socket.id = self.engine.id;
						});

						if (this.autoConnect) {
							// manually call here since connecting evnet is fired before listening
							onConnecting();
						}
					}

					function onConnecting() {
						if (!~indexOf(self.connecting, socket)) {
							self.connecting.push(socket);
						}
					}

					return socket;
				};

				/**
     * Called upon a socket close.
     *
     * @param {Socket} socket
     */

				Manager.prototype.destroy = function (socket) {
					var index = indexOf(this.connecting, socket);
					if (~index) this.connecting.splice(index, 1);
					if (this.connecting.length) return;

					this.close();
				};

				/**
     * Writes a packet.
     *
     * @param {Object} packet
     * @api private
     */

				Manager.prototype.packet = function (packet) {
					debug('writing packet %j', packet);
					var self = this;

					if (!self.encoding) {
						// encode, then write to engine with result
						self.encoding = true;
						this.encoder.encode(packet, function (encodedPackets) {
							for (var i = 0; i < encodedPackets.length; i++) {
								self.engine.write(encodedPackets[i], packet.options);
							}
							self.encoding = false;
							self.processPacketQueue();
						});
					} else {
						// add packet to the queue
						self.packetBuffer.push(packet);
					}
				};

				/**
     * If packet buffer is non-empty, begins encoding the
     * next packet in line.
     *
     * @api private
     */

				Manager.prototype.processPacketQueue = function () {
					if (this.packetBuffer.length > 0 && !this.encoding) {
						var pack = this.packetBuffer.shift();
						this.packet(pack);
					}
				};

				/**
     * Clean up transport subscriptions and packet buffer.
     *
     * @api private
     */

				Manager.prototype.cleanup = function () {
					debug('cleanup');

					var sub;
					while (sub = this.subs.shift()) {
						sub.destroy();
					}this.packetBuffer = [];
					this.encoding = false;
					this.lastPing = null;

					this.decoder.destroy();
				};

				/**
     * Close the current socket.
     *
     * @api private
     */

				Manager.prototype.close = Manager.prototype.disconnect = function () {
					debug('disconnect');
					this.skipReconnect = true;
					this.reconnecting = false;
					if ('opening' == this.readyState) {
						// `onclose` will not fire because
						// an open event never happened
						this.cleanup();
					}
					this.backoff.reset();
					this.readyState = 'closed';
					if (this.engine) this.engine.close();
				};

				/**
     * Called upon engine close.
     *
     * @api private
     */

				Manager.prototype.onclose = function (reason) {
					debug('onclose');

					this.cleanup();
					this.backoff.reset();
					this.readyState = 'closed';
					this.emit('close', reason);

					if (this._reconnection && !this.skipReconnect) {
						this.reconnect();
					}
				};

				/**
     * Attempt a reconnection.
     *
     * @api private
     */

				Manager.prototype.reconnect = function () {
					if (this.reconnecting || this.skipReconnect) return this;

					var self = this;

					if (this.backoff.attempts >= this._reconnectionAttempts) {
						debug('reconnect failed');
						this.backoff.reset();
						this.emitAll('reconnect_failed');
						this.reconnecting = false;
					} else {
						var delay = this.backoff.duration();
						debug('will wait %dms before reconnect attempt', delay);

						this.reconnecting = true;
						var timer = setTimeout(function () {
							if (self.skipReconnect) return;

							debug('attempting reconnect');
							self.emitAll('reconnect_attempt', self.backoff.attempts);
							self.emitAll('reconnecting', self.backoff.attempts);

							// check again for the case socket closed in above events
							if (self.skipReconnect) return;

							self.open(function (err) {
								if (err) {
									debug('reconnect attempt error');
									self.reconnecting = false;
									self.reconnect();
									self.emitAll('reconnect_error', err.data);
								} else {
									debug('reconnect success');
									self.onreconnect();
								}
							});
						}, delay);

						this.subs.push({
							destroy: function destroy() {
								clearTimeout(timer);
							}
						});
					}
				};

				/**
     * Called upon successful reconnect.
     *
     * @api private
     */

				Manager.prototype.onreconnect = function () {
					var attempt = this.backoff.attempts;
					this.reconnecting = false;
					this.backoff.reset();
					this.updateSocketIds();
					this.emitAll('reconnect', attempt);
				};
			}, { "./on": 33, "./socket": 34, "backo2": 36, "component-bind": 37, "component-emitter": 38, "debug": 39, "engine.io-client": 1, "indexof": 42, "socket.io-parser": 47 }], 33: [function (_dereq_, module, exports) {

				/**
     * Module exports.
     */

				module.exports = on;

				/**
     * Helper for subscriptions.
     *
     * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
     * @param {String} event name
     * @param {Function} callback
     * @api public
     */

				function on(obj, ev, fn) {
					obj.on(ev, fn);
					return {
						destroy: function destroy() {
							obj.removeListener(ev, fn);
						}
					};
				}
			}, {}], 34: [function (_dereq_, module, exports) {

				/**
     * Module dependencies.
     */

				var parser = _dereq_('socket.io-parser');
				var Emitter = _dereq_('component-emitter');
				var toArray = _dereq_('to-array');
				var on = _dereq_('./on');
				var bind = _dereq_('component-bind');
				var debug = _dereq_('debug')('socket.io-client:socket');
				var hasBin = _dereq_('has-binary');

				/**
     * Module exports.
     */

				module.exports = exports = Socket;

				/**
     * Internal events (blacklisted).
     * These events can't be emitted by the user.
     *
     * @api private
     */

				var events = {
					connect: 1,
					connect_error: 1,
					connect_timeout: 1,
					connecting: 1,
					disconnect: 1,
					error: 1,
					reconnect: 1,
					reconnect_attempt: 1,
					reconnect_failed: 1,
					reconnect_error: 1,
					reconnecting: 1,
					ping: 1,
					pong: 1
				};

				/**
     * Shortcut to `Emitter#emit`.
     */

				var emit = Emitter.prototype.emit;

				/**
     * `Socket` constructor.
     *
     * @api public
     */

				function Socket(io, nsp) {
					this.io = io;
					this.nsp = nsp;
					this.json = this; // compat
					this.ids = 0;
					this.acks = {};
					this.receiveBuffer = [];
					this.sendBuffer = [];
					this.connected = false;
					this.disconnected = true;
					if (this.io.autoConnect) this.open();
				}

				/**
     * Mix in `Emitter`.
     */

				Emitter(Socket.prototype);

				/**
     * Subscribe to open, close and packet events
     *
     * @api private
     */

				Socket.prototype.subEvents = function () {
					if (this.subs) return;

					var io = this.io;
					this.subs = [on(io, 'open', bind(this, 'onopen')), on(io, 'packet', bind(this, 'onpacket')), on(io, 'close', bind(this, 'onclose'))];
				};

				/**
     * "Opens" the socket.
     *
     * @api public
     */

				Socket.prototype.open = Socket.prototype.connect = function () {
					if (this.connected) return this;

					this.subEvents();
					this.io.open(); // ensure open
					if ('open' == this.io.readyState) this.onopen();
					this.emit('connecting');
					return this;
				};

				/**
     * Sends a `message` event.
     *
     * @return {Socket} self
     * @api public
     */

				Socket.prototype.send = function () {
					var args = toArray(arguments);
					args.unshift('message');
					this.emit.apply(this, args);
					return this;
				};

				/**
     * Override `emit`.
     * If the event is in `events`, it's emitted normally.
     *
     * @param {String} event name
     * @return {Socket} self
     * @api public
     */

				Socket.prototype.emit = function (ev) {
					if (events.hasOwnProperty(ev)) {
						emit.apply(this, arguments);
						return this;
					}

					var args = toArray(arguments);
					var parserType = parser.EVENT; // default
					if (hasBin(args)) {
						parserType = parser.BINARY_EVENT;
					} // binary
					var packet = { type: parserType, data: args };

					packet.options = {};
					packet.options.compress = !this.flags || false !== this.flags.compress;

					// event ack callback
					if ('function' == typeof args[args.length - 1]) {
						debug('emitting packet with ack id %d', this.ids);
						this.acks[this.ids] = args.pop();
						packet.id = this.ids++;
					}

					if (this.connected) {
						this.packet(packet);
					} else {
						this.sendBuffer.push(packet);
					}

					delete this.flags;

					return this;
				};

				/**
     * Sends a packet.
     *
     * @param {Object} packet
     * @api private
     */

				Socket.prototype.packet = function (packet) {
					packet.nsp = this.nsp;
					this.io.packet(packet);
				};

				/**
     * Called upon engine `open`.
     *
     * @api private
     */

				Socket.prototype.onopen = function () {
					debug('transport is open - connecting');

					// write connect packet if necessary
					if ('/' != this.nsp) {
						this.packet({ type: parser.CONNECT });
					}
				};

				/**
     * Called upon engine `close`.
     *
     * @param {String} reason
     * @api private
     */

				Socket.prototype.onclose = function (reason) {
					debug('close (%s)', reason);
					this.connected = false;
					this.disconnected = true;
					delete this.id;
					this.emit('disconnect', reason);
				};

				/**
     * Called with socket packet.
     *
     * @param {Object} packet
     * @api private
     */

				Socket.prototype.onpacket = function (packet) {
					if (packet.nsp != this.nsp) return;

					switch (packet.type) {
						case parser.CONNECT:
							this.onconnect();
							break;

						case parser.EVENT:
							this.onevent(packet);
							break;

						case parser.BINARY_EVENT:
							this.onevent(packet);
							break;

						case parser.ACK:
							this.onack(packet);
							break;

						case parser.BINARY_ACK:
							this.onack(packet);
							break;

						case parser.DISCONNECT:
							this.ondisconnect();
							break;

						case parser.ERROR:
							this.emit('error', packet.data);
							break;
					}
				};

				/**
     * Called upon a server event.
     *
     * @param {Object} packet
     * @api private
     */

				Socket.prototype.onevent = function (packet) {
					var args = packet.data || [];
					debug('emitting event %j', args);

					if (null != packet.id) {
						debug('attaching ack callback to event');
						args.push(this.ack(packet.id));
					}

					if (this.connected) {
						emit.apply(this, args);
					} else {
						this.receiveBuffer.push(args);
					}
				};

				/**
     * Produces an ack callback to emit with an event.
     *
     * @api private
     */

				Socket.prototype.ack = function (id) {
					var self = this;
					var sent = false;
					return function () {
						// prevent double callbacks
						if (sent) return;
						sent = true;
						var args = toArray(arguments);
						debug('sending ack %j', args);

						var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
						self.packet({
							type: type,
							id: id,
							data: args
						});
					};
				};

				/**
     * Called upon a server acknowlegement.
     *
     * @param {Object} packet
     * @api private
     */

				Socket.prototype.onack = function (packet) {
					var ack = this.acks[packet.id];
					if ('function' == typeof ack) {
						debug('calling ack %s with %j', packet.id, packet.data);
						ack.apply(this, packet.data);
						delete this.acks[packet.id];
					} else {
						debug('bad ack %s', packet.id);
					}
				};

				/**
     * Called upon server connect.
     *
     * @api private
     */

				Socket.prototype.onconnect = function () {
					this.connected = true;
					this.disconnected = false;
					this.emit('connect');
					this.emitBuffered();
				};

				/**
     * Emit buffered events (received and emitted).
     *
     * @api private
     */

				Socket.prototype.emitBuffered = function () {
					var i;
					for (i = 0; i < this.receiveBuffer.length; i++) {
						emit.apply(this, this.receiveBuffer[i]);
					}
					this.receiveBuffer = [];

					for (i = 0; i < this.sendBuffer.length; i++) {
						this.packet(this.sendBuffer[i]);
					}
					this.sendBuffer = [];
				};

				/**
     * Called upon server disconnect.
     *
     * @api private
     */

				Socket.prototype.ondisconnect = function () {
					debug('server disconnect (%s)', this.nsp);
					this.destroy();
					this.onclose('io server disconnect');
				};

				/**
     * Called upon forced client/server side disconnections,
     * this method ensures the manager stops tracking us and
     * that reconnections don't get triggered for this.
     *
     * @api private.
     */

				Socket.prototype.destroy = function () {
					if (this.subs) {
						// clean subscriptions to avoid reconnections
						for (var i = 0; i < this.subs.length; i++) {
							this.subs[i].destroy();
						}
						this.subs = null;
					}

					this.io.destroy(this);
				};

				/**
     * Disconnects the socket manually.
     *
     * @return {Socket} self
     * @api public
     */

				Socket.prototype.close = Socket.prototype.disconnect = function () {
					if (this.connected) {
						debug('performing disconnect (%s)', this.nsp);
						this.packet({ type: parser.DISCONNECT });
					}

					// remove socket from pool
					this.destroy();

					if (this.connected) {
						// fire events
						this.onclose('io client disconnect');
					}
					return this;
				};

				/**
     * Sets the compress flag.
     *
     * @param {Boolean} if `true`, compresses the sending data
     * @return {Socket} self
     * @api public
     */

				Socket.prototype.compress = function (compress) {
					this.flags = this.flags || {};
					this.flags.compress = compress;
					return this;
				};
			}, { "./on": 33, "component-bind": 37, "component-emitter": 38, "debug": 39, "has-binary": 41, "socket.io-parser": 47, "to-array": 51 }], 35: [function (_dereq_, module, exports) {
				(function (global) {

					/**
      * Module dependencies.
      */

					var parseuri = _dereq_('parseuri');
					var debug = _dereq_('debug')('socket.io-client:url');

					/**
      * Module exports.
      */

					module.exports = url;

					/**
      * URL parser.
      *
      * @param {String} url
      * @param {Object} An object meant to mimic window.location.
      *                 Defaults to window.location.
      * @api public
      */

					function url(uri, loc) {
						var obj = uri;

						// default to window.location
						var loc = loc || global.location;
						if (null == uri) uri = loc.protocol + '//' + loc.host;

						// relative path support
						if ('string' == typeof uri) {
							if ('/' == uri.charAt(0)) {
								if ('/' == uri.charAt(1)) {
									uri = loc.protocol + uri;
								} else {
									uri = loc.host + uri;
								}
							}

							if (!/^(https?|wss?):\/\//.test(uri)) {
								debug('protocol-less url %s', uri);
								if ('undefined' != typeof loc) {
									uri = loc.protocol + '//' + uri;
								} else {
									uri = 'https://' + uri;
								}
							}

							// parse
							debug('parse %s', uri);
							obj = parseuri(uri);
						}

						// make sure we treat `localhost:80` and `localhost` equally
						if (!obj.port) {
							if (/^(http|ws)$/.test(obj.protocol)) {
								obj.port = '80';
							} else if (/^(http|ws)s$/.test(obj.protocol)) {
								obj.port = '443';
							}
						}

						obj.path = obj.path || '/';

						var ipv6 = obj.host.indexOf(':') !== -1;
						var host = ipv6 ? '[' + obj.host + ']' : obj.host;

						// define unique id
						obj.id = obj.protocol + '://' + host + ':' + obj.port;
						// define href
						obj.href = obj.protocol + '://' + host + (loc && loc.port == obj.port ? '' : ':' + obj.port);

						return obj;
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "debug": 39, "parseuri": 45 }], 36: [function (_dereq_, module, exports) {

				/**
     * Expose `Backoff`.
     */

				module.exports = Backoff;

				/**
     * Initialize backoff timer with `opts`.
     *
     * - `min` initial timeout in milliseconds [100]
     * - `max` max timeout [10000]
     * - `jitter` [0]
     * - `factor` [2]
     *
     * @param {Object} opts
     * @api public
     */

				function Backoff(opts) {
					opts = opts || {};
					this.ms = opts.min || 100;
					this.max = opts.max || 10000;
					this.factor = opts.factor || 2;
					this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
					this.attempts = 0;
				}

				/**
     * Return the backoff duration.
     *
     * @return {Number}
     * @api public
     */

				Backoff.prototype.duration = function () {
					var ms = this.ms * Math.pow(this.factor, this.attempts++);
					if (this.jitter) {
						var rand = Math.random();
						var deviation = Math.floor(rand * this.jitter * ms);
						ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
					}
					return Math.min(ms, this.max) | 0;
				};

				/**
     * Reset the number of attempts.
     *
     * @api public
     */

				Backoff.prototype.reset = function () {
					this.attempts = 0;
				};

				/**
     * Set the minimum duration
     *
     * @api public
     */

				Backoff.prototype.setMin = function (min) {
					this.ms = min;
				};

				/**
     * Set the maximum duration
     *
     * @api public
     */

				Backoff.prototype.setMax = function (max) {
					this.max = max;
				};

				/**
     * Set the jitter
     *
     * @api public
     */

				Backoff.prototype.setJitter = function (jitter) {
					this.jitter = jitter;
				};
			}, {}], 37: [function (_dereq_, module, exports) {
				/**
     * Slice reference.
     */

				var slice = [].slice;

				/**
     * Bind `obj` to `fn`.
     *
     * @param {Object} obj
     * @param {Function|String} fn or string
     * @return {Function}
     * @api public
     */

				module.exports = function (obj, fn) {
					if ('string' == typeof fn) fn = obj[fn];
					if ('function' != typeof fn) throw new Error('bind() requires a function');
					var args = slice.call(arguments, 2);
					return function () {
						return fn.apply(obj, args.concat(slice.call(arguments)));
					};
				};
			}, {}], 38: [function (_dereq_, module, exports) {

				/**
     * Expose `Emitter`.
     */

				module.exports = Emitter;

				/**
     * Initialize a new `Emitter`.
     *
     * @api public
     */

				function Emitter(obj) {
					if (obj) return mixin(obj);
				};

				/**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

				function mixin(obj) {
					for (var key in Emitter.prototype) {
						obj[key] = Emitter.prototype[key];
					}
					return obj;
				}

				/**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
					this._callbacks = this._callbacks || {};
					(this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
					return this;
				};

				/**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.once = function (event, fn) {
					function on() {
						this.off(event, on);
						fn.apply(this, arguments);
					}

					on.fn = fn;
					this.on(event, on);
					return this;
				};

				/**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

				Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
					this._callbacks = this._callbacks || {};

					// all
					if (0 == arguments.length) {
						this._callbacks = {};
						return this;
					}

					// specific event
					var callbacks = this._callbacks['$' + event];
					if (!callbacks) return this;

					// remove all handlers
					if (1 == arguments.length) {
						delete this._callbacks['$' + event];
						return this;
					}

					// remove specific handler
					var cb;
					for (var i = 0; i < callbacks.length; i++) {
						cb = callbacks[i];
						if (cb === fn || cb.fn === fn) {
							callbacks.splice(i, 1);
							break;
						}
					}
					return this;
				};

				/**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */

				Emitter.prototype.emit = function (event) {
					this._callbacks = this._callbacks || {};
					var args = [].slice.call(arguments, 1),
					    callbacks = this._callbacks['$' + event];

					if (callbacks) {
						callbacks = callbacks.slice(0);
						for (var i = 0, len = callbacks.length; i < len; ++i) {
							callbacks[i].apply(this, args);
						}
					}

					return this;
				};

				/**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */

				Emitter.prototype.listeners = function (event) {
					this._callbacks = this._callbacks || {};
					return this._callbacks['$' + event] || [];
				};

				/**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */

				Emitter.prototype.hasListeners = function (event) {
					return !!this.listeners(event).length;
				};
			}, {}], 39: [function (_dereq_, module, exports) {
				arguments[4][17][0].apply(exports, arguments);
			}, { "./debug": 40, "dup": 17 }], 40: [function (_dereq_, module, exports) {
				arguments[4][18][0].apply(exports, arguments);
			}, { "dup": 18, "ms": 44 }], 41: [function (_dereq_, module, exports) {
				(function (global) {

					/*
      * Module requirements.
      */

					var isArray = _dereq_('isarray');

					/**
      * Module exports.
      */

					module.exports = hasBinary;

					/**
      * Checks for binary data.
      *
      * Right now only Buffer and ArrayBuffer are supported..
      *
      * @param {Object} anything
      * @api public
      */

					function hasBinary(data) {

						function _hasBinary(obj) {
							if (!obj) return false;

							if (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer || global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
								return true;
							}

							if (isArray(obj)) {
								for (var i = 0; i < obj.length; i++) {
									if (_hasBinary(obj[i])) {
										return true;
									}
								}
							} else if (obj && 'object' == (typeof obj === "undefined" ? "undefined" : _typeof(obj))) {
								// see: https://github.com/Automattic/has-binary/pull/4
								if (obj.toJSON && 'function' == typeof obj.toJSON) {
									obj = obj.toJSON();
								}

								for (var key in obj) {
									if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
										return true;
									}
								}
							}

							return false;
						}

						return _hasBinary(data);
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "isarray": 43 }], 42: [function (_dereq_, module, exports) {
				arguments[4][23][0].apply(exports, arguments);
			}, { "dup": 23 }], 43: [function (_dereq_, module, exports) {
				arguments[4][24][0].apply(exports, arguments);
			}, { "dup": 24 }], 44: [function (_dereq_, module, exports) {
				arguments[4][25][0].apply(exports, arguments);
			}, { "dup": 25 }], 45: [function (_dereq_, module, exports) {
				arguments[4][28][0].apply(exports, arguments);
			}, { "dup": 28 }], 46: [function (_dereq_, module, exports) {
				(function (global) {
					/*global Blob,File*/

					/**
      * Module requirements
      */

					var isArray = _dereq_('isarray');
					var isBuf = _dereq_('./is-buffer');

					/**
      * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
      * Anything with blobs or files should be fed through removeBlobs before coming
      * here.
      *
      * @param {Object} packet - socket.io event packet
      * @return {Object} with deconstructed packet and list of buffers
      * @api public
      */

					exports.deconstructPacket = function (packet) {
						var buffers = [];
						var packetData = packet.data;

						function _deconstructPacket(data) {
							if (!data) return data;

							if (isBuf(data)) {
								var placeholder = { _placeholder: true, num: buffers.length };
								buffers.push(data);
								return placeholder;
							} else if (isArray(data)) {
								var newData = new Array(data.length);
								for (var i = 0; i < data.length; i++) {
									newData[i] = _deconstructPacket(data[i]);
								}
								return newData;
							} else if ('object' == (typeof data === "undefined" ? "undefined" : _typeof(data)) && !(data instanceof Date)) {
								var newData = {};
								for (var key in data) {
									newData[key] = _deconstructPacket(data[key]);
								}
								return newData;
							}
							return data;
						}

						var pack = packet;
						pack.data = _deconstructPacket(packetData);
						pack.attachments = buffers.length; // number of binary 'attachments'
						return { packet: pack, buffers: buffers };
					};

					/**
      * Reconstructs a binary packet from its placeholder packet and buffers
      *
      * @param {Object} packet - event packet with placeholders
      * @param {Array} buffers - binary buffers to put in placeholder positions
      * @return {Object} reconstructed packet
      * @api public
      */

					exports.reconstructPacket = function (packet, buffers) {
						var curPlaceHolder = 0;

						function _reconstructPacket(data) {
							if (data && data._placeholder) {
								var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
								return buf;
							} else if (isArray(data)) {
								for (var i = 0; i < data.length; i++) {
									data[i] = _reconstructPacket(data[i]);
								}
								return data;
							} else if (data && 'object' == (typeof data === "undefined" ? "undefined" : _typeof(data))) {
								for (var key in data) {
									data[key] = _reconstructPacket(data[key]);
								}
								return data;
							}
							return data;
						}

						packet.data = _reconstructPacket(packet.data);
						packet.attachments = undefined; // no longer useful
						return packet;
					};

					/**
      * Asynchronously removes Blobs or Files from data via
      * FileReader's readAsArrayBuffer method. Used before encoding
      * data as msgpack. Calls callback with the blobless data.
      *
      * @param {Object} data
      * @param {Function} callback
      * @api private
      */

					exports.removeBlobs = function (data, callback) {
						function _removeBlobs(obj, curKey, containingObject) {
							if (!obj) return obj;

							// convert any blob
							if (global.Blob && obj instanceof Blob || global.File && obj instanceof File) {
								pendingBlobs++;

								// async filereader
								var fileReader = new FileReader();
								fileReader.onload = function () {
									// this.result == arraybuffer
									if (containingObject) {
										containingObject[curKey] = this.result;
									} else {
										bloblessData = this.result;
									}

									// if nothing pending its callback time
									if (! --pendingBlobs) {
										callback(bloblessData);
									}
								};

								fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
							} else if (isArray(obj)) {
								// handle array
								for (var i = 0; i < obj.length; i++) {
									_removeBlobs(obj[i], i, obj);
								}
							} else if (obj && 'object' == (typeof obj === "undefined" ? "undefined" : _typeof(obj)) && !isBuf(obj)) {
								// and object
								for (var key in obj) {
									_removeBlobs(obj[key], key, obj);
								}
							}
						}

						var pendingBlobs = 0;
						var bloblessData = data;
						_removeBlobs(bloblessData);
						if (!pendingBlobs) {
							callback(bloblessData);
						}
					};
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, { "./is-buffer": 48, "isarray": 43 }], 47: [function (_dereq_, module, exports) {

				/**
     * Module dependencies.
     */

				var debug = _dereq_('debug')('socket.io-parser');
				var json = _dereq_('json3');
				var isArray = _dereq_('isarray');
				var Emitter = _dereq_('component-emitter');
				var binary = _dereq_('./binary');
				var isBuf = _dereq_('./is-buffer');

				/**
     * Protocol version.
     *
     * @api public
     */

				exports.protocol = 4;

				/**
     * Packet types.
     *
     * @api public
     */

				exports.types = ['CONNECT', 'DISCONNECT', 'EVENT', 'BINARY_EVENT', 'ACK', 'BINARY_ACK', 'ERROR'];

				/**
     * Packet type `connect`.
     *
     * @api public
     */

				exports.CONNECT = 0;

				/**
     * Packet type `disconnect`.
     *
     * @api public
     */

				exports.DISCONNECT = 1;

				/**
     * Packet type `event`.
     *
     * @api public
     */

				exports.EVENT = 2;

				/**
     * Packet type `ack`.
     *
     * @api public
     */

				exports.ACK = 3;

				/**
     * Packet type `error`.
     *
     * @api public
     */

				exports.ERROR = 4;

				/**
     * Packet type 'binary event'
     *
     * @api public
     */

				exports.BINARY_EVENT = 5;

				/**
     * Packet type `binary ack`. For acks with binary arguments.
     *
     * @api public
     */

				exports.BINARY_ACK = 6;

				/**
     * Encoder constructor.
     *
     * @api public
     */

				exports.Encoder = Encoder;

				/**
     * Decoder constructor.
     *
     * @api public
     */

				exports.Decoder = Decoder;

				/**
     * A socket.io Encoder instance
     *
     * @api public
     */

				function Encoder() {}

				/**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     * @param {Function} callback - function to handle encodings (likely engine.write)
     * @return Calls callback with Array of encodings
     * @api public
     */

				Encoder.prototype.encode = function (obj, callback) {
					debug('encoding packet %j', obj);

					if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
						encodeAsBinary(obj, callback);
					} else {
						var encoding = encodeAsString(obj);
						callback([encoding]);
					}
				};

				/**
     * Encode packet as string.
     *
     * @param {Object} packet
     * @return {String} encoded
     * @api private
     */

				function encodeAsString(obj) {
					var str = '';
					var nsp = false;

					// first is type
					str += obj.type;

					// attachments if we have them
					if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
						str += obj.attachments;
						str += '-';
					}

					// if we have a namespace other than `/`
					// we append it followed by a comma `,`
					if (obj.nsp && '/' != obj.nsp) {
						nsp = true;
						str += obj.nsp;
					}

					// immediately followed by the id
					if (null != obj.id) {
						if (nsp) {
							str += ',';
							nsp = false;
						}
						str += obj.id;
					}

					// json data
					if (null != obj.data) {
						if (nsp) str += ',';
						str += json.stringify(obj.data);
					}

					debug('encoded %j as %s', obj, str);
					return str;
				}

				/**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     *
     * @param {Object} packet
     * @return {Buffer} encoded
     * @api private
     */

				function encodeAsBinary(obj, callback) {

					function writeEncoding(bloblessData) {
						var deconstruction = binary.deconstructPacket(bloblessData);
						var pack = encodeAsString(deconstruction.packet);
						var buffers = deconstruction.buffers;

						buffers.unshift(pack); // add packet info to beginning of data list
						callback(buffers); // write all the buffers
					}

					binary.removeBlobs(obj, writeEncoding);
				}

				/**
     * A socket.io Decoder instance
     *
     * @return {Object} decoder
     * @api public
     */

				function Decoder() {
					this.reconstructor = null;
				}

				/**
     * Mix in `Emitter` with Decoder.
     */

				Emitter(Decoder.prototype);

				/**
     * Decodes an ecoded packet string into packet JSON.
     *
     * @param {String} obj - encoded packet
     * @return {Object} packet
     * @api public
     */

				Decoder.prototype.add = function (obj) {
					var packet;
					if ('string' == typeof obj) {
						packet = decodeString(obj);
						if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) {
							// binary packet's json
							this.reconstructor = new BinaryReconstructor(packet);

							// no attachments, labeled binary but no binary data to follow
							if (this.reconstructor.reconPack.attachments === 0) {
								this.emit('decoded', packet);
							}
						} else {
							// non-binary full packet
							this.emit('decoded', packet);
						}
					} else if (isBuf(obj) || obj.base64) {
						// raw binary data
						if (!this.reconstructor) {
							throw new Error('got binary data when not reconstructing a packet');
						} else {
							packet = this.reconstructor.takeBinaryData(obj);
							if (packet) {
								// received final buffer
								this.reconstructor = null;
								this.emit('decoded', packet);
							}
						}
					} else {
						throw new Error('Unknown type: ' + obj);
					}
				};

				/**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     * @api private
     */

				function decodeString(str) {
					var p = {};
					var i = 0;

					// look up type
					p.type = Number(str.charAt(0));
					if (null == exports.types[p.type]) return error();

					// look up attachments if type binary
					if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
						var buf = '';
						while (str.charAt(++i) != '-') {
							buf += str.charAt(i);
							if (i == str.length) break;
						}
						if (buf != Number(buf) || str.charAt(i) != '-') {
							throw new Error('Illegal attachments');
						}
						p.attachments = Number(buf);
					}

					// look up namespace (if any)
					if ('/' == str.charAt(i + 1)) {
						p.nsp = '';
						while (++i) {
							var c = str.charAt(i);
							if (',' == c) break;
							p.nsp += c;
							if (i == str.length) break;
						}
					} else {
						p.nsp = '/';
					}

					// look up id
					var next = str.charAt(i + 1);
					if ('' !== next && Number(next) == next) {
						p.id = '';
						while (++i) {
							var c = str.charAt(i);
							if (null == c || Number(c) != c) {
								--i;
								break;
							}
							p.id += str.charAt(i);
							if (i == str.length) break;
						}
						p.id = Number(p.id);
					}

					// look up json data
					if (str.charAt(++i)) {
						try {
							p.data = json.parse(str.substr(i));
						} catch (e) {
							return error();
						}
					}

					debug('decoded %s as %j', str, p);
					return p;
				}

				/**
     * Deallocates a parser's resources
     *
     * @api public
     */

				Decoder.prototype.destroy = function () {
					if (this.reconstructor) {
						this.reconstructor.finishedReconstruction();
					}
				};

				/**
     * A manager of a binary event's 'buffer sequence'. Should
     * be constructed whenever a packet of type BINARY_EVENT is
     * decoded.
     *
     * @param {Object} packet
     * @return {BinaryReconstructor} initialized reconstructor
     * @api private
     */

				function BinaryReconstructor(packet) {
					this.reconPack = packet;
					this.buffers = [];
				}

				/**
     * Method to be called when binary data received from connection
     * after a BINARY_EVENT packet.
     *
     * @param {Buffer | ArrayBuffer} binData - the raw binary data received
     * @return {null | Object} returns null if more binary data is expected or
     *   a reconstructed packet object if all buffers have been received.
     * @api private
     */

				BinaryReconstructor.prototype.takeBinaryData = function (binData) {
					this.buffers.push(binData);
					if (this.buffers.length == this.reconPack.attachments) {
						// done with buffer list
						var packet = binary.reconstructPacket(this.reconPack, this.buffers);
						this.finishedReconstruction();
						return packet;
					}
					return null;
				};

				/**
     * Cleans up binary packet reconstruction variables.
     *
     * @api private
     */

				BinaryReconstructor.prototype.finishedReconstruction = function () {
					this.reconPack = null;
					this.buffers = [];
				};

				function error(data) {
					return {
						type: exports.ERROR,
						data: 'parser error'
					};
				}
			}, { "./binary": 46, "./is-buffer": 48, "component-emitter": 49, "debug": 39, "isarray": 43, "json3": 50 }], 48: [function (_dereq_, module, exports) {
				(function (global) {

					module.exports = isBuf;

					/**
      * Returns true if obj is a buffer or an arraybuffer.
      *
      * @api private
      */

					function isBuf(obj) {
						return global.Buffer && global.Buffer.isBuffer(obj) || global.ArrayBuffer && obj instanceof ArrayBuffer;
					}
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, {}], 49: [function (_dereq_, module, exports) {
				arguments[4][15][0].apply(exports, arguments);
			}, { "dup": 15 }], 50: [function (_dereq_, module, exports) {
				(function (global) {
					/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
					;(function () {
						// Detect the `define` function exposed by asynchronous module loaders. The
						// strict `define` check is necessary for compatibility with `r.js`.
						var isLoader = typeof define === "function" && define.amd;

						// A set of types used to distinguish objects from primitives.
						var objectTypes = {
							"function": true,
							"object": true
						};

						// Detect the `exports` object exposed by CommonJS implementations.
						var freeExports = objectTypes[typeof exports === "undefined" ? "undefined" : _typeof(exports)] && exports && !exports.nodeType && exports;

						// Use the `global` object exposed by Node (including Browserify via
						// `insert-module-globals`), Narwhal, and Ringo as the default context,
						// and the `window` object in browsers. Rhino exports a `global` function
						// instead.
						var root = objectTypes[typeof window === "undefined" ? "undefined" : _typeof(window)] && window || this,
						    freeGlobal = freeExports && objectTypes[typeof module === "undefined" ? "undefined" : _typeof(module)] && module && !module.nodeType && (typeof global === "undefined" ? "undefined" : _typeof(global)) == "object" && global;

						if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
							root = freeGlobal;
						}

						// Public: Initializes JSON 3 using the given `context` object, attaching the
						// `stringify` and `parse` functions to the specified `exports` object.
						function runInContext(context, exports) {
							context || (context = root["Object"]());
							exports || (exports = root["Object"]());

							// Native constructor aliases.
							var Number = context["Number"] || root["Number"],
							    String = context["String"] || root["String"],
							    Object = context["Object"] || root["Object"],
							    Date = context["Date"] || root["Date"],
							    SyntaxError = context["SyntaxError"] || root["SyntaxError"],
							    TypeError = context["TypeError"] || root["TypeError"],
							    Math = context["Math"] || root["Math"],
							    nativeJSON = context["JSON"] || root["JSON"];

							// Delegate to the native `stringify` and `parse` implementations.
							if ((typeof nativeJSON === "undefined" ? "undefined" : _typeof(nativeJSON)) == "object" && nativeJSON) {
								exports.stringify = nativeJSON.stringify;
								exports.parse = nativeJSON.parse;
							}

							// Convenience aliases.
							var objectProto = Object.prototype,
							    getClass = objectProto.toString,
							    _isProperty,
							    _forEach,
							    undef;

							// Test the `Date#getUTC*` methods. Based on work by @Yaffle.
							var isExtended = new Date(-3509827334573292);
							try {
								// The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
								// results for certain dates in Opera >= 10.53.
								isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
								// Safari < 2.0.2 stores the internal millisecond time value correctly,
								// but clips the values returned by the date methods to the range of
								// signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
								isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
							} catch (exception) {}

							// Internal: Determines whether the native `JSON.stringify` and `parse`
							// implementations are spec-compliant. Based on work by Ken Snyder.
							function has(name) {
								if (has[name] !== undef) {
									// Return cached feature test result.
									return has[name];
								}
								var isSupported;
								if (name == "bug-string-char-index") {
									// IE <= 7 doesn't support accessing string characters using square
									// bracket notation. IE 8 only supports this for primitives.
									isSupported = "a"[0] != "a";
								} else if (name == "json") {
									// Indicates whether both `JSON.stringify` and `JSON.parse` are
									// supported.
									isSupported = has("json-stringify") && has("json-parse");
								} else {
									var value,
									    serialized = "{\"a\":[1,true,false,null,\"\\u0000\\b\\n\\f\\r\\t\"]}";
									// Test `JSON.stringify`.
									if (name == "json-stringify") {
										var stringify = exports.stringify,
										    stringifySupported = typeof stringify == "function" && isExtended;
										if (stringifySupported) {
											// A test function object with a custom `toJSON` method.
											(value = function value() {
												return 1;
											}).toJSON = value;
											try {
												stringifySupported =
												// Firefox 3.1b1 and b2 serialize string, number, and boolean
												// primitives as object literals.
												stringify(0) === "0" &&
												// FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
												// literals.
												stringify(new Number()) === "0" && stringify(new String()) == '""' &&
												// FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
												// does not define a canonical JSON representation (this applies to
												// objects with `toJSON` properties as well, *unless* they are nested
												// within an object or array).
												stringify(getClass) === undef &&
												// IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
												// FF 3.1b3 pass this test.
												stringify(undef) === undef &&
												// Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
												// respectively, if the value is omitted entirely.
												stringify() === undef &&
												// FF 3.1b1, 2 throw an error if the given value is not a number,
												// string, array, object, Boolean, or `null` literal. This applies to
												// objects with custom `toJSON` methods as well, unless they are nested
												// inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
												// methods entirely.
												stringify(value) === "1" && stringify([value]) == "[1]" &&
												// Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
												// `"[null]"`.
												stringify([undef]) == "[null]" &&
												// YUI 3.0.0b1 fails to serialize `null` literals.
												stringify(null) == "null" &&
												// FF 3.1b1, 2 halts serialization if an array contains a function:
												// `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
												// elides non-JSON values from objects and arrays, unless they
												// define custom `toJSON` methods.
												stringify([undef, getClass, null]) == "[null,null,null]" &&
												// Simple serialization test. FF 3.1b1 uses Unicode escape sequences
												// where character escape codes are expected (e.g., `\b` => `\u0008`).
												stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
												// FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
												stringify(null, value) === "1" && stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
												// JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
												// serialize extended years.
												stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
												// The milliseconds are optional in ES 5, but required in 5.1.
												stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
												// Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
												// four-digit years instead of six-digit years. Credits: @Yaffle.
												stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
												// Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
												// values less than 1000. Credits: @Yaffle.
												stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
											} catch (exception) {
												stringifySupported = false;
											}
										}
										isSupported = stringifySupported;
									}
									// Test `JSON.parse`.
									if (name == "json-parse") {
										var parse = exports.parse;
										if (typeof parse == "function") {
											try {
												// FF 3.1b1, b2 will throw an exception if a bare literal is provided.
												// Conforming implementations should also coerce the initial argument to
												// a string prior to parsing.
												if (parse("0") === 0 && !parse(false)) {
													// Simple parsing test.
													value = parse(serialized);
													var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
													if (parseSupported) {
														try {
															// Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
															parseSupported = !parse('"\t"');
														} catch (exception) {}
														if (parseSupported) {
															try {
																// FF 4.0 and 4.0.1 allow leading `+` signs and leading
																// decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
																// certain octal literals.
																parseSupported = parse("01") !== 1;
															} catch (exception) {}
														}
														if (parseSupported) {
															try {
																// FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
																// points. These environments, along with FF 3.1b1 and 2,
																// also allow trailing commas in JSON objects and arrays.
																parseSupported = parse("1.") !== 1;
															} catch (exception) {}
														}
													}
												}
											} catch (exception) {
												parseSupported = false;
											}
										}
										isSupported = parseSupported;
									}
								}
								return has[name] = !!isSupported;
							}

							if (!has("json")) {
								// Common `[[Class]]` name aliases.
								var functionClass = "[object Function]",
								    dateClass = "[object Date]",
								    numberClass = "[object Number]",
								    stringClass = "[object String]",
								    arrayClass = "[object Array]",
								    booleanClass = "[object Boolean]";

								// Detect incomplete support for accessing string characters by index.
								var charIndexBuggy = has("bug-string-char-index");

								// Define additional utility methods if the `Date` methods are buggy.
								if (!isExtended) {
									var floor = Math.floor;
									// A mapping between the months of the year and the number of days between
									// January 1st and the first of the respective month.
									var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
									// Internal: Calculates the number of days between the Unix epoch and the
									// first day of the given month.
									var getDay = function getDay(year, month) {
										return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
									};
								}

								// Internal: Determines if a property is a direct property of the given
								// object. Delegates to the native `Object#hasOwnProperty` method.
								if (!(_isProperty = objectProto.hasOwnProperty)) {
									_isProperty = function isProperty(property) {
										var members = {},
										    constructor;
										if ((members.__proto__ = null, members.__proto__ = {
											// The *proto* property cannot be set multiple times in recent
											// versions of Firefox and SeaMonkey.
											"toString": 1
										}, members).toString != getClass) {
											// Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
											// supports the mutable *proto* property.
											_isProperty = function isProperty(property) {
												// Capture and break the object's prototype chain (see section 8.6.2
												// of the ES 5.1 spec). The parenthesized expression prevents an
												// unsafe transformation by the Closure Compiler.
												var original = this.__proto__,
												    result = property in (this.__proto__ = null, this);
												// Restore the original prototype chain.
												this.__proto__ = original;
												return result;
											};
										} else {
											// Capture a reference to the top-level `Object` constructor.
											constructor = members.constructor;
											// Use the `constructor` property to simulate `Object#hasOwnProperty` in
											// other environments.
											_isProperty = function isProperty(property) {
												var parent = (this.constructor || constructor).prototype;
												return property in this && !(property in parent && this[property] === parent[property]);
											};
										}
										members = null;
										return _isProperty.call(this, property);
									};
								}

								// Internal: Normalizes the `for...in` iteration algorithm across
								// environments. Each enumerated key is yielded to a `callback` function.
								_forEach = function forEach(object, callback) {
									var size = 0,
									    Properties,
									    members,
									    property;

									// Tests for bugs in the current environment's `for...in` algorithm. The
									// `valueOf` property inherits the non-enumerable flag from
									// `Object.prototype` in older versions of IE, Netscape, and Mozilla.
									(Properties = function Properties() {
										this.valueOf = 0;
									}).prototype.valueOf = 0;

									// Iterate over a new instance of the `Properties` class.
									members = new Properties();
									for (property in members) {
										// Ignore all properties inherited from `Object.prototype`.
										if (_isProperty.call(members, property)) {
											size++;
										}
									}
									Properties = members = null;

									// Normalize the iteration algorithm.
									if (!size) {
										// A list of non-enumerable properties inherited from `Object.prototype`.
										members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
										// IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
										// properties.
										_forEach = function forEach(object, callback) {
											var isFunction = getClass.call(object) == functionClass,
											    property,
											    length;
											var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[_typeof(object.hasOwnProperty)] && object.hasOwnProperty || _isProperty;
											for (property in object) {
												// Gecko <= 1.0 enumerates the `prototype` property of functions under
												// certain conditions; IE does not.
												if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
													callback(property);
												}
											}
											// Manually invoke the callback for each non-enumerable property.
											for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property)) {}
										};
									} else if (size == 2) {
										// Safari <= 2.0.4 enumerates shadowed properties twice.
										_forEach = function forEach(object, callback) {
											// Create a set of iterated properties.
											var members = {},
											    isFunction = getClass.call(object) == functionClass,
											    property;
											for (property in object) {
												// Store each property name to prevent double enumeration. The
												// `prototype` property of functions is not enumerated due to cross-
												// environment inconsistencies.
												if (!(isFunction && property == "prototype") && !_isProperty.call(members, property) && (members[property] = 1) && _isProperty.call(object, property)) {
													callback(property);
												}
											}
										};
									} else {
										// No bugs detected; use the standard `for...in` algorithm.
										_forEach = function forEach(object, callback) {
											var isFunction = getClass.call(object) == functionClass,
											    property,
											    isConstructor;
											for (property in object) {
												if (!(isFunction && property == "prototype") && _isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
													callback(property);
												}
											}
											// Manually invoke the callback for the `constructor` property due to
											// cross-environment inconsistencies.
											if (isConstructor || _isProperty.call(object, property = "constructor")) {
												callback(property);
											}
										};
									}
									return _forEach(object, callback);
								};

								// Public: Serializes a JavaScript `value` as a JSON string. The optional
								// `filter` argument may specify either a function that alters how object and
								// array members are serialized, or an array of strings and numbers that
								// indicates which properties should be serialized. The optional `width`
								// argument may be either a string or number that specifies the indentation
								// level of the output.
								if (!has("json-stringify")) {
									// Internal: A map of control characters and their escaped equivalents.
									var Escapes = {
										92: "\\\\",
										34: '\\"',
										8: "\\b",
										12: "\\f",
										10: "\\n",
										13: "\\r",
										9: "\\t"
									};

									// Internal: Converts `value` into a zero-padded string such that its
									// length is at least equal to `width`. The `width` must be <= 6.
									var leadingZeroes = "000000";
									var toPaddedString = function toPaddedString(width, value) {
										// The `|| 0` expression is necessary to work around a bug in
										// Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
										return (leadingZeroes + (value || 0)).slice(-width);
									};

									// Internal: Double-quotes a string `value`, replacing all ASCII control
									// characters (characters with code unit values between 0 and 31) with
									// their escaped equivalents. This is an implementation of the
									// `Quote(value)` operation defined in ES 5.1 section 15.12.3.
									var unicodePrefix = "\\u00";
									var quote = function quote(value) {
										var result = '"',
										    index = 0,
										    length = value.length,
										    useCharIndex = !charIndexBuggy || length > 10;
										var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
										for (; index < length; index++) {
											var charCode = value.charCodeAt(index);
											// If the character is a control character, append its Unicode or
											// shorthand escape sequence; otherwise, append the character as-is.
											switch (charCode) {
												case 8:case 9:case 10:case 12:case 13:case 34:case 92:
													result += Escapes[charCode];
													break;
												default:
													if (charCode < 32) {
														result += unicodePrefix + toPaddedString(2, charCode.toString(16));
														break;
													}
													result += useCharIndex ? symbols[index] : value.charAt(index);
											}
										}
										return result + '"';
									};

									// Internal: Recursively serializes an object. Implements the
									// `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
									var serialize = function serialize(property, object, callback, properties, whitespace, indentation, stack) {
										var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
										try {
											// Necessary for host object support.
											value = object[property];
										} catch (exception) {}
										if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
											className = getClass.call(value);
											if (className == dateClass && !_isProperty.call(value, "toJSON")) {
												if (value > -1 / 0 && value < 1 / 0) {
													// Dates are serialized according to the `Date#toJSON` method
													// specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
													// for the ISO 8601 date time string format.
													if (getDay) {
														// Manually compute the year, month, date, hours, minutes,
														// seconds, and milliseconds if the `getUTC*` methods are
														// buggy. Adapted from @Yaffle's `date-shim` project.
														date = floor(value / 864e5);
														for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++) {}
														for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++) {}
														date = 1 + date - getDay(year, month);
														// The `time` value specifies the time within the day (see ES
														// 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
														// to compute `A modulo B`, as the `%` operator does not
														// correspond to the `modulo` operation for negative numbers.
														time = (value % 864e5 + 864e5) % 864e5;
														// The hours, minutes, seconds, and milliseconds are obtained by
														// decomposing the time within the day. See section 15.9.1.10.
														hours = floor(time / 36e5) % 24;
														minutes = floor(time / 6e4) % 60;
														seconds = floor(time / 1e3) % 60;
														milliseconds = time % 1e3;
													} else {
														year = value.getUTCFullYear();
														month = value.getUTCMonth();
														date = value.getUTCDate();
														hours = value.getUTCHours();
														minutes = value.getUTCMinutes();
														seconds = value.getUTCSeconds();
														milliseconds = value.getUTCMilliseconds();
													}
													// Serialize extended years correctly.
													value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) + "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
													// Months, dates, hours, minutes, and seconds should have two
													// digits; milliseconds should have three.
													"T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
													// Milliseconds are optional in ES 5.0, but required in 5.1.
													"." + toPaddedString(3, milliseconds) + "Z";
												} else {
													value = null;
												}
											} else if (typeof value.toJSON == "function" && (className != numberClass && className != stringClass && className != arrayClass || _isProperty.call(value, "toJSON"))) {
												// Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
												// `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
												// ignores all `toJSON` methods on these objects unless they are
												// defined directly on an instance.
												value = value.toJSON(property);
											}
										}
										if (callback) {
											// If a replacement function was provided, call it to obtain the value
											// for serialization.
											value = callback.call(object, property, value);
										}
										if (value === null) {
											return "null";
										}
										className = getClass.call(value);
										if (className == booleanClass) {
											// Booleans are represented literally.
											return "" + value;
										} else if (className == numberClass) {
											// JSON numbers must be finite. `Infinity` and `NaN` are serialized as
											// `"null"`.
											return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
										} else if (className == stringClass) {
											// Strings are double-quoted and escaped.
											return quote("" + value);
										}
										// Recursively serialize objects and arrays.
										if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object") {
											// Check for cyclic structures. This is a linear search; performance
											// is inversely proportional to the number of unique nested objects.
											for (length = stack.length; length--;) {
												if (stack[length] === value) {
													// Cyclic structures cannot be serialized by `JSON.stringify`.
													throw TypeError();
												}
											}
											// Add the object to the stack of traversed objects.
											stack.push(value);
											results = [];
											// Save the current indentation level and indent one additional level.
											prefix = indentation;
											indentation += whitespace;
											if (className == arrayClass) {
												// Recursively serialize array elements.
												for (index = 0, length = value.length; index < length; index++) {
													element = serialize(index, value, callback, properties, whitespace, indentation, stack);
													results.push(element === undef ? "null" : element);
												}
												result = results.length ? whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : "[" + results.join(",") + "]" : "[]";
											} else {
												// Recursively serialize object members. Members are selected from
												// either a user-specified list of property names, or the object
												// itself.
												_forEach(properties || value, function (property) {
													var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
													if (element !== undef) {
														// According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
														// is not the empty string, let `member` {quote(property) + ":"}
														// be the concatenation of `member` and the `space` character."
														// The "`space` character" refers to the literal space
														// character, not the `space` {width} argument provided to
														// `JSON.stringify`.
														results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
													}
												});
												result = results.length ? whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : "{" + results.join(",") + "}" : "{}";
											}
											// Remove the object from the traversed object stack.
											stack.pop();
											return result;
										}
									};

									// Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
									exports.stringify = function (source, filter, width) {
										var whitespace, callback, properties, className;
										if (objectTypes[typeof filter === "undefined" ? "undefined" : _typeof(filter)] && filter) {
											if ((className = getClass.call(filter)) == functionClass) {
												callback = filter;
											} else if (className == arrayClass) {
												// Convert the property names array into a makeshift set.
												properties = {};
												for (var index = 0, length = filter.length, value; index < length; value = filter[index++], (className = getClass.call(value), className == stringClass || className == numberClass) && (properties[value] = 1)) {}
											}
										}
										if (width) {
											if ((className = getClass.call(width)) == numberClass) {
												// Convert the `width` to an integer and create a string containing
												// `width` number of space characters.
												if ((width -= width % 1) > 0) {
													for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ") {}
												}
											} else if (className == stringClass) {
												whitespace = width.length <= 10 ? width : width.slice(0, 10);
											}
										}
										// Opera <= 7.54u2 discards the values associated with empty string keys
										// (`""`) only if they are used directly within an object member list
										// (e.g., `!("" in { "": 1})`).
										return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
									};
								}

								// Public: Parses a JSON source string.
								if (!has("json-parse")) {
									var fromCharCode = String.fromCharCode;

									// Internal: A map of escaped control characters and their unescaped
									// equivalents.
									var Unescapes = {
										92: "\\",
										34: '"',
										47: "/",
										98: "\b",
										116: "\t",
										110: "\n",
										102: "\f",
										114: "\r"
									};

									// Internal: Stores the parser state.
									var Index, Source;

									// Internal: Resets the parser state and throws a `SyntaxError`.
									var abort = function abort() {
										Index = Source = null;
										throw SyntaxError();
									};

									// Internal: Returns the next token, or `"$"` if the parser has reached
									// the end of the source string. A token may be a string, number, `null`
									// literal, or Boolean literal.
									var lex = function lex() {
										var source = Source,
										    length = source.length,
										    value,
										    begin,
										    position,
										    isSigned,
										    charCode;
										while (Index < length) {
											charCode = source.charCodeAt(Index);
											switch (charCode) {
												case 9:case 10:case 13:case 32:
													// Skip whitespace tokens, including tabs, carriage returns, line
													// feeds, and space characters.
													Index++;
													break;
												case 123:case 125:case 91:case 93:case 58:case 44:
													// Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
													// the current position.
													value = charIndexBuggy ? source.charAt(Index) : source[Index];
													Index++;
													return value;
												case 34:
													// `"` delimits a JSON string; advance to the next character and
													// begin parsing the string. String tokens are prefixed with the
													// sentinel `@` character to distinguish them from punctuators and
													// end-of-string tokens.
													for (value = "@", Index++; Index < length;) {
														charCode = source.charCodeAt(Index);
														if (charCode < 32) {
															// Unescaped ASCII control characters (those with a code unit
															// less than the space character) are not permitted.
															abort();
														} else if (charCode == 92) {
															// A reverse solidus (`\`) marks the beginning of an escaped
															// control character (including `"`, `\`, and `/`) or Unicode
															// escape sequence.
															charCode = source.charCodeAt(++Index);
															switch (charCode) {
																case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:
																	// Revive escaped control characters.
																	value += Unescapes[charCode];
																	Index++;
																	break;
																case 117:
																	// `\u` marks the beginning of a Unicode escape sequence.
																	// Advance to the first character and validate the
																	// four-digit code point.
																	begin = ++Index;
																	for (position = Index + 4; Index < position; Index++) {
																		charCode = source.charCodeAt(Index);
																		// A valid sequence comprises four hexdigits (case-
																		// insensitive) that form a single hexadecimal value.
																		if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
																			// Invalid Unicode escape sequence.
																			abort();
																		}
																	}
																	// Revive the escaped character.
																	value += fromCharCode("0x" + source.slice(begin, Index));
																	break;
																default:
																	// Invalid escape sequence.
																	abort();
															}
														} else {
															if (charCode == 34) {
																// An unescaped double-quote character marks the end of the
																// string.
																break;
															}
															charCode = source.charCodeAt(Index);
															begin = Index;
															// Optimize for the common case where a string is valid.
															while (charCode >= 32 && charCode != 92 && charCode != 34) {
																charCode = source.charCodeAt(++Index);
															}
															// Append the string as-is.
															value += source.slice(begin, Index);
														}
													}
													if (source.charCodeAt(Index) == 34) {
														// Advance to the next character and return the revived string.
														Index++;
														return value;
													}
													// Unterminated string.
													abort();
												default:
													// Parse numbers and literals.
													begin = Index;
													// Advance past the negative sign, if one is specified.
													if (charCode == 45) {
														isSigned = true;
														charCode = source.charCodeAt(++Index);
													}
													// Parse an integer or floating-point value.
													if (charCode >= 48 && charCode <= 57) {
														// Leading zeroes are interpreted as octal literals.
														if (charCode == 48 && (charCode = source.charCodeAt(Index + 1), charCode >= 48 && charCode <= 57)) {
															// Illegal octal literal.
															abort();
														}
														isSigned = false;
														// Parse the integer component.
														for (; Index < length && (charCode = source.charCodeAt(Index), charCode >= 48 && charCode <= 57); Index++) {}
														// Floats cannot contain a leading decimal point; however, this
														// case is already accounted for by the parser.
														if (source.charCodeAt(Index) == 46) {
															position = ++Index;
															// Parse the decimal component.
															for (; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
															if (position == Index) {
																// Illegal trailing decimal.
																abort();
															}
															Index = position;
														}
														// Parse exponents. The `e` denoting the exponent is
														// case-insensitive.
														charCode = source.charCodeAt(Index);
														if (charCode == 101 || charCode == 69) {
															charCode = source.charCodeAt(++Index);
															// Skip past the sign following the exponent, if one is
															// specified.
															if (charCode == 43 || charCode == 45) {
																Index++;
															}
															// Parse the exponential component.
															for (position = Index; position < length && (charCode = source.charCodeAt(position), charCode >= 48 && charCode <= 57); position++) {}
															if (position == Index) {
																// Illegal empty exponent.
																abort();
															}
															Index = position;
														}
														// Coerce the parsed value to a JavaScript number.
														return +source.slice(begin, Index);
													}
													// A negative sign may only precede numbers.
													if (isSigned) {
														abort();
													}
													// `true`, `false`, and `null` literals.
													if (source.slice(Index, Index + 4) == "true") {
														Index += 4;
														return true;
													} else if (source.slice(Index, Index + 5) == "false") {
														Index += 5;
														return false;
													} else if (source.slice(Index, Index + 4) == "null") {
														Index += 4;
														return null;
													}
													// Unrecognized token.
													abort();
											}
										}
										// Return the sentinel `$` character if the parser has reached the end
										// of the source string.
										return "$";
									};

									// Internal: Parses a JSON `value` token.
									var get = function get(value) {
										var results, hasMembers;
										if (value == "$") {
											// Unexpected end of input.
											abort();
										}
										if (typeof value == "string") {
											if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
												// Remove the sentinel `@` character.
												return value.slice(1);
											}
											// Parse object and array literals.
											if (value == "[") {
												// Parses a JSON array, returning a new JavaScript array.
												results = [];
												for (;; hasMembers || (hasMembers = true)) {
													value = lex();
													// A closing square bracket marks the end of the array literal.
													if (value == "]") {
														break;
													}
													// If the array literal contains elements, the current token
													// should be a comma separating the previous element from the
													// next.
													if (hasMembers) {
														if (value == ",") {
															value = lex();
															if (value == "]") {
																// Unexpected trailing `,` in array literal.
																abort();
															}
														} else {
															// A `,` must separate each array element.
															abort();
														}
													}
													// Elisions and leading commas are not permitted.
													if (value == ",") {
														abort();
													}
													results.push(get(value));
												}
												return results;
											} else if (value == "{") {
												// Parses a JSON object, returning a new JavaScript object.
												results = {};
												for (;; hasMembers || (hasMembers = true)) {
													value = lex();
													// A closing curly brace marks the end of the object literal.
													if (value == "}") {
														break;
													}
													// If the object literal contains members, the current token
													// should be a comma separator.
													if (hasMembers) {
														if (value == ",") {
															value = lex();
															if (value == "}") {
																// Unexpected trailing `,` in object literal.
																abort();
															}
														} else {
															// A `,` must separate each object member.
															abort();
														}
													}
													// Leading commas are not permitted, object property names must be
													// double-quoted strings, and a `:` must separate each property
													// name and value.
													if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
														abort();
													}
													results[value.slice(1)] = get(lex());
												}
												return results;
											}
											// Unexpected token encountered.
											abort();
										}
										return value;
									};

									// Internal: Updates a traversed object member.
									var update = function update(source, property, callback) {
										var element = walk(source, property, callback);
										if (element === undef) {
											delete source[property];
										} else {
											source[property] = element;
										}
									};

									// Internal: Recursively traverses a parsed JSON object, invoking the
									// `callback` function for each value. This is an implementation of the
									// `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
									var walk = function walk(source, property, callback) {
										var value = source[property],
										    length;
										if ((typeof value === "undefined" ? "undefined" : _typeof(value)) == "object" && value) {
											// `forEach` can't be used to traverse an array in Opera <= 8.54
											// because its `Object#hasOwnProperty` implementation returns `false`
											// for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
											if (getClass.call(value) == arrayClass) {
												for (length = value.length; length--;) {
													update(value, length, callback);
												}
											} else {
												_forEach(value, function (property) {
													update(value, property, callback);
												});
											}
										}
										return callback.call(source, property, value);
									};

									// Public: `JSON.parse`. See ES 5.1 section 15.12.2.
									exports.parse = function (source, callback) {
										var result, value;
										Index = 0;
										Source = "" + source;
										result = get(lex());
										// If a JSON string contains multiple tokens, it is invalid.
										if (lex() != "$") {
											abort();
										}
										// Reset the parser state.
										Index = Source = null;
										return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
									};
								}
							}

							exports["runInContext"] = runInContext;
							return exports;
						}

						if (freeExports && !isLoader) {
							// Export for CommonJS environments.
							runInContext(root, freeExports);
						} else {
							// Export for web browsers and JavaScript engines.
							var nativeJSON = root.JSON,
							    previousJSON = root["JSON3"],
							    isRestored = false;

							var JSON3 = runInContext(root, root["JSON3"] = {
								// Public: Restores the original value of the global `JSON` object and
								// returns a reference to the `JSON3` object.
								"noConflict": function noConflict() {
									if (!isRestored) {
										isRestored = true;
										root.JSON = nativeJSON;
										root["JSON3"] = previousJSON;
										nativeJSON = previousJSON = null;
									}
									return JSON3;
								}
							});

							root.JSON = {
								"parse": JSON3.parse,
								"stringify": JSON3.stringify
							};
						}

						// Export for asynchronous module loaders.
						if (isLoader) {
							define(function () {
								return JSON3;
							});
						}
					}).call(this);
				}).call(this, typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
			}, {}], 51: [function (_dereq_, module, exports) {
				module.exports = toArray;

				function toArray(list, index) {
					var array = [];

					index = index || 0;

					for (var i = index || 0; i < list.length; i++) {
						array[i - index] = list[i];
					}

					return array;
				}
			}, {}] }, {}, [31])(31);
	});
}

cc._RF.pop();
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},["socket-io","AnysdkMgr","AudioMgr","GameNetMgr","Global","HTTP","HotUpdate","MahjongMgr","Net","ReplayMgr","UserMgr","Utils","VoiceMgr","Alert","Chat","CheckBox","CreateRole","CreateRoom","DingQue","Folds","GameOver","GameResult","Hall","History","HuanSanZhang","ImageLoader","JoinGameInput","LoadingLogic","Login","MJGame","MJRoom","NoticeTip","OnBack","PengGangs","PopupMgr","RadioButton","RadioGroupMgr","ReConnect","ReplayCtrl","Seat","Settings","TimePointer","UserInfoShow","Voice","WaitingConnection"])

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvQWxlcnQuanMiLCJhc3NldHMvc2NyaXB0cy9BbnlzZGtNZ3IuanMiLCJhc3NldHMvc2NyaXB0cy9BdWRpb01nci5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvQ2hhdC5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvQ2hlY2tCb3guanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0NyZWF0ZVJvbGUuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0NyZWF0ZVJvb20uanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0RpbmdRdWUuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0ZvbGRzLmpzIiwiYXNzZXRzL3NjcmlwdHMvR2FtZU5ldE1nci5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvR2FtZU92ZXIuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0dhbWVSZXN1bHQuanMiLCJhc3NldHMvc2NyaXB0cy9HbG9iYWwuanMiLCJhc3NldHMvc2NyaXB0cy9IVFRQLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9IYWxsLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9IaXN0b3J5LmpzIiwiYXNzZXRzL3NjcmlwdHMvSG90VXBkYXRlLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9IdWFuU2FuWmhhbmcuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0ltYWdlTG9hZGVyLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9Kb2luR2FtZUlucHV0LmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9Mb2FkaW5nTG9naWMuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL0xvZ2luLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9NSkdhbWUuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL01KUm9vbS5qcyIsImFzc2V0cy9zY3JpcHRzL01haGpvbmdNZ3IuanMiLCJhc3NldHMvc2NyaXB0cy9OZXQuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL05vdGljZVRpcC5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvT25CYWNrLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9QZW5nR2FuZ3MuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL1BvcHVwTWdyLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9SYWRpb0J1dHRvbi5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvUmFkaW9Hcm91cE1nci5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvUmVDb25uZWN0LmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9SZXBsYXlDdHJsLmpzIiwiYXNzZXRzL3NjcmlwdHMvUmVwbGF5TWdyLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9TZWF0LmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9TZXR0aW5ncy5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvVGltZVBvaW50ZXIuanMiLCJhc3NldHMvc2NyaXB0cy9jb21wb25lbnRzL1VzZXJJbmZvU2hvdy5qcyIsImFzc2V0cy9zY3JpcHRzL1VzZXJNZ3IuanMiLCJhc3NldHMvc2NyaXB0cy9VdGlscy5qcyIsImFzc2V0cy9zY3JpcHRzL1ZvaWNlTWdyLmpzIiwiYXNzZXRzL3NjcmlwdHMvY29tcG9uZW50cy9Wb2ljZS5qcyIsImFzc2V0cy9zY3JpcHRzL2NvbXBvbmVudHMvV2FpdGluZ0Nvbm5lY3Rpb24uanMiLCJhc3NldHMvc2NyaXB0cy8zcmRwYXJ0eS9zb2NrZXQtaW8uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJROztBQW1CWjtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBOztBQUVBO0FBbEZLOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYUTs7QUFjWjtBQUNBOztBQUdBO0FBQ0E7O0FBRUE7OztBQUtBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDVDs7QUFFUztBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNEO0FBQ0g7QUFFRztBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDSDtBQTlKSTs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFkUTs7QUFpQlo7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIO0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKOzs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFqR0k7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWhCUTs7QUFtQlo7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOzs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFqR0k7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiUTs7QUFnQlo7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFJRDtBQUNBOztBQUVBO0FBakRLOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBRFE7O0FBYVo7QUFDSTs7QUFvQkE7QUFXQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBQ0Q7QUFDQTs7QUFFQTtBQTNFSzs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaUTs7QUFlWjtBQUNBO0FBQ0k7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFFSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7O0FBRUk7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUdEO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7O0FBRUE7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTE87O0FBUVg7QUFDSTtBQUNBO0FBQ0E7QUFITztBQUtYO0FBQ0E7QUFDSDs7QUFFRDs7QUFFSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUpPOztBQU9YO0FBQ0k7QUFDQTtBQUNBO0FBSE87QUFLWDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDs7QUFFSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUpPOztBQU9YO0FBQ0k7QUFDQTtBQUNBO0FBSE87QUFLWDtBQUNBO0FBQ0E7QUFDSDs7QUFwZEk7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFKUTs7QUFnQlo7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7QUF0TEs7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWUTs7QUFhWjtBQUNBO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDs7QUFFQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUF2SEk7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFuQlE7O0FBaUNaO0FBQ0k7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNKOzs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDSTtBQURRO0FBR1o7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSztBQUNBO0FBQ0E7QUFDRDtBQUdIO0FBQ0k7QUFDQTtBQUNEO0FBSUg7QUFDSTtBQUNBO0FBQ0Q7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUlBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDRztBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDSTtBQUNBO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFHRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDTDtBQUNIOztBQUdEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUlEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUdEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0M7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7O0FBRUE7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDSDtBQUNEO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDtBQUNKO0FBQ0Q7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBRk87QUFJWDtBQUNBO0FBQ0g7O0FBR0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUpLO0FBTVQ7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBM3lCSzs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhCUTs7QUFtQlo7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFBd0M7QUFBOEI7O0FBRXRFO0FBQXVDO0FBQXdCO0FBQ2xFOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNKO0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDs7QUFHRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVFO0FBQ0Y7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFJQTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7O0FBR0Q7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBR0Q7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFFSDtBQUNKOztBQUdEO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFBUTtBQUNSO0FBQVE7QUFDUjtBQUFRO0FBQ1I7QUFBUTtBQUpaO0FBTUE7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBQ0Q7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDs7QUFHRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNEO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUU7QUFDRjtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJOztBQUVBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFHSjtBQUNHO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUdBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDs7QUFHRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDs7QUFFQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFHRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUVIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUFRO0FBQ1I7QUFBUTtBQUNSO0FBQVE7QUFDUjtBQUFRO0FBSlo7QUFNQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7O0FBR0Q7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVFO0FBQ0Y7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFHSjs7QUFFRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBOztBQUdBO0FBQ0E7O0FBR0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIOztBQUdEO0FBQ0E7QUFDSTtBQUNIOztBQUVEOztBQUVBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUdEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBRUg7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQVE7QUFDUjtBQUFRO0FBQ1I7QUFBUTtBQUNSO0FBQVE7QUFKWjtBQU1BOztBQUVBO0FBQ0E7QUFDSTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBRUc7QUFDSDtBQUNKO0FBRUc7QUFHSztBQUNKO0FBQ0c7QUFDSDtBQUNKO0FBQ0o7QUFDRDtBQUNIOztBQUdEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTtBQWxvQ0s7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhROztBQWNaO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFBdUM7QUFBNkI7QUFDdkU7O0FBRUQ7QUFDSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUE1Rkk7Ozs7Ozs7Ozs7QUNBVDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFQSztBQUZTOzs7Ozs7Ozs7O0FDQXRCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0c7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNDO0FBQ0o7QUFDSjtBQUVHO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBeERHO0FBSFE7Ozs7Ozs7Ozs7QUNWcEI7QUFDQTtBQUNBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJROztBQXlCWjtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBRk87QUFJWDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUZPO0FBSVg7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7O0FBRUE7QUFDSTtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0k7QUFDSTtBQUNBO0FBRm1CO0FBSTFCOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBRm9CO0FBSTNCOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQUVKOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFETztBQUdYO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSDtBQUdKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQURPO0FBR1g7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUVKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBRk87QUFJWDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFKTztBQU1YO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBSk87QUFNWDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUlEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0M7O0FBRUQ7QUFDQTtBQUNDO0FBR0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDs7QUFFQTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBNVlJOzs7Ozs7Ozs7OztBQ0ZUO0FBQ0k7O0FBRUE7QUFDSTtBQUNJO0FBQ0E7QUFGYztBQUlsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBCUTs7QUF1Qlo7QUFDQTtBQUNJO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFFSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDRztBQUNGO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNKOztBQW5PSTs7Ozs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0k7QUFDQTtBQUZTO0FBSWI7QUFDSTtBQUNBO0FBRlM7QUFJYjtBQUNJO0FBQ0E7QUFGSztBQUlUO0FBQ0k7QUFDQTtBQUZJO0FBYkE7O0FBbUJaO0FBQ0k7QUFDQTtBQUVJO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUF4QlI7QUEwQkE7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUVJO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDSTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0o7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNKO0FBQ0k7QUFDQTtBQUNBO0FBQ0o7QUFDSTs7QUFFQTtBQUNBO0FBQ0o7QUFDSTs7QUFFQTtBQUNBO0FBRUk7QUFDSDtBQUdHO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBQ0E7QUFDSjtBQUNJO0FBckRSOztBQXdEQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUVJO0FBQ0E7O0FBRUE7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSDtBQTNLSTs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaUTs7QUFlWjtBQUNBO0FBQ0k7QUFDQTs7QUFFQTtBQUNJO0FBQ0g7QUFDRDs7QUFFQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDs7QUFFQTtBQUNHO0FBQ0E7QUFDRjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUhPOztBQU1YO0FBQ0E7QUFDQTs7QUFFQTtBQUNIOztBQWxKSTs7Ozs7Ozs7OztBQ0FUO0FBQ0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQUVHO0FBQ0k7QUFDQTtBQUNHO0FBQ0Y7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUhPO0FBS1g7QUFDQTtBQUVIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZROztBQWFaO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDRztBQUNLO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7QUFDRDtBQUNBOztBQUVBO0FBckRLOzs7Ozs7Ozs7O0FDL0RUO0FBQ0k7O0FBRUE7QUFDSTtBQUNJO0FBQ0E7QUFGQztBQUlMO0FBTFE7O0FBaUJaO0FBQ0E7O0FBSUE7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7QUFDRDtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTtBQXZISzs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTFE7O0FBUVo7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBR0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDRDtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBRUc7QUFDSDtBQUNKO0FBQ0o7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDSjtBQW5OSTs7Ozs7Ozs7Ozs7O0FDQVQ7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBRUc7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBQ0Q7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdKO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDs7QUFFQTs7QUFFQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUxBO0FBT0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUVIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUVHO0FBQ0E7QUFDQTtBQUNIOztBQUdEO0FBQ0k7QUFDSDtBQUdKOztBQUdEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFITTtBQUtWO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRztBQUNBO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7O0FBRUk7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNJO0FBQ1A7QUFDRDtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDs7QUFFQTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFHRDs7QUFFSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFFRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBOztBQUVBO0FBbktLOzs7Ozs7Ozs7O0FDM0JUO0FBQ0k7O0FBRUE7QUFDSTtBQUNJO0FBQ0E7QUFGSzs7QUFLVDtBQUNJO0FBQ0E7QUFGUTs7QUFLWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJROztBQXdCWjtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOztBQUVJO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBVlI7O0FBY0E7QUFDQTtBQUNJO0FBQWdCO0FBQ2hCO0FBQWU7QUFDZjtBQUFjO0FBSGxCOztBQU9BO0FBQ0E7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBRk87QUFJWDtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJOztBQUVBO0FBQ0E7O0FBRUE7QUFDRztBQUNBO0FBQ0Y7O0FBRUQ7QUFDSTtBQUNBO0FBRUg7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIO0FBRUc7QUFDSDtBQUNKO0FBQ0o7QUFFRztBQUNBOztBQUVBO0FBRUk7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIO0FBRUc7QUFDSDs7QUFFRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNKO0FBQ0k7QUFDSjtBQUNJO0FBQ0o7QUFDSTs7QUFSUjtBQVdIOztBQUVEO0FBQ0k7QUFDQTtBQUNIOztBQUdEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNIOztBQUlEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEOztBQUVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBR0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNKO0FBQ0o7QUFDRDtBQUNBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQVJBO0FBVUk7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNHO0FBQ0Y7QUFDRDtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDQTtBQUNIOztBQUlEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0E7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNSO0FBQ1E7QUFDQTtBQUNJO0FBQ0k7QUFDaEI7QUFDZ0I7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVUO0FBQ1E7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDSjtBQUNKO0FBRUc7QUFDSTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDSjtBQUVHO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNEO0FBSEs7QUFLRDs7QUFFQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDSjtBQUNEO0FBVks7QUFZRDtBQUNIO0FBQ0Q7QUFISztBQUtEO0FBQ0g7QUFDRDtBQUhLO0FBS0Q7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNBOztBQUdBO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQTlqQ0k7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDSTtBQUNBO0FBRk07QUFJVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWlE7O0FBZVo7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIOztBQUdEO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7O0FBRUk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDTTtBQUNMO0FBQ0Q7QUFDSDtBQUVKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEOztBQUVJO0FBQ0E7QUFDSDs7QUFFRDs7QUFFSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7O0FBSUE7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQXVCO0FBQThDO0FBRXhFOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7O0FBR0Q7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNIOztBQUdEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUVHO0FBQ0g7QUFDRDtBQUNIOztBQUdEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNSO0FBQ0s7QUExV0k7Ozs7Ozs7Ozs7QUNBVDs7QUFFQTtBQUNJOztBQUVBO0FBQ0k7QUFDSTtBQUNBO0FBRk07O0FBS1Y7QUFDSTtBQUNBO0FBRk87O0FBS1g7QUFDSTtBQUNBO0FBRlE7O0FBS1o7QUFDSTtBQUNBO0FBRlk7O0FBS2hCO0FBQ0k7QUFDQTtBQUZXOztBQUtmO0FBQ0k7QUFDQTtBQUZXOztBQUtmO0FBQ0k7QUFDQTtBQUZPOztBQUtYO0FBQ0k7QUFDQTtBQUZPOztBQUtYO0FBQ0E7QUFDQTtBQTNDUTs7QUE4Q1o7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0U7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDRjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDQTtBQUNHO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBR0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDSjtBQUNEO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQXZPSTs7Ozs7Ozs7Ozs7O0FDRlQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNEO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFITztBQUtYO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNIOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7QUFDSjtBQUNEO0FBQ0k7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNEO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFKTztBQU1YO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JIO0FBbEtJO0FBRlM7Ozs7Ozs7Ozs7QUNKdEI7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYlE7O0FBZ0JaO0FBQ0E7QUFDSTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNHO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNIO0FBM0NJOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVlE7O0FBYVo7QUFDQTtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0E7O0FBRUE7QUEvQks7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVFE7O0FBWVo7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBRUg7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUtBO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBRUo7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7O0FBRUk7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNJO0FBQ0g7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUlEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7O0FBRUQ7QUFDSDtBQUVHO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0g7QUFFRztBQUNIO0FBRUc7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBRUc7QUFDSDtBQUNKO0FBRUc7QUFDSTtBQUNIO0FBQ0c7QUFDSDtBQUNHO0FBQ0g7QUFDSjtBQUNKO0FBRUo7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDs7QUFJQTtBQUNBOztBQUVBO0FBblRLOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFoQlE7O0FBbUJaO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNKO0FBQ0Q7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNIO0FBQ0o7QUE5SUk7Ozs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZFE7O0FBaUJaO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTs7QUFFQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQWhFSTs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZROztBQWFaO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBOztBQUVBO0FBakVLOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYlE7O0FBZ0JaO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNHO0FBQ0k7QUFDQztBQUNJO0FBQ0E7QUFDSDtBQUNHO0FBQ0g7QUFDRDtBQUNBO0FBQ0o7QUFFRztBQUNIO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7QUE3REk7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWlE7O0FBZVo7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQXJESTs7Ozs7Ozs7OztBQ0FUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaUTs7QUFlWjtBQUNBOztBQUlBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNHO0FBQ0E7QUFDQTtBQUNIO0FBQ0c7QUFDQTtBQUNBO0FBQ0g7QUFHSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQUNEO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNDO0FBQ0Q7QUFDSDtBQUNKOztBQUVEO0FBQ0E7O0FBRUE7QUE5SEs7Ozs7Ozs7Ozs7QUNUVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCUTs7QUF3Qlo7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFHRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIOztBQUVEOztBQUVBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNHO0FBQ0M7QUFDQTtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDRDtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEOztBQUVBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0g7O0FBRUQ7QUFDSDs7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7QUFDSjs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0g7QUFDSjtBQUNKO0FBek9JOzs7Ozs7Ozs7O0FDQVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkUTs7QUFpQlo7QUFDQTtBQUNJO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDs7QUFFSTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDSDs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBRUc7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDQTs7QUFFQTtBQXZISzs7Ozs7Ozs7OztBQ0FUO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTFE7O0FBaUJaO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7O0FBR0k7QUFDSTtBQUNIOztBQUlEO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7QUFDRDtBQUNIO0FBQ0o7QUF6Rkk7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhROztBQWNaO0FBQ0E7QUFDSTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBOztBQUVBO0FBNURLOzs7Ozs7Ozs7O0FDQVQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNNO0FBQ0E7QUFDQTtBQUNBO0FBWlE7O0FBZVo7QUFDSTtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSDs7QUFFRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0E7QUFDQTtBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDSTtBQUNBO0FBQ0g7QUFFRztBQUNBO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ1M7QUFDQTtBQUNBO0FBQ1Q7QUFDTTtBQUNKO0FBQ0o7QUFDRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBSE87QUFLWDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSTtBQUNJO0FBQ0g7QUFDSjtBQUVHO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFDSjtBQUVHO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0E7QUFDQTtBQUhPO0FBS1g7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0k7QUFDSTtBQUNIO0FBRUc7QUFDQTtBQUNJO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUZPO0FBSVg7QUFDSDtBQUNEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBSE87QUFLWDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0k7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFKTztBQU1YO0FBQ0g7QUF6TEk7Ozs7Ozs7Ozs7QUNBVDtBQUNJOztBQUVBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVhROztBQWVaO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0g7O0FBckNJOzs7Ozs7Ozs7O0FDQVQ7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDs7QUFFRDtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUNEO0FBQ0g7O0FBRUQ7QUFDSTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNIOztBQUVEO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7O0FBRUE7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaUTs7QUFlWjtBQUNBO0FBQ0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCQTtBQUNJO0FBQ0E7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNIO0FBRUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDSjs7QUFFRDtBQUNJO0FBQ0k7QUFDQTtBQUNBO0FBQ0k7QUFDQTtBQUNIO0FBQ0Q7QUFDSTtBQUNBO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNIO0FBQ0Q7QUFDQTtBQUNJO0FBQ0g7QUFFRztBQUNIO0FBR0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNBO0FBQ0k7QUFDSDtBQUVHO0FBQ0g7QUFHSjs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBSUc7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUNKO0FBQ0Q7QUFDSDs7QUFFRDtBQUdBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNJO0FBQ0g7QUFFRztBQUNBO0FBQ0k7QUFDSDtBQUNKO0FBQ0o7QUE5TEk7Ozs7Ozs7Ozs7QUN6RVQ7QUFDSTs7QUFFQTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFqQlE7O0FBb0JaO0FBQ0E7O0FBRUk7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNJO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBO0FBQ0k7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7O0FBRUQ7QUFDSTtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUVHO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDQTtBQUNBO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7QUFDSTtBQUNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0g7QUFDRDtBQUNIOztBQUVEO0FBQ0k7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSTtBQUNJO0FBQ0k7QUFDSDtBQUNEO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSDtBQUNKOztBQUVEO0FBQ0k7QUFDQTtBQUNJO0FBQ0E7QUFDSDtBQUVHO0FBQ0E7QUFDSDtBQUNKO0FBQ0o7QUF6SEk7Ozs7Ozs7Ozs7QUNBVDtBQUNJO0FBQ0E7QUFDSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaUTs7QUFlWjtBQUNBO0FBQ0k7QUFDSTtBQUNIOztBQUVEO0FBQ0E7QUFDSDs7QUFFRDtBQUNBO0FBQ0k7QUFDSDs7QUFFRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0Q7QUFDSTtBQUNJO0FBQ0g7QUFDRDtBQUNIO0FBQ0o7QUFDRDtBQUNJO0FBQ0E7QUFDSTtBQUNIO0FBQ0o7QUFqREk7Ozs7Ozs7Ozs7Ozs7QUNBVDtBQUNDO0FBQWE7QUFBMkQ7QUFBbUI7QUFBZ0Q7QUFBYTtBQUFLO0FBQXNDO0FBQVM7QUFBcUM7QUFBUztBQUFtQztBQUFPO0FBQUs7QUFBTztBQUFXO0FBQUM7QUFBYTtBQUFvRDtBQUFnQjtBQUFVO0FBQVU7QUFBc0s7QUFBMkQ7QUFBaUM7QUFBc0I7QUFBb0I7QUFBcUU7QUFBM0I7QUFBNEM7O0FBRW55QjtBQUVDOztBQUVEOztBQUVBOzs7Ozs7QUFNQTtBQUVDO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7O0FBRUQ7O0FBR0E7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7O0FBRUQ7QUFDRDs7QUFFRDs7QUFFQTs7OztBQUlBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkJzQzs7QUEwQnJDO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNEOztBQUVEOzs7OztBQUtBO0FBQ0U7QUFDQTtBQUNEO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFDRTtBQUNGO0FBQ0U7QUFDRDs7QUFFQTtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBOztBQUVBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUVEO0FBQ0U7QUFFRjtBQUNFO0FBRUY7QUFDRTtBQUVGO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUFBO0FBQUE7O0FBSUE7O0FBRUE7QUFDRDtBQUNFO0FBQ0E7QUFDRDtBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNDOztBQUVEO0FBQ0Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7QUFDQTtBQUNEO0FBQ0M7O0FBRUQ7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUVEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7QUFDQztBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNFO0FBQ0Q7QUFDQTs7QUFFQztBQUNEO0FBQ0E7QUFDQTs7QUFFQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVDO0FBQ0Q7QUFDQTtBQUNBO0FBbkJEO0FBcUJFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTtBQUVFO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDtBQUNFOztBQUVEO0FBQ0E7O0FBRUE7QUFDRDtBQUNBO0FBQ0E7QUFIYztBQUtiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDs7QUFFQTs7QUFFQTtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNDO0FBQ0Y7QUFDQztBQUNEO0FBQ0M7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDtBQUNBO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDRDtBQUVBO0FBQ0E7QUFDRDs7OztBQUlBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7OztBQVFBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNEO0FBRUE7QUFDRDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTtBQUNBOztBQUVBOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNEO0FBQ0U7QUFDRjtBQUNBO0FBQ0U7QUFDRjtBQUVBO0FBQ0E7QUFDRDs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7QUFPQTtBQUNFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNFOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNGOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7QUFDRTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTs7QUFFQTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNFO0FBRUY7QUFDRTtBQUNEOztBQUVBOztBQUVBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTs7QUFFQTtBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRTs7QUFFRDs7QUFFQTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7QUFFQTtBQUNBO0FBQ0U7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7QUFDRTtBQUNEO0FBQ0U7QUFDRjtBQUNDO0FBQ0Y7QUFDRTtBQUNGO0FBRUE7QUFDQTtBQUNEO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7Ozs7O0FBT0E7QUFDRTs7QUFFQTtBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNFO0FBQ0Q7O0FBRUQ7QUFFQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDRDtBQUNFO0FBQ0Q7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0U7QUFDRjtBQUNDO0FBQ0Y7QUFDRDtBQUNFO0FBQ0E7QUFDQTtBQUNEOztBQUVEO0FBQ0U7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNEO0FBQ0M7QUFDRjs7QUFFRDtBQUNBO0FBQ0U7QUFDRDs7QUFFRDtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7QUFDRTtBQUNGO0FBQ0M7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRjtBQUNDO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDRTtBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNDO0FBQ0Q7QUFDRTtBQUNGO0FBQ0U7QUFDRDtBQUNDO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDRDtBQUNDO0FBQ0Y7QUFDQztBQUNGO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0U7QUFDRjs7QUFFRDtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRjtBQUVBO0FBQ0E7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUNEOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTs7QUFFQTs7QUFFQTtBQUNEO0FBQ0E7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRjs7QUFFRDtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0M7QUFDRjtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDs7QUFFRDtBQUNBO0FBQ0U7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7O0FBRUE7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDRDtBQUNFOztBQUVEOztBQUVBO0FBQ0E7QUFFRDtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUVBO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7QUFDRTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFGWTs7QUFLWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFOztBQUVEOztBQUVBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0U7O0FBRUQ7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTs7QUFFQTtBQUNEO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7OztBQU9BO0FBRUU7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7QUFDQztBQUNGOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDQztBQUNEOztBQUVEO0FBQ0U7QUFDRjtBQUNDOztBQUVEO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0M7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7QUFDRTtBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBRUQ7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7QUFDRTs7QUFFRDs7QUFFQTtBQUNBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0Q7QUFFQTtBQUNBO0FBQ0Q7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUNDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7O0FBRUQ7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNGO0FBRUE7QUFDRDs7QUFFQTtBQUNDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNDO0FBQ0M7QUFDQTtBQUNEOztBQUVBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7O0FBRUQ7QUFFQztBQUNEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0E7O0FBRUE7QUFBeUI7QUFBdUM7O0FBRWhFO0FBQWlCO0FBQWlCO0FBQ2xDO0FBQWU7QUFBZTtBQUM5QjtBQUFtQjtBQUFjOztBQUVqQztBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7QUFFQTtBQUNEOzs7Ozs7O0FBT0E7QUFDRTs7QUFFQTtBQUNEO0FBQUE7QUFBQTtBQUFBOztBQUdBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDtBQUNFO0FBQ0Q7QUFDQztBQUNEOztBQUVEO0FBQ0U7O0FBRUQ7QUFDRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUlBO0FBQ0U7QUFDQTtBQUNEO0FBQ0U7QUFDRjs7QUFFRDtBQUFBOztBQUdBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNGO0FBRUE7QUFDRDtBQUNBOzs7O0FBSUE7O0FBS0E7Ozs7QUFJQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEOzs7OztBQUtBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7QUFJQTs7QUFJQTs7Ozs7O0FBTUE7QUFDRTtBQUNEO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0M7QUFDRjs7QUFFRDtBQUNFOztBQUVBO0FBQ0E7O0FBRUE7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNEO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRTtBQUNGO0FBRUE7QUFDQTs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNEO0FBQ0U7QUFDRDtBQUNEOztBQUVEOzs7Ozs7Ozs7QUFTQTtBQUVFO0FBQ0E7QUFFQTtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFDRTtBQUNBOztBQUVBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFJRTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQUE7O0FBR0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNEO0FBRUE7O0FBRUQ7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7O0FBRUQ7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUtBOzs7O0FBSUE7O0FBU0E7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0E7QUFDQztBQUNEOztBQUVEOzs7O0FBSUE7QUFDRTtBQUNEOztBQUdEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7O0FBRUE7O0FBT0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNDOztBQUVEO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBR0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDRDs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7Ozs7OztBQVdBO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7QUFFQTs7QUFFRDs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTs7QUFFRTtBQUNBO0FBRUE7O0FBRUE7QUFDQTs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNEOztBQUVEO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNDO0FBQ0Q7QUFDQztBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNDO0FBQ0Q7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDRDtBQUVBO0FBQ0Q7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQU9BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTtBQUNDO0FBRCtCO0FBQUE7QUFJNUI7QUFDQTtBQUNBO0FBQ0E7QUFQNEI7O0FBVWhDOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7QUFDQTtBQUNFOztBQUVEOztBQUlBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Q7QUFDRTs7QUFFRDtBQUVEOztBQUVEO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTtBQUNFO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDRDs7QUFFRDtBQUNFO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7QUFDRDs7QUFFRDtBQUNFO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNEO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7QUFDRDs7QUFFQTtBQUNFO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNFOztBQUVEOztBQUVBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7O0FBRUE7QUFDRDtBQUNFO0FBQ0Q7O0FBRUQ7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7O0FBRUQ7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7O0FBRUQ7QUFDRDtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7QUFJQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRDtBQUNFO0FBQ0E7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7QUFDRTtBQUNGOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0U7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFBQTtBQUFBOztBQUdBO0FBQ0Q7O0FBRUE7QUFDRTtBQUNEO0FBQ0M7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7O0FBRUE7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDs7QUFFQTtBQUNFO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Q7QUFDQzs7QUFFRDtBQUNEO0FBQ0E7QUFDRTtBQUVGOztBQUVEOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0U7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7O0FBRUQ7QUFDRDtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFDRTs7QUFFRDtBQUFnQjtBQUNqQjtBQUNFO0FBQVE7QUFDVjtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7QUFDRjs7QUFFRDtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7QUFJQTtBQUNFO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDRTs7QUFFRDs7QUFJQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7O0FBRUE7QUFDRDtBQUNBO0FBQ0U7QUFDRjtBQUNDOztBQUVEO0FBQ0Q7QUFDRTtBQUNGOztBQUVEOzs7Ozs7Ozs7QUFTQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNFOztBQUVBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0M7QUFDRjs7QUFFRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7QUFDRjtBQUVBO0FBQ0E7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7O0FBRUE7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7QUFFQTtBQUNEOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7O0FBRUU7QUFDRDs7QUFFQTtBQUtFO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0Y7QUFDQztBQUNEO0FBQ0U7O0FBRUQ7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNGOztBQUVEO0FBQ0U7O0FBRUQ7QUFDRDtBQUVBO0FBQ0E7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUVEO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFFQTs7QUFFRDs7QUFFQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDRDtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBRUE7QUFDRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNFO0FBQ0E7QUFDQTtBQUdEOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQWxDRDtBQW9DRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBS0Q7O0FBRUQ7Ozs7QUFJQTtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBRUE7QUFDRDtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0U7QUFDRDtBQUNFOztBQUVEOztBQUVBO0FBQ0E7QUFDRDtBQUNFOztBQUVEO0FBR0Q7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNEOzs7Ozs7OztBQVFBO0FBQ0U7O0FBRUE7QUFDRDtBQUNFO0FBQ0E7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFFQTtBQUNEOzs7Ozs7O0FBT0E7O0FBRUE7O0FBSUE7QUFDQztBQUFBO0FBQUE7O0FBSUE7QUFDQztBQUNBOztBQUVEO0FBQUE7QUFBQTs7QUFJQTtBQUNDO0FBQ0E7O0FBRUQ7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0E7QUFFQTtBQUNEO0FBQ0E7QUFDQTs7QUFFQztBQUNBOztBQUVBO0FBQ0E7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBOztBQUVEOztBQUVBOztBQUVBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQWtDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Q7QUFDRDtBQUNBOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNEO0FBQ0E7O0FBRUQ7QUFDQztBQUNDO0FBSUE7QUFDRDtBQUNEOztBQUVBO0FBQ0M7QUFDQTs7QUFFRDtBQUNDO0FBQXFDO0FBQ3BDO0FBQ0E7QUFDRDtBQUNBO0FBQXFDO0FBQ3BDO0FBQ0E7QUFDeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7O0FBRUQ7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDRDtBQUNBOztBQUVEOztBQUVBO0FBQ0M7QUFDQztBQUNBOztBQUVEO0FBQ0E7O0FBRUE7QUFDQztBQUNBOztBQUVEO0FBQ0E7QUFDQTs7QUFFRDtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQztBQUNBOztBQUVEO0FBQ0M7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNDO0FBQ0E7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0M7QUFDQTtBQUNEOztBQUVEO0FBQ0E7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNBO0FBQ0Q7QUFDQTs7QUFFRDs7QUFFQTtBQUNDO0FBQ0E7QUFDQTtBQUhVOztBQU1YO0FBQ0E7QUFDQTtBQUtDO0FBQ0M7QUFDQTtBQUNEO0FBQ0E7QUFBa0I7QUFDakI7QUFDQTtBQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0M7QUFDQTtBQUNEO0FBQ0Q7QUFBUTtBQUNSO0FBQ0E7QUFFRDtBQUVBO0FBQ0E7QUFDRDs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBT0E7Ozs7Ozs7QUFPQTtBQUNFOztBQUVBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFOztBQUVBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFOztBQUVBO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUF3QjtBQUF4QjtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQzs7QUFFRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQWFBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUdBOztBQUVBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Y7QUFDRTtBQUNBO0FBQ0Q7QUFDRDtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BOztBQUVBOzs7Ozs7O0FBT0E7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFFQzs7QUFFRDs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFINEI7QUFLM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDQztBQUNGOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRjs7QUFFRDs7OztBQUlBOztBQUVBOzs7Ozs7OztBQVFBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRjs7QUFHRDs7Ozs7Ozs7QUFRQTtBQUVFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7QUFDRDtBQUNDOztBQUVEO0FBQ0E7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNEO0FBQ0U7QUFIWTtBQUtiOztBQUVEO0FBQ0E7O0FBRUE7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNEOztBQUVEO0FBQ0U7QUFDQTtBQUNEO0FBQ0M7O0FBRUQ7QUFDRDtBQUNFO0FBQ0Q7QUFDQzs7QUFFRDtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0E7QUFDQTs7QUFFQTtBQUNEOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBOztBQUVBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNFO0FBQ0Q7QUFDQTtBQUNEO0FBQ0M7QUFBUTtBQUNWO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTs7QUFFQTtBQUNBO0FBQWdDO0FBQWhDO0FBR0E7QUFDQTs7QUFFQTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNEO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7O0FBTUE7QUFDRTs7QUFFQTs7QUFFQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNEO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0E7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7QUFDRTtBQUNEO0FBQ0U7QUFIWTtBQUtiO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBRUE7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBSE87QUFLUjtBQUVBOztBQUVEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiVzs7QUFnQmI7Ozs7QUFJQTs7QUFFQTs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0U7O0FBRUE7QUFDQTtBQUtEOztBQUVEOzs7Ozs7QUFNQTtBQUVFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7O0FBU0E7QUFDRTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7QUFBb0I7QUFBbUM7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7O0FBRUQ7QUFDRDtBQUNFO0FBQ0Y7QUFDRTs7QUFFRDs7QUFFQTtBQUNEOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTs7QUFFQTtBQUNEO0FBQ0U7QUFDQTs7QUFFRjtBQUNFO0FBQ0E7O0FBRUY7QUFDRTtBQUNBOztBQUVGO0FBQ0U7QUFDQTs7QUFFRjtBQUNFO0FBQ0E7O0FBRUY7QUFDRTtBQUNBOztBQUVGO0FBQ0U7QUFDQTtBQTNCRDtBQTZCRDs7QUFFRDs7Ozs7OztBQU9BO0FBQ0U7QUFDQTs7QUFFQTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBSFU7QUFLVjtBQUNGOztBQUVEOzs7Ozs7O0FBT0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNEOztBQUVBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEOztBQUVEOzs7Ozs7O0FBT0E7QUFFRTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBOztBQUVBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBRUE7QUFDRDs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEO0FBQ0U7QUFDQTtBQUNEO0FBQ0U7QUFDRjtBQUNFO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUVDO0FBQ0Q7QUFDQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Q7QUFFQTtBQUNBOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDs7QUFFRDs7Ozs7O0FBTUE7QUFDRTtBQUNEOztBQUVEOzs7Ozs7QUFNQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDtBQUdBO0FBQ0Q7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0U7QUFDRjtBQUVBOztBQUVEOzs7O0FBSUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0U7QUFDRDs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBRUU7QUFDQTtBQUVBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUE7QUFJRTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQUE7O0FBR0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNDOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7O0FBUUE7QUFDRTtBQUNEO0FBRUE7QUFDRDtBQUNDO0FBQ0Q7QUFDQztBQUNEOztBQUVBOzs7O0FBSUE7O0FBRUE7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7O0FBU0E7O0FBRUU7QUFDRDs7QUFFQTtBQUtFO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNDO0FBQ0M7QUFDQTtBQUNEO0FBQ0Y7QUFDQztBQUNBO0FBQ0Q7QUFDRTs7QUFFRDtBQUNEO0FBQ0U7QUFDRDtBQUNDO0FBQ0Y7O0FBRUQ7QUFDRTs7QUFFRDtBQUNEO0FBRUE7QUFDQTtBQUNEO0FBQ0M7QUFDRDtBQUNDO0FBQ0Q7QUFDQztBQUNEO0FBQ0M7QUFDRDtBQUNBOztBQUVBOzs7O0FBSUE7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQVVBO0FBQ0U7QUFDQTs7QUFFQTtBQUNEOztBQUVBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7QUFDQztBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBO0FBQ0U7O0FBRUE7QUFDRDtBQUNFO0FBQ0E7QUFDRDtBQUNDO0FBQ0Q7QUFDRTtBQUNEO0FBQ0Q7QUFDQztBQUNEO0FBQ0U7QUFDRDtBQUNEO0FBQ0Q7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0U7QUFDRDs7QUFFQTtBQUNBO0FBRUU7O0FBRUE7QUFDQTtBQUNBO0FBQWlDO0FBQ2xDO0FBQ0U7QUFDRDtBQUVDO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNFO0FBQ0Q7QUFDQzs7QUFFRDtBQUNEO0FBQTBCO0FBQ3pCO0FBQ0Q7QUFDRTtBQUNGO0FBQTBEO0FBQ3pEO0FBQ0Q7QUFDRTtBQUNGO0FBQ0M7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFFQTtBQUNBOztBQUVEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBVUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7Ozs7OztBQU1BOztBQUVBOzs7Ozs7Ozs7O0FBVUE7QUFDRTs7QUFFQTtBQUNEO0FBQ0U7QUFFRjtBQUNBO0FBQ0U7QUFDRjs7QUFFRDs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTs7QUFFRDtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0Q7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEOztBQUVEOzs7Ozs7Ozs7O0FBVUE7O0FBRUU7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNFOztBQUVEO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQTtBQUNFO0FBQ0Q7O0FBRUQ7Ozs7QUFJQTs7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQWdGO0FBQzlFOztBQUVBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFBUTtBQUNQO0FBQ0Q7QUFDQztBQUNvQztBQUN0QztBQUNFO0FBQ0Q7QUFDQztBQUNBO0FBQWM7QUFDZjtBQUNBO0FBQ0U7QUFDRjtBQUNDO0FBRUY7QUFDRTtBQUNGOztBQUVEOzs7Ozs7OztBQVFBO0FBQ0U7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDRDtBQUNFO0FBQ0Q7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0Y7QUFDRTs7QUFFRDtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRDtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNEO0FBQ0U7QUFDRDtBQUNDO0FBQ0Q7QUFDQzs7QUFFRDtBQUNBO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDRDtBQUNFO0FBQ0Y7O0FBRUQ7Ozs7Ozs7Ozs7QUFVQTtBQUNFO0FBQ0E7QUFDRDs7QUFFRDs7Ozs7Ozs7OztBQVVBO0FBQ0U7QUFDQTtBQUF5RDtBQUMxRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7Ozs7OztBQU1BO0FBQ0U7QUFDQTtBQUNEOztBQUVEO0FBQ0U7QUFDRDtBQUNBO0FBRlE7QUFJUjtBQUVBO0FBQ0Q7O0FBRUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0U7QUFFRDtBQUVBO0FBQ0E7QUFDRDtBQUNDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNBO0FBRm1COztBQUtsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTs7QUFHQTtBQUNEO0FBQ0U7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBU0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBSUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFBQTtBQUNBO0FBQ0E7QUFDRTtBQUFBO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDRDtBQUNDO0FBQ0Q7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0Q7QUFDRDtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNGO0FBQ0M7QUFDRjtBQUNDO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7O0FBRUQ7QUFDRTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFPQTtBQUNBOztBQUVBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDQzs7QUFFRDtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQUE7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUhvRDtBQUtwRDtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0E7QUFDRDtBQUNDOztBQUVEO0FBQ0E7QUFDQTtBQUNEO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0Q7O0FBRUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Y7QUFDQztBQUNBO0FBQ0Q7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNGO0FBQ0M7QUFDRjtBQUNDO0FBQ0E7QUFDRDtBQUFBO0FBQUE7QUFDQTtBQUNFO0FBQ0Q7QUFDRTtBQUNGO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNDO0FBQ0Y7QUFDRDtBQUNFOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUFk7O0FBVWQ7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDRDs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDQTtBQUNDO0FBQ0Q7QUFDRTtBQUNBO0FBQ0Q7QUFDRDtBQVREO0FBV0U7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDQTtBQUVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNGO0FBQ0U7QUFDRjtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNDO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7QUFDRTtBQUNEO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0Q7QUFDRDtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDRTtBQUNGOztBQUVEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNEO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFDQztBQUNEO0FBQ0M7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0M7O0FBRUQ7QUFDQTtBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSYzs7QUFXaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0U7QUFDQTtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0M7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0Q7QUFDQTtBQUNBO0FBQ0M7QUFDRDtBQUNBO0FBekJEO0FBMkJFO0FBQ0Y7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDRDtBQUNEO0FBQ0E7QUFDQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDQTtBQUNEO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNBO0FBQ0Q7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0Q7QUFDQztBQUNBO0FBQ0Q7QUFDRDtBQUNBO0FBakpEO0FBbUpFO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDQTtBQUNEO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDQTtBQUNEO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNDO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRDtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0U7QUFDRDtBQUNEO0FBQ0M7QUFDQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0U7QUFDRDtBQUNEO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNDO0FBQ0Y7QUFDQTtBQUNFO0FBQ0Y7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ0Q7QUFDRDtBQUNFO0FBQ0Q7QUFDRDtBQUNEO0FBQ0E7QUFDRTtBQUNEO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNFO0FBQ0E7QUFDRDtBQUNFO0FBQ0Y7QUFDRTtBQUNGOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFBQTtBQUNBO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDRTtBQUNEO0FBQ0U7QUFDRjtBQUNDO0FBQ0Q7QUFDRTtBQUNGO0FBQ0M7QUFDRDtBQUNEOztBQUVEO0FBQ0E7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRDtBQUNFO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Q7QUFDQztBQUNGOztBQUVEO0FBQ0E7QUFDRTs7QUFFRDtBQUNEO0FBQ0E7QUFDRTtBQUNGO0FBQ0E7QUFBQTtBQUFBOztBQUlBO0FBQ0U7QUFDQTtBQUNBO0FBQ0Q7QUFDRTtBQUNBO0FBQ0E7QUFDQTtBQUNEO0FBQ0Q7QUFDRTtBQVg2Qzs7QUFjaEQ7QUFDRTtBQUNBO0FBRlU7QUFJVjs7QUFFRDtBQUNBO0FBQ0Q7QUFDRTtBQUNEO0FBQ0M7QUFDRjtBQUVBO0FBQ0E7QUFDRDs7QUFFQTtBQUNDOztBQUVBOztBQUVBO0FBQ0M7QUFDQTs7QUFFRDtBQUNBO0FBRUE7QUFDQTtBQUNEIiwic291cmNlc0NvbnRlbnQiOlsiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICAgICAgX2FsZXJ0Om51bGwsXG4gICAgICAgIF9idG5PSzpudWxsLFxuICAgICAgICBfYnRuQ2FuY2VsOm51bGwsXG4gICAgICAgIF90aXRsZTpudWxsLFxuICAgICAgICBfY29udGVudDpudWxsLFxuICAgICAgICBfb25vazpudWxsLFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYWxlcnQgPSBjYy5maW5kKFwiQ2FudmFzL2FsZXJ0XCIpO1xuICAgICAgICB0aGlzLl90aXRsZSA9IGNjLmZpbmQoXCJDYW52YXMvYWxlcnQvdGl0bGVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNjLmZpbmQoXCJDYW52YXMvYWxlcnQvY29udGVudFwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fYnRuT0sgPSBjYy5maW5kKFwiQ2FudmFzL2FsZXJ0L2J0bl9va1wiKTtcbiAgICAgICAgdGhpcy5fYnRuQ2FuY2VsID0gY2MuZmluZChcIkNhbnZhcy9hbGVydC9idG5fY2FuY2VsXCIpO1xuICAgICAgICBcbiAgICAgICAgY2MudnYudXRpbHMuYWRkQ2xpY2tFdmVudCh0aGlzLl9idG5PSyx0aGlzLm5vZGUsXCJBbGVydFwiLFwib25CdG5DbGlja2VkXCIpO1xuICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KHRoaXMuX2J0bkNhbmNlbCx0aGlzLm5vZGUsXCJBbGVydFwiLFwib25CdG5DbGlja2VkXCIpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fYWxlcnQuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGNjLnZ2LmFsZXJ0ID0gdGhpcztcbiAgICB9LFxuICAgIFxuICAgIG9uQnRuQ2xpY2tlZDpmdW5jdGlvbihldmVudCl7XG4gICAgICAgIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuX29rXCIpe1xuICAgICAgICAgICAgaWYodGhpcy5fb25vayl7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25vaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2FsZXJ0LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9vbm9rID0gbnVsbDtcbiAgICB9LFxuICAgIFxuICAgIHNob3c6ZnVuY3Rpb24odGl0bGUsY29udGVudCxvbm9rLG5lZWRjYW5jZWwsb2tzdHIsY2FuY2Vsc3RyKXtcbiAgICAgICAgdGhpcy5fYWxlcnQuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb25vayA9IG9ub2s7XG4gICAgICAgIHRoaXMuX3RpdGxlLnN0cmluZyA9IHRpdGxlO1xuICAgICAgICB0aGlzLl9jb250ZW50LnN0cmluZyA9IGNvbnRlbnQ7XG4gICAgICAgIGlmKG5lZWRjYW5jZWwpe1xuICAgICAgICAgICAgdGhpcy5fYnRuQ2FuY2VsLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9idG5PSy54ID0gLTE1MDtcbiAgICAgICAgICAgIHRoaXMuX2J0bkNhbmNlbC54ID0gMTUwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0aGlzLl9idG5DYW5jZWwuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9idG5PSy54ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIG9rc3RyICkge1xuICAgICAgICAgICAgdGhpcy5fYnRuT0suZ2V0Q2hpbGRCeU5hbWUoXCJOZXcgTGFiZWxcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBva3N0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGNhbmNlbHN0ciApIHtcbiAgICAgICAgICAgIHRoaXMuX2J0bkNhbmNlbC5nZXRDaGlsZEJ5TmFtZShcIk5ldyBMYWJlbFwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGNhbmNlbHN0cjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgb25EZXN0b3J5OmZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKGNjLnZ2KXtcbiAgICAgICAgICAgIGNjLnZ2LmFsZXJ0ID0gbnVsbDsgICAgXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG5cbiAgICAvLyB9LFxufSk7XG4iLCJjYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICAvLyBmb286IHtcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCwgICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZSB3aWxsIGJlIHVzZWQgb25seSB3aGVuIHRoZSBjb21wb25lbnQgYXR0YWNoaW5nXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gYSBub2RlIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgICAgICBfaXNDYXB0dXJpbmc6ZmFsc2UsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgIH0sXG5cbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG5cbiAgICAvLyB9LFxuICAgIFxuICAgIFxuXG4gICAgXG4gICAgaW5pdDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLkFORFJPSURfQVBJID0gXCJjb20vdml2aWdhbWVzL3NjbWovV1hBUElcIjtcbiAgICAgICAgdGhpcy5JT1NfQVBJID0gXCJBcHBDb250cm9sbGVyXCI7XG4gICAgICAgIHRoaXMuQU5EUk9JRF9XRUJQQUdFX0FQSSA9IFwib3JnL2NvY29zMmR4L2phdmFzY3JpcHQvQXBwQWN0aXZpdHlcIjtcbiAgICB9LFxuICAgIFxuICAgIG9wZW5Eb3dubG9hZFBhZ2U6ZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIm9wZW4gd2VicGFnZSEhIVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coY2Muc3lzLm9zKTtcbiAgICAgICAgY29uc29sZS5sb2coY2Muc3lzLk9TX0FORFJPSUQpO1xuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJvcGVuIHdlYnBhZ2UgT1NfQU5EUk9JRCEhIVwiKTtcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QodGhpcy5BTkRST0lEX1dFQlBBR0VfQVBJLCBcIm9wZW5Eb3dubG9hZFBhZ2VcIiwgXCIoTGphdmEvbGFuZy9TdHJpbmc7KVZcIixjYy52di5TSS5hcHB3ZWIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1Mpe1xuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZCh0aGlzLklPU19BUEksIFwib3BlbkRvd25sb2FkUGFnZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwbGF0Zm9ybTpcIiArIGNjLnN5cy5vcyArIFwiIGRvc24ndCBpbXBsZW1lbnQgc2hhcmUuXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBsb2dpbjpmdW5jdGlvbigpe1xuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpeyBcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QodGhpcy5BTkRST0lEX0FQSSwgXCJMb2dpblwiLCBcIigpVlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfSU9TKXtcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QodGhpcy5JT1NfQVBJLCBcImxvZ2luXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBsYXRmb3JtOlwiICsgY2Muc3lzLm9zICsgXCIgZG9zbid0IGltcGxlbWVudCBzaGFyZS5cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNoYXJlOmZ1bmN0aW9uKHRpdGxlLGRlc2Mpe1xuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpe1xuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZCh0aGlzLkFORFJPSURfQVBJLCBcIlNoYXJlXCIsIFwiKExqYXZhL2xhbmcvU3RyaW5nO0xqYXZhL2xhbmcvU3RyaW5nO0xqYXZhL2xhbmcvU3RyaW5nOylWXCIsY2MudnYuU0kuYXBwd2ViLHRpdGxlLGRlc2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1Mpe1xuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZCh0aGlzLklPU19BUEksIFwic2hhcmU6c2hhcmVUaXRsZTpzaGFyZURlc2M6XCIsY2MudnYuU0kuYXBwd2ViLHRpdGxlLGRlc2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBsYXRmb3JtOlwiICsgY2Muc3lzLm9zICsgXCIgZG9zbid0IGltcGxlbWVudCBzaGFyZS5cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNoYXJlT25UaW1lbGluZTpmdW5jdGlvbih0aXRsZSxkZXNjKXtcbiAgICAgICAgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19BTkRST0lEKXtcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QodGhpcy5BTkRST0lEX0FQSSwgXCJTaGFyZU9uVGltZWxpbmVcIiwgXCIoTGphdmEvbGFuZy9TdHJpbmc7TGphdmEvbGFuZy9TdHJpbmc7TGphdmEvbGFuZy9TdHJpbmc7KVZcIixjYy52di5TSS5hcHB3ZWIsdGl0bGUsZGVzYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0lPUyl7XG4gICAgICAgICAgICBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKHRoaXMuSU9TX0FQSSwgXCJzaGFyZXRpbWVsaW5lOnNoYXJlVGl0bGU6c2hhcmVEZXNjOlwiLGNjLnZ2LlNJLmFwcHdlYix0aXRsZSxkZXNjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwbGF0Zm9ybTpcIiArIGNjLnN5cy5vcyArIFwiIGRvc24ndCBpbXBsZW1lbnQgc2hhcmUuXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBjb3B5OmZ1bmN0aW9uIChkZXNjKSB7XG4gICAgICAgIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfQU5EUk9JRCl7XG4gICAgICAgICAgICBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKHRoaXMuQU5EUk9JRF9XRUJQQUdFX0FQSSwgXCJDb3B5XCIsIFwiKExqYXZhL2xhbmcvU3RyaW5nOylWXCIsZGVzYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0lPUyl7XG4gICAgICAgICAgICBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKHRoaXMuSU9TX0FQSSwgXCJjb3B5OlwiLGRlc2MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBsYXRmb3JtOlwiICsgY2Muc3lzLm9zICsgXCIgZG9zbid0IGltcGxlbWVudCBzaGFyZS5cIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNoYXJlUmVzdWx0OmZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKHRoaXMuX2lzQ2FwdHVyaW5nKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0NhcHR1cmluZyA9IHRydWU7XG4gICAgICAgIHZhciBzaXplID0gY2MuZGlyZWN0b3IuZ2V0V2luU2l6ZSgpO1xuICAgICAgICB2YXIgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBcInJlc3VsdF9zaGFyZS5qcGdcIjtcbiAgICAgICAgdmFyIGZ1bGxQYXRoID0ganNiLmZpbGVVdGlscy5nZXRXcml0YWJsZVBhdGgoKSArIGZpbGVOYW1lO1xuICAgICAgICBpZihqc2IuZmlsZVV0aWxzLmlzRmlsZUV4aXN0KGZ1bGxQYXRoKSl7XG4gICAgICAgICAgICBqc2IuZmlsZVV0aWxzLnJlbW92ZUZpbGUoZnVsbFBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0ZXh0dXJlID0gbmV3IGNjLlJlbmRlclRleHR1cmUoTWF0aC5mbG9vcihzaXplLndpZHRoKSwgTWF0aC5mbG9vcihzaXplLmhlaWdodCkpO1xuICAgICAgICB0ZXh0dXJlLnNldFBvc2l0aW9uKGNjLnAoc2l6ZS53aWR0aC8yLCBzaXplLmhlaWdodC8yKSk7XG4gICAgICAgIHRleHR1cmUuYmVnaW4oKTtcbiAgICAgICAgY2MuZGlyZWN0b3IuZ2V0UnVubmluZ1NjZW5lKCkudmlzaXQoKTtcbiAgICAgICAgdGV4dHVyZS5lbmQoKTtcbiAgICAgICAgdGV4dHVyZS5zYXZlVG9GaWxlKGZpbGVOYW1lLCBjYy5JTUFHRV9GT1JNQVRfSlBHKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHRyeVRpbWVzID0gMDtcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGlmKGpzYi5maWxlVXRpbHMuaXNGaWxlRXhpc3QoZnVsbFBhdGgpKXtcbiAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gMTAwO1xuICAgICAgICAgICAgICAgIHZhciBzY2FsZSA9IGhlaWdodC9zaXplLmhlaWdodDtcblx0XHRcdCAgICB2YXIgd2lkdGggPSBNYXRoLmZsb29yKHNpemUud2lkdGggKiBzY2FsZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19BTkRST0lEKXtcbiAgICAgICAgICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChzZWxmLkFORFJPSURfQVBJLCBcIlNoYXJlSU1HXCIsIFwiKExqYXZhL2xhbmcvU3RyaW5nO0lJKVZcIixmdWxsUGF0aCx3aWR0aCxoZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfSU9TKXtcbiAgICAgICAgICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChzZWxmLklPU19BUEksIFwic2hhcmVJTUc6d2lkdGg6aGVpZ2h0OlwiLGZ1bGxQYXRoLHdpZHRoLGhlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicGxhdGZvcm06XCIgKyBjYy5zeXMub3MgKyBcIiBkb3NuJ3QgaW1wbGVtZW50IHNoYXJlLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5faXNDYXB0dXJpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgdHJ5VGltZXMrKztcbiAgICAgICAgICAgICAgICBpZih0cnlUaW1lcyA+IDEwKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0aW1lIG91dC4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLDUwKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmbiw1MCk7XG4gICAgfSxcbiAgICBcbiAgICBvbkxvZ2luUmVzcDpmdW5jdGlvbihjb2RlKXtcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24ocmV0KXtcbiAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlID09IDApe1xuICAgICAgICAgICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInd4X2FjY291bnRcIixyZXQuYWNjb3VudCk7XG4gICAgICAgICAgICAgICAgY2Muc3lzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwid3hfc2lnblwiLHJldC5zaWduKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNjLnZ2LnVzZXJNZ3Iub25BdXRoKHJldCk7XG4gICAgICAgIH1cbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi93ZWNoYXRfYXV0aFwiLHtjb2RlOmNvZGUsb3M6Y2Muc3lzLm9zfSxmbik7XG4gICAgfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICAgICAgYmdtVm9sdW1lOjEuMCxcbiAgICAgICAgc2Z4Vm9sdW1lOjEuMCxcbiAgICAgICAgXG4gICAgICAgIGJnbUF1ZGlvSUQ6LTEsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHQgPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJiZ21Wb2x1bWVcIik7XG4gICAgICAgIGlmKHQgIT0gbnVsbCl7XG4gICAgICAgICAgICB0aGlzLmJnbVZvbHVtZSA9IHBhcnNlRmxvYXQodCk7ICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgdCA9IGNjLnN5cy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInNmeFZvbHVtZVwiKTtcbiAgICAgICAgaWYodCAhPSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuc2Z4Vm9sdW1lID0gcGFyc2VGbG9hdCh0KTsgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNjLmdhbWUub24oY2MuZ2FtZS5FVkVOVF9ISURFLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNjLmF1ZGlvRW5naW5lLnBhdXNlQWxsXCIpO1xuICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUucGF1c2VBbGwoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNjLmdhbWUub24oY2MuZ2FtZS5FVkVOVF9TSE9XLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNjLmF1ZGlvRW5naW5lLnJlc3VtZUFsbFwiKTtcbiAgICAgICAgICAgIGNjLmF1ZGlvRW5naW5lLnJlc3VtZUFsbCgpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbiAgICBcbiAgICBnZXRVcmw6ZnVuY3Rpb24odXJsKXtcbiAgICAgICAgcmV0dXJuIGNjLnVybC5yYXcoXCJyZXNvdXJjZXMvc291bmRzL1wiICsgdXJsKTtcbiAgICB9LFxuICAgIFxuICAgIHBsYXlCR00odXJsKXtcbiAgICAgICAgdmFyIGF1ZGlvVXJsID0gdGhpcy5nZXRVcmwodXJsKTtcbiAgICAgICAgY29uc29sZS5sb2coYXVkaW9VcmwpO1xuICAgICAgICBpZih0aGlzLmJnbUF1ZGlvSUQgPj0gMCl7XG4gICAgICAgICAgICBjYy5hdWRpb0VuZ2luZS5zdG9wKHRoaXMuYmdtQXVkaW9JRCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZ21BdWRpb0lEID0gY2MuYXVkaW9FbmdpbmUucGxheShhdWRpb1VybCx0cnVlLHRoaXMuYmdtVm9sdW1lKTtcbiAgICB9LFxuICAgIFxuICAgIHBsYXlTRlgodXJsKXtcbiAgICAgICAgdmFyIGF1ZGlvVXJsID0gdGhpcy5nZXRVcmwodXJsKTtcbiAgICAgICAgaWYodGhpcy5zZnhWb2x1bWUgPiAwKXtcbiAgICAgICAgICAgIHZhciBhdWRpb0lkID0gY2MuYXVkaW9FbmdpbmUucGxheShhdWRpb1VybCxmYWxzZSx0aGlzLnNmeFZvbHVtZSk7ICAgIFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzZXRTRlhWb2x1bWU6ZnVuY3Rpb24odil7XG4gICAgICAgIGlmKHRoaXMuc2Z4Vm9sdW1lICE9IHYpe1xuICAgICAgICAgICAgY2Muc3lzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwic2Z4Vm9sdW1lXCIsdik7XG4gICAgICAgICAgICB0aGlzLnNmeFZvbHVtZSA9IHY7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNldEJHTVZvbHVtZTpmdW5jdGlvbih2LGZvcmNlKXtcbiAgICAgICAgaWYodGhpcy5iZ21BdWRpb0lEID49IDApe1xuICAgICAgICAgICAgaWYodiA+IDApe1xuICAgICAgICAgICAgICAgIGNjLmF1ZGlvRW5naW5lLnJlc3VtZSh0aGlzLmJnbUF1ZGlvSUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBjYy5hdWRpb0VuZ2luZS5wYXVzZSh0aGlzLmJnbUF1ZGlvSUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9jYy5hdWRpb0VuZ2luZS5zZXRWb2x1bWUodGhpcy5iZ21BdWRpb0lELHRoaXMuYmdtVm9sdW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmJnbVZvbHVtZSAhPSB2IHx8IGZvcmNlKXtcbiAgICAgICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImJnbVZvbHVtZVwiLHYpO1xuICAgICAgICAgICAgdGhpcy5iZ21Wb2x1bWUgPSB2O1xuICAgICAgICAgICAgY2MuYXVkaW9FbmdpbmUuc2V0Vm9sdW1lKHRoaXMuYmdtQXVkaW9JRCx2KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgcGF1c2VBbGw6ZnVuY3Rpb24oKXtcbiAgICAgICAgY2MuYXVkaW9FbmdpbmUucGF1c2VBbGwoKTtcbiAgICB9LFxuICAgIFxuICAgIHJlc3VtZUFsbDpmdW5jdGlvbigpe1xuICAgICAgICBjYy5hdWRpb0VuZ2luZS5yZXN1bWVBbGwoKTtcbiAgICB9XG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgICAgICBfY2hhdFJvb3Q6bnVsbCxcbiAgICAgICAgX3RhYlF1aWNrOm51bGwsXG4gICAgICAgIF90YWJFbW9qaTpudWxsLFxuICAgICAgICBfaXB0Q2hhdDpudWxsLFxuICAgICAgICBcbiAgICAgICAgX3F1aWNrQ2hhdEluZm86bnVsbCxcbiAgICAgICAgX2J0bkNoYXQ6bnVsbCxcbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKGNjLnZ2ID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjYy52di5jaGF0ID0gdGhpcztcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2J0bkNoYXQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJidG5fY2hhdFwiKTtcbiAgICAgICAgdGhpcy5fYnRuQ2hhdC5hY3RpdmUgPSBjYy52di5yZXBsYXlNZ3IuaXNSZXBsYXkoKSA9PSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2NoYXRSb290ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiY2hhdFwiKTtcbiAgICAgICAgdGhpcy5fY2hhdFJvb3QuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl90YWJRdWljayA9IHRoaXMuX2NoYXRSb290LmdldENoaWxkQnlOYW1lKFwicXVpY2tjaGF0bGlzdFwiKTtcbiAgICAgICAgdGhpcy5fdGFiRW1vamkgPSB0aGlzLl9jaGF0Um9vdC5nZXRDaGlsZEJ5TmFtZShcImVtb2ppc1wiKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2lwdENoYXQgPSB0aGlzLl9jaGF0Um9vdC5nZXRDaGlsZEJ5TmFtZShcImlwdENoYXRcIikuZ2V0Q29tcG9uZW50KGNjLkVkaXRCb3gpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3F1aWNrQ2hhdEluZm8gPSB7fTtcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW0wXCJdID0ge2luZGV4OjAsY29udGVudDpcIuW/q+eCueWViu+8jOmDveetieWIsOaIkeiKseWEv+mDveiwouiwouS6hu+8gVwiLHNvdW5kOlwiZml4X21zZ18xLm1wM1wifTtcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW0xXCJdID0ge2luZGV4OjEsY29udGVudDpcIuaAjuS5iOWPiOaWree6v+S6hu+8jOe9kee7nOaAjuS5iOi/meS5iOW3ruWViu+8gVwiLHNvdW5kOlwiZml4X21zZ18yLm1wM1wifTtcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW0yXCJdID0ge2luZGV4OjIsY29udGVudDpcIuS4jeimgei1sO+8jOWGs+aImOWIsOWkqeS6ru+8gVwiLHNvdW5kOlwiZml4X21zZ18zLm1wM1wifTtcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW0zXCJdID0ge2luZGV4OjMsY29udGVudDpcIuS9oOeahOeJjOaJk+W+l+S5n+WkquWlveS6hu+8gVwiLHNvdW5kOlwiZml4X21zZ180Lm1wM1wifTtcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW00XCJdID0ge2luZGV4OjQsY29udGVudDpcIuS9oOaYr+WmueWmuei/mOaYr+WTpeWTpeWViu+8n1wiLHNvdW5kOlwiZml4X21zZ181Lm1wM1wifTtcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW01XCJdID0ge2luZGV4OjUsY29udGVudDpcIuWSjOS9oOWQiOS9nOecn+aYr+WkquaEieW/q+S6hu+8gVwiLHNvdW5kOlwiZml4X21zZ182Lm1wM1wifTtcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW02XCJdID0ge2luZGV4OjYsY29udGVudDpcIuWkp+WutuWlve+8jOW+iOmrmOWFtOingeWIsOWQhOS9je+8gVwiLHNvdW5kOlwiZml4X21zZ183Lm1wM1wifTtcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW03XCJdID0ge2luZGV4OjcsY29udGVudDpcIuWQhOS9je+8jOecn+aYr+S4jeWlveaEj+aAne+8jOaIkeW+l+emu+W8gOS4gOS8muWEv+OAglwiLHNvdW5kOlwiZml4X21zZ184Lm1wM1wifTtcbiAgICAgICAgdGhpcy5fcXVpY2tDaGF0SW5mb1tcIml0ZW04XCJdID0ge2luZGV4OjgsY29udGVudDpcIuS4jeimgeWQteS6hu+8jOS4k+W/g+eOqea4uOaIj+WQp++8gVwiLHNvdW5kOlwiZml4X21zZ185Lm1wM1wifTtcbiAgICB9LFxuICAgIFxuICAgIGdldFF1aWNrQ2hhdEluZm8oaW5kZXgpe1xuICAgICAgICB2YXIga2V5ID0gXCJpdGVtXCIgKyBpbmRleDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1aWNrQ2hhdEluZm9ba2V5XTsgICBcbiAgICB9LFxuICAgIFxuICAgIG9uQnRuQ2hhdENsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5fY2hhdFJvb3QuYWN0aXZlID0gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIG9uQmdDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX2NoYXRSb290LmFjdGl2ZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgXG4gICAgb25UYWJDbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJ0YWJRdWlja1wiKXtcbiAgICAgICAgICAgIHRoaXMuX3RhYlF1aWNrLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl90YWJFbW9qaS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwidGFiRW1vamlcIil7XG4gICAgICAgICAgICB0aGlzLl90YWJRdWljay5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3RhYkVtb2ppLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIG9uUXVpY2tDaGF0SXRlbUNsaWNrZWQ6ZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICB0aGlzLl9jaGF0Um9vdC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGluZm8gPSB0aGlzLl9xdWlja0NoYXRJbmZvW2V2ZW50LnRhcmdldC5uYW1lXTtcbiAgICAgICAgY2MudnYubmV0LnNlbmQoXCJxdWlja19jaGF0XCIsaW5mby5pbmRleCk7IFxuICAgIH0sXG4gICAgXG4gICAgb25FbW9qaUl0ZW1DbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQudGFyZ2V0Lm5hbWUpO1xuICAgICAgICB0aGlzLl9jaGF0Um9vdC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgY2MudnYubmV0LnNlbmQoXCJlbW9qaVwiLGV2ZW50LnRhcmdldC5uYW1lKTtcbiAgICB9LFxuICAgIFxuICAgIG9uQnRuU2VuZENoYXRDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX2NoYXRSb290LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBpZih0aGlzLl9pcHRDaGF0LnN0cmluZyA9PSBcIlwiKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYy52di5uZXQuc2VuZChcImNoYXRcIix0aGlzLl9pcHRDaGF0LnN0cmluZyk7XG4gICAgICAgIHRoaXMuX2lwdENoYXQuc3RyaW5nID0gXCJcIjtcbiAgICB9LFxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgICAgIHRhcmdldDpjYy5Ob2RlLFxuICAgICAgICBzcHJpdGU6Y2MuU3ByaXRlRnJhbWUsXG4gICAgICAgIGNoZWNrZWRTcHJpdGU6Y2MuU3ByaXRlRnJhbWUsXG4gICAgICAgIGNoZWNrZWQ6ZmFsc2UsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9LFxuICAgIFxuICAgIG9uQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmNoZWNrZWQgPSAhdGhpcy5jaGVja2VkO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9LFxuICAgIFxuICAgIHN3aXRjaFRvVW5jaGVja2VkOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH0sXG4gICAgXG4gICAgcmVmcmVzaDpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdGFyZ2V0U3ByaXRlID0gdGhpcy50YXJnZXQuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XG4gICAgICAgIGlmKHRoaXMuY2hlY2tlZCl7XG4gICAgICAgICAgICB0YXJnZXRTcHJpdGUuc3ByaXRlRnJhbWUgPSB0aGlzLmNoZWNrZWRTcHJpdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHRhcmdldFNwcml0ZS5zcHJpdGVGcmFtZSA9IHRoaXMuc3ByaXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIFxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgaW5wdXROYW1lOmNjLkVkaXRCb3gsXG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgIH0sXG4gICAgXG4gICAgb25SYW5kb21CdG5DbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBuYW1lcyA9IFtcbiAgICAgICAgICAgIFwi5LiK5a6YXCIsXG4gICAgICAgICAgICBcIuasp+mYs1wiLFxuICAgICAgICAgICAgXCLkuJzmlrlcIixcbiAgICAgICAgICAgIFwi56uv5pyoXCIsXG4gICAgICAgICAgICBcIueLrOWtpFwiLFxuICAgICAgICAgICAgXCLlj7jpqaxcIixcbiAgICAgICAgICAgIFwi5Y2X5a6rXCIsXG4gICAgICAgICAgICBcIuWkj+S+r1wiLFxuICAgICAgICAgICAgXCLor7jokZtcIixcbiAgICAgICAgICAgIFwi55qH55SrXCIsXG4gICAgICAgICAgICBcIumVv+WtmVwiLFxuICAgICAgICAgICAgXCLlrofmlodcIixcbiAgICAgICAgICAgIFwi6L2p6L6VXCIsXG4gICAgICAgICAgICBcIuS4nOmDrVwiLFxuICAgICAgICAgICAgXCLlrZDovaZcIixcbiAgICAgICAgICAgIFwi5Lic6ZizXCIsXG4gICAgICAgICAgICBcIuWtkOiogFwiLFxuICAgICAgICBdO1xuICAgICAgICBcbiAgICAgICAgdmFyIG5hbWVzMiA9IFtcbiAgICAgICAgICAgIFwi6ZuA5ZyjXCIsXG4gICAgICAgICAgICBcIui1jOS+oFwiLFxuICAgICAgICAgICAgXCLotYzlnKNcIixcbiAgICAgICAgICAgIFwi56iz6LWiXCIsXG4gICAgICAgICAgICBcIuS4jei+k1wiLFxuICAgICAgICAgICAgXCLlpb3ov5BcIixcbiAgICAgICAgICAgIFwi6Ieq5pG4XCIsXG4gICAgICAgICAgICBcIuaciemSsVwiLFxuICAgICAgICAgICAgXCLlnJ/osapcIixcbiAgICAgICAgXTtcbiAgICAgICAgdmFyIGlkeCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChuYW1lcy5sZW5ndGggLSAxKSk7XG4gICAgICAgIHZhciBpZHgyID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG5hbWVzMi5sZW5ndGggLSAxKSk7XG4gICAgICAgIHRoaXMuaW5wdXROYW1lLnN0cmluZyA9IG5hbWVzW2lkeF0gKyBuYW1lczJbaWR4Ml07XG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighY2Muc3lzLmlzTmF0aXZlICYmIGNjLnN5cy5pc01vYmlsZSl7XG4gICAgICAgICAgICB2YXIgY3ZzID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChjYy5DYW52YXMpO1xuICAgICAgICAgICAgY3ZzLmZpdEhlaWdodCA9IHRydWU7XG4gICAgICAgICAgICBjdnMuZml0V2lkdGggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25SYW5kb21CdG5DbGlja2VkKCk7XG4gICAgfSxcblxuICAgIG9uQnRuQ29uZmlybUNsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmlucHV0TmFtZS5zdHJpbmc7XG4gICAgICAgIGlmKG5hbWUgPT0gXCJcIil7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImludmFsaWQgbmFtZS5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2cobmFtZSk7XG4gICAgICAgIGNjLnZ2LnVzZXJNZ3IuY3JlYXRlKG5hbWUpO1xuICAgIH1cbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG5cbiAgICAvLyB9LFxufSk7XG4iLCJjYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICBfbGVpeGluZ3h1YW56ZTpudWxsLFxuICAgICAgICBfa291ZmVpOm51bGwsXG4gICAgICAgIF9xdWFuc2h1Om51bGwsXG4gICAgICAgIF9qaWVzdWFuOm51bGwsXG4gICAgICAgIF93YW5mYXh1YW56ZTpudWxsLFxuICAgICAgICBfdHlwZXM6W10sLy/lrprkuYnlpJrnp43muLjmiI/nsbvlnosgXG4gICAgICAgIF9zam1tal9qaWZlaTowLC8v5oi/5Li75Ye66LWEIG9yIOeOqeWutuW5s+WIhlxuICAgICAgICBfc2ptbWpfanVzaHU6MCwvLzjnm5ggb3IgMeWciFxuICAgICAgICBfZGhtal9qaWZlaTowLFxuICAgICAgICBfZGhtal9qdXNodTowLFxuICAgICAgICBfdGRoX2ppZmVpOjAsXG4gICAgICAgIF90ZGhfanVzaHU6MCxcbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8v5pyJ5aSa56eN546p5rOV77yM5rKI5a626Zeo6bq75bCGIOWumua1t+m6u+WwhiDmjqjliLDog6HpurvlsIZcbiAgICAgICAgdGhpcy5fdHlwZXMgPSBbXCJzam1talwiLFwiZGhtalwiLFwidGRoXCJdO1xuICAgICAgICBcbiAgICAgICAgLy/pmpDol4/pmaTnrKzkuIDnp43lpJbnmoTlhbbku5bnjqnms5Ug55WM6Z2iXG4gICAgICAgIGZvcih2YXIgaSA9IDEgOyBpIDwgdGhpcy5fdHlwZXMubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUodGhpcy5fdHlwZXNbaV0pLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL+aIv+S4u+W8gDjlsYAgM+egliAg5bmz5pGK5q+P5Liq5Lq6MeegllxuICAgICAgICAvL+aIv+S4u+W8gOS4gOWciCA256CWICAg5bmz5pGK5q+P5Liq5Lq6IDLnoJZcbiAgICAgICAgLy/liJ3lp4vljJborqHotLlcbiAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBvbkJ0bkJhY2s6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgXG4gICAgb25CdG5PSzpmdW5jdGlvbihldmVudCl7XG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgLy/noa7lrprmuLjmiI/nsbvlnotcbiAgICAgICAgdmFyIHR5cGUgPSBldmVudC50YXJnZXQucGFyZW50Lm5hbWU7XG4gICAgICAgIC8v5YiG5Yir6L+b5YWl5LiN5ZCM55qE5Yib5bu66YC76L6RXG4gICAgICAgIC8vVE9ET++8muiuqea3u+WKoOS4gOS4qua4uOaIj+WSjOinhOWImeabtOWKoOaWueS+v1xuICAgICAgICBpZih0eXBlPT1cInNqbW1qXCIpe1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVSb29tU0pNTUooKTtcbiAgICAgICAgfWVsc2UgaWYodHlwZT09XCJkaG1qXCIpe1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVSb29tREhNSigpO1xuICAgICAgICB9ZWxzZSBpZih0eXBlPT1cInRkaFwiKXtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUm9vbVRESCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBvblR5cGVDbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgdGhpcy5zd2l0Y2hUeXBlKGV2ZW50LnRhcmdldC5wYXJlbnQuY2hpbGRyZW5bMV0ubmFtZSk7XG4gICAgfSxcbiAgICBcbiAgICBvblNKTU1KZmFuZ3podUNsaWNrZWQ6ZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3NqbW1qX2ppZmVpID0gMDtcbiAgICAgICAgdmFyIGNvc3QgPSAxO1xuICAgICAgICBpZih0aGlzLl9zam1tal9qaWZlaSA9PSAwICkgY29zdCA9IDM7XG4gICAgICAgIGVsc2UgY29zdCA9IDE7XG4gICAgICAgIGlmKHRoaXMuX3NqbW1qX2p1c2h1ID09IDApIGNvc3QgPSBjb3N0O1xuICAgICAgICBlbHNlIGNvc3QgKj0gMjtcbiAgICAgICAgY2MuZmluZChcIkNhbnZhcy9DcmVhdGVSb29tL3NqbW1qL2Nvc3QvbnVtYmVyXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCLDl1wiICsgY29zdDtcbiAgICB9LFxuICAgIG9uU0pNTUp3YW5qaWFDbGlja2VkOmZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLl9zam1tal9qaWZlaSA9IDE7XG4gICAgICAgIHZhciBjb3N0ID0gMTtcbiAgICAgICAgaWYodGhpcy5fc2ptbWpfamlmZWkgPT0gMCApIGNvc3QgPSAzO1xuICAgICAgICBlbHNlIGNvc3QgPSAxO1xuICAgICAgICBpZih0aGlzLl9zam1tal9qdXNodSA9PSAwKSBjb3N0ID0gY29zdDtcbiAgICAgICAgZWxzZSBjb3N0ICo9IDI7XG4gICAgICAgIGNjLmZpbmQoXCJDYW52YXMvQ3JlYXRlUm9vbS9zam1tai9jb3N0L251bWJlclwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwiw5dcIiArIGNvc3Q7XG4gICAgfSxcbiAgICBvblNKTU1KOHBhbkNsaWNrZWQ6ZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3NqbW1qX2p1c2h1ID0gMDtcbiAgICAgICAgdmFyIGNvc3QgPSAxO1xuICAgICAgICBpZih0aGlzLl9zam1tal9qaWZlaSA9PSAwICkgY29zdCA9IDM7XG4gICAgICAgIGVsc2UgY29zdCA9IDE7XG4gICAgICAgIGlmKHRoaXMuX3NqbW1qX2p1c2h1ID09IDApIGNvc3QgPSBjb3N0O1xuICAgICAgICBlbHNlIGNvc3QgKj0gMjtcbiAgICAgICAgY2MuZmluZChcIkNhbnZhcy9DcmVhdGVSb29tL3NqbW1qL2Nvc3QvbnVtYmVyXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCLDl1wiICsgY29zdDtcbiAgICB9LFxuICAgIG9uU0pNTUoxcXVhbkNsaWNrZWQ6ZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3NqbW1qX2p1c2h1ID0gMTtcbiAgICAgICAgdmFyIGNvc3QgPSAxO1xuICAgICAgICBpZih0aGlzLl9zam1tal9qaWZlaSA9PSAwICkgY29zdCA9IDM7XG4gICAgICAgIGVsc2UgY29zdCA9IDE7XG4gICAgICAgIGlmKHRoaXMuX3NqbW1qX2p1c2h1ID09IDApIGNvc3QgPSBjb3N0O1xuICAgICAgICBlbHNlIGNvc3QgPSAyICogY29zdDtcbiAgICAgICAgY2MuZmluZChcIkNhbnZhcy9DcmVhdGVSb29tL3NqbW1qL2Nvc3QvbnVtYmVyXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCLDl1wiICsgY29zdDtcbiAgICB9LFxuICAgIFxuICAgIG9uREhNSmZhbmd6aHVDbGlja2VkOmZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLl9kaG1qX2ppZmVpID0gMDtcbiAgICAgICAgdmFyIGNvc3QgPSAxO1xuICAgICAgICBpZih0aGlzLl9kaG1qX2ppZmVpID09IDAgKSBjb3N0ID0gMztcbiAgICAgICAgZWxzZSBjb3N0ID0gMTtcbiAgICAgICAgaWYodGhpcy5fZGhtal9qdXNodSA9PSAwKSBjb3N0ID0gY29zdDtcbiAgICAgICAgZWxzZSBjb3N0ICo9IDI7XG4gICAgICAgIGNjLmZpbmQoXCJDYW52YXMvQ3JlYXRlUm9vbS9kaG1qL2Nvc3QvbnVtYmVyXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCLDl1wiICsgY29zdDtcbiAgICB9LFxuICAgIG9uREhNSndhbmppYUNsaWNrZWQ6ZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2RobWpfamlmZWkgPSAxO1xuICAgICAgICB2YXIgY29zdCA9IDE7XG4gICAgICAgIGlmKHRoaXMuX2RobWpfamlmZWkgPT0gMCApIGNvc3QgPSAzO1xuICAgICAgICBlbHNlIGNvc3QgPSAxO1xuICAgICAgICBpZih0aGlzLl9kaG1qX2p1c2h1ID09IDApIGNvc3QgPSBjb3N0O1xuICAgICAgICBlbHNlIGNvc3QgKj0gMjtcbiAgICAgICAgY2MuZmluZChcIkNhbnZhcy9DcmVhdGVSb29tL2RobWovY29zdC9udW1iZXJcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBcIsOXXCIgKyBjb3N0O1xuICAgIH0sXG4gICAgb25ESE1KOHBhbkNsaWNrZWQ6ZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX2RobWpfanVzaHUgPSAwO1xuICAgICAgICB2YXIgY29zdCA9IDE7XG4gICAgICAgIGlmKHRoaXMuX2RobWpfamlmZWkgPT0gMCApIGNvc3QgPSAzO1xuICAgICAgICBlbHNlIGNvc3QgPSAxO1xuICAgICAgICBpZih0aGlzLl9kaG1qX2p1c2h1ID09IDApIGNvc3QgPSBjb3N0O1xuICAgICAgICBlbHNlIGNvc3QgKj0gMjtcbiAgICAgICAgY2MuZmluZChcIkNhbnZhcy9DcmVhdGVSb29tL2RobWovY29zdC9udW1iZXJcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBcIsOXXCIgKyBjb3N0O1xuICAgIH0sXG4gICAgb25ESE1KMXF1YW5DbGlja2VkOmZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLl9kaG1qX2p1c2h1ID0gMTtcbiAgICAgICAgdmFyIGNvc3QgPSAxO1xuICAgICAgICBpZih0aGlzLl9kaG1qX2ppZmVpID09IDAgKSBjb3N0ID0gMztcbiAgICAgICAgZWxzZSBjb3N0ID0gMTtcbiAgICAgICAgaWYodGhpcy5fZGhtal9qdXNodSA9PSAwKSBjb3N0ID0gY29zdDtcbiAgICAgICAgZWxzZSBjb3N0ICo9IDI7XG4gICAgICAgIGNjLmZpbmQoXCJDYW52YXMvQ3JlYXRlUm9vbS9kaG1qL2Nvc3QvbnVtYmVyXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCLDl1wiICsgY29zdDtcbiAgICB9LFxuICAgIFxuICAgIG9uVERIZmFuZ3podUNsaWNrZWQ6ZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3RkaF9qaWZlaSA9IDA7XG4gICAgICAgIHZhciBjb3N0ID0gMTtcbiAgICAgICAgaWYodGhpcy5fdGRoX2ppZmVpID09IDAgKSBjb3N0ID0gMztcbiAgICAgICAgZWxzZSBjb3N0ID0gMTtcbiAgICAgICAgaWYodGhpcy5fdGRoX2p1c2h1ID09IDApIGNvc3QgPSBjb3N0O1xuICAgICAgICBlbHNlIGNvc3QgKj0gMjtcbiAgICAgICAgY2MuZmluZChcIkNhbnZhcy9DcmVhdGVSb29tL3RkaC9jb3N0L251bWJlclwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwiw5dcIiArIGNvc3Q7XG4gICAgfSxcbiAgICBvblRESHdhbmppYUNsaWNrZWQ6ZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3RkaF9qaWZlaSA9IDE7XG4gICAgICAgIHZhciBjb3N0ID0gMTtcbiAgICAgICAgaWYodGhpcy5fdGRoX2ppZmVpID09IDAgKSBjb3N0ID0gMztcbiAgICAgICAgZWxzZSBjb3N0ID0gMTtcbiAgICAgICAgaWYodGhpcy5fdGRoX2p1c2h1ID09IDApIGNvc3QgPSBjb3N0O1xuICAgICAgICBlbHNlIGNvc3QgKj0gMjtcbiAgICAgICAgY2MuZmluZChcIkNhbnZhcy9DcmVhdGVSb29tL3RkaC9jb3N0L251bWJlclwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwiw5dcIiArIGNvc3Q7XG4gICAgfSxcbiAgICBvblRESDhwYW5DbGlja2VkOmZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB0aGlzLl90ZGhfanVzaHUgPSAwO1xuICAgICAgICB2YXIgY29zdCA9IDE7XG4gICAgICAgIGlmKHRoaXMuX3RkaF9qaWZlaSA9PSAwICkgY29zdCA9IDM7XG4gICAgICAgIGVsc2UgY29zdCA9IDE7XG4gICAgICAgIGlmKHRoaXMuX3RkaF9qdXNodSA9PSAwKSBjb3N0ID0gY29zdDtcbiAgICAgICAgZWxzZSBjb3N0ICo9IDI7XG4gICAgICAgIGNjLmZpbmQoXCJDYW52YXMvQ3JlYXRlUm9vbS90ZGgvY29zdC9udW1iZXJcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBcIsOXXCIgKyBjb3N0O1xuICAgIH0sXG4gICAgb25UREgxcXVhbkNsaWNrZWQ6ZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuX3RkaF9qdXNodSA9IDE7XG4gICAgICAgIHZhciBjb3N0ID0gMTtcbiAgICAgICAgaWYodGhpcy5fdGRoX2ppZmVpID09IDAgKSBjb3N0ID0gMztcbiAgICAgICAgZWxzZSBjb3N0ID0gMTtcbiAgICAgICAgaWYodGhpcy5fdGRoX2p1c2h1ID09IDApIGNvc3QgPSBjb3N0O1xuICAgICAgICBlbHNlIGNvc3QgKj0gMjtcbiAgICAgICAgY2MuZmluZChcIkNhbnZhcy9DcmVhdGVSb29tL3RkaC9jb3N0L251bWJlclwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwiw5dcIiArIGNvc3Q7XG4gICAgfSxcbiAgICBcbiAgICAvL3RhYueVjOmdouWIh+aNolxuICAgIHN3aXRjaFR5cGU6ZnVuY3Rpb24odHlwZSkge1xuICAgICAgICBmb3IodmFyIGkgPSAwIDsgaSA8IHRoaXMuX3R5cGVzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKHRoaXMuX3R5cGVzW2ldKS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUodHlwZSkuYWN0aXZlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgY3JlYXRlUm9vbVNKTU1KOmZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgICAgICAvL+iOt+WPlumcgOimgeeahOaJgOaciemAiemhuVxuICAgICAgICBcbiAgICAgICAgLy/ov5nph4zkuIDlrpropoHlsI/lhpnvvIzlkI7nq6/kvJrnm7TmjqXmi7zmjqXov5nkuKrlrZfnrKbkuLJcbiAgICAgICAgdmFyIHR5cGUgPSBcInNqbW1qXCI7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9rb3VmZWkgPSBbXTtcbiAgICAgICAgdmFyIHQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUodHlwZSkuZ2V0Q2hpbGRCeU5hbWUoXCJrb3VmZWlcIik7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0LmNoaWxkcmVuQ291bnQ7ICsraSl7XG4gICAgICAgICAgICB2YXIgbiA9IHQuY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiUmFkaW9CdXR0b25cIik7XG4gICAgICAgICAgICBpZihuICE9IG51bGwpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2tvdWZlaS5wdXNoKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9xdWFuc2h1ID0gW107XG4gICAgICAgIHZhciB0ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKHR5cGUpLmdldENoaWxkQnlOYW1lKFwicXVhbnNodVwiKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHQuY2hpbGRyZW5Db3VudDsgKytpKXtcbiAgICAgICAgICAgIHZhciBuID0gdC5jaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJSYWRpb0J1dHRvblwiKTtcbiAgICAgICAgICAgIGlmKG4gIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVhbnNodS5wdXNoKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9qaWVzdWFuID0gW107XG4gICAgICAgIHZhciB0ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKHR5cGUpLmdldENoaWxkQnlOYW1lKFwiamllc3VhblwiKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHQuY2hpbGRyZW5Db3VudDsgKytpKXtcbiAgICAgICAgICAgIHZhciBuID0gdC5jaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJSYWRpb0J1dHRvblwiKTtcbiAgICAgICAgICAgIGlmKG4gIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgdGhpcy5famllc3Vhbi5wdXNoKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl93YW5mYXh1YW56ZSA9IFtdO1xuICAgICAgICB2YXIgdCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZSh0eXBlKS5nZXRDaGlsZEJ5TmFtZShcIndhbmZheHVhbnplXCIpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdC5jaGlsZHJlbkNvdW50OyArK2kpe1xuICAgICAgICAgICAgdmFyIG4gPSB0LmNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIkNoZWNrQm94XCIpO1xuICAgICAgICAgICAgaWYobiAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICB0aGlzLl93YW5mYXh1YW56ZS5wdXNoKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9uQ3JlYXRlID0gZnVuY3Rpb24ocmV0KXtcbiAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlICE9PSAwKXtcbiAgICAgICAgICAgICAgICBjYy52di53Yy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZXQuZXJybXNnKTtcbiAgICAgICAgICAgICAgICBpZihyZXQuZXJyY29kZSA9PSAyMjIyKXtcbiAgICAgICAgICAgICAgICAgICAgY2MudnYuYWxlcnQuc2hvdyhcIuaPkOekulwiLFwi5oi/5Y2h5LiN6Laz77yM5Yib5bu65oi/6Ze05aSx6LSlIVwiKTsgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBjYy52di5hbGVydC5zaG93KFwi5o+Q56S6XCIsXCLliJvlu7rmiL/pl7TlpLHotKUs6ZSZ6K+v56CBOlwiICsgcmV0LmVycmNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5jb25uZWN0R2FtZVNlcnZlcihyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBob25nemhvbmdkYW5naHVhID0gc2VsZi5fd2FuZmF4dWFuemVbMF0uY2hlY2tlZDsgICAgIFxuICAgICAgICBcbiAgICAgICAgdmFyIGtvdWZlaSA9IDA7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLl9rb3VmZWkubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgaWYoc2VsZi5fa291ZmVpW2ldLmNoZWNrZWQpe1xuICAgICAgICAgICAgICAgIGtvdWZlaSA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9ICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHF1YW5zaHUgPSAwO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5fcXVhbnNodS5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBpZihzZWxmLl9xdWFuc2h1W2ldLmNoZWNrZWQpe1xuICAgICAgICAgICAgICAgIHF1YW5zaHUgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBqaWVzdWFuID0gMDtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYuX2ppZXN1YW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgaWYoc2VsZi5famllc3VhbltpXS5jaGVja2VkKXtcbiAgICAgICAgICAgICAgICBqaWVzdWFuID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgY29uZiA9IHtcbiAgICAgICAgICAgIHR5cGU6dHlwZSxcbiAgICAgICAgICAgIGhvbmd6aG9uZ2RhbmdodWE6IGhvbmd6aG9uZ2RhbmdodWEsXG4gICAgICAgICAgICBrb3VmZWk6a291ZmVpLFxuICAgICAgICAgICAgcXVhbnNodTpxdWFuc2h1LFxuICAgICAgICAgICAgamllc3VhbjpqaWVzdWFuXG4gICAgICAgIH07IFxuICAgICAgICBcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBhY2NvdW50OmNjLnZ2LnVzZXJNZ3IuYWNjb3VudCxcbiAgICAgICAgICAgIHNpZ246Y2MudnYudXNlck1nci5zaWduLFxuICAgICAgICAgICAgY29uZjpKU09OLnN0cmluZ2lmeShjb25mKVxuICAgICAgICB9O1xuICAgICAgICBjYy52di53Yy5zaG93KFwi5q2j5Zyo5Yib5bu65oi/6Ze0XCIpO1xuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL2NyZWF0ZV9wcml2YXRlX3Jvb21cIixkYXRhLG9uQ3JlYXRlKTsgICBcbiAgICB9LFxuICAgIFxuICAgIGNyZWF0ZVJvb21ESE1KOmZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgICAgICAvL+iOt+WPlumcgOimgeeahOaJgOaciemAiemhuVxuICAgICAgICAvL+i/memHjOS4gOWumuimgeWwj+WGme+8jOWQjuerr+S8muebtOaOpeaLvOaOpei/meS4quWtl+espuS4slxuICAgICAgICB2YXIgdHlwZSA9IFwiZGhtalwiO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fa291ZmVpID0gW107XG4gICAgICAgIHZhciB0ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKHR5cGUpLmdldENoaWxkQnlOYW1lKFwia291ZmVpXCIpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdC5jaGlsZHJlbkNvdW50OyArK2kpe1xuICAgICAgICAgICAgdmFyIG4gPSB0LmNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIlJhZGlvQnV0dG9uXCIpO1xuICAgICAgICAgICAgaWYobiAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9rb3VmZWkucHVzaChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5fcXVhbnNodSA9IFtdO1xuICAgICAgICB2YXIgdCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZSh0eXBlKS5nZXRDaGlsZEJ5TmFtZShcInF1YW5zaHVcIik7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0LmNoaWxkcmVuQ291bnQ7ICsraSl7XG4gICAgICAgICAgICB2YXIgbiA9IHQuY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiUmFkaW9CdXR0b25cIik7XG4gICAgICAgICAgICBpZihuICE9IG51bGwpe1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1YW5zaHUucHVzaChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5famllc3VhbiA9IFtdO1xuICAgICAgICB2YXIgdCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZSh0eXBlKS5nZXRDaGlsZEJ5TmFtZShcImppZXN1YW5cIik7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0LmNoaWxkcmVuQ291bnQ7ICsraSl7XG4gICAgICAgICAgICB2YXIgbiA9IHQuY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KFwiUmFkaW9CdXR0b25cIik7XG4gICAgICAgICAgICBpZihuICE9IG51bGwpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2ppZXN1YW4ucHVzaChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgb25DcmVhdGUgPSBmdW5jdGlvbihyZXQpe1xuICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgIT09IDApe1xuICAgICAgICAgICAgICAgIGNjLnZ2LndjLmhpZGUoKTtcbiAgICAgICAgICAgICAgICBpZihyZXQuZXJyY29kZSA9PSAyMjIyKXtcbiAgICAgICAgICAgICAgICAgICAgY2MudnYuYWxlcnQuc2hvdyhcIuaPkOekulwiLFwi5oi/5Y2h5LiN6Laz77yM5Yib5bu65oi/6Ze05aSx6LSlIVwiKTsgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBjYy52di5hbGVydC5zaG93KFwi5o+Q56S6XCIsXCLliJvlu7rmiL/pl7TlpLHotKUs6ZSZ6K+v56CBOlwiICsgcmV0LmVycmNvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5jb25uZWN0R2FtZVNlcnZlcihyZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy/liKTmlq3nlKjmiLflgZrkuoblk6rkupvpgInmi6lcbiAgICAgICAgLy/miaPotLkgMCDmiL/kuLvlh7rotYQgMSDnjqnlrrblubPliIZcbiAgICAgICAgLy/lnIjmlbAgMCA455uYIDEg5LiA5ZyIXG4gICAgICAgIC8v57uT566XIDAgNTAgIDEgMTIwXG5cbiAgICAgICAgdmFyIGtvdWZlaSA9IDA7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLl9rb3VmZWkubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgaWYoc2VsZi5fa291ZmVpW2ldLmNoZWNrZWQpe1xuICAgICAgICAgICAgICAgIGtvdWZlaSA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9ICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHF1YW5zaHUgPSAwO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5fcXVhbnNodS5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBpZihzZWxmLl9xdWFuc2h1W2ldLmNoZWNrZWQpe1xuICAgICAgICAgICAgICAgIHF1YW5zaHUgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBqaWVzdWFuID0gMDtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYuX2ppZXN1YW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgaWYoc2VsZi5famllc3VhbltpXS5jaGVja2VkKXtcbiAgICAgICAgICAgICAgICBqaWVzdWFuID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgY29uZiA9IHtcbiAgICAgICAgICAgIHR5cGU6dHlwZSxcbiAgICAgICAgICAgIGtvdWZlaTprb3VmZWksXG4gICAgICAgICAgICBxdWFuc2h1OnF1YW5zaHUsXG4gICAgICAgICAgICBqaWVzdWFuOmppZXN1YW5cbiAgICAgICAgfTsgXG4gICAgICAgIFxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGFjY291bnQ6Y2MudnYudXNlck1nci5hY2NvdW50LFxuICAgICAgICAgICAgc2lnbjpjYy52di51c2VyTWdyLnNpZ24sXG4gICAgICAgICAgICBjb25mOkpTT04uc3RyaW5naWZ5KGNvbmYpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICBjYy52di53Yy5zaG93KFwi5q2j5Zyo5Yib5bu65oi/6Ze0XCIpO1xuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL2NyZWF0ZV9wcml2YXRlX3Jvb21cIixkYXRhLG9uQ3JlYXRlKTsgICBcbiAgICB9LFxuICAgIFxuICAgIGNyZWF0ZVJvb21UREg6ZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgICAgIC8v6I635Y+W6ZyA6KaB55qE5omA5pyJ6YCJ6aG5XG4gICAgICAgIC8v6L+Z6YeM5LiA5a6a6KaB5bCP5YaZ77yM5ZCO56uv5Lya55u05o6l5ou85o6l6L+Z5Liq5a2X56ym5LiyXG4gICAgICAgIHZhciB0eXBlID0gXCJ0ZGhcIjtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2tvdWZlaSA9IFtdO1xuICAgICAgICB2YXIgdCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZSh0eXBlKS5nZXRDaGlsZEJ5TmFtZShcImtvdWZlaVwiKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHQuY2hpbGRyZW5Db3VudDsgKytpKXtcbiAgICAgICAgICAgIHZhciBuID0gdC5jaGlsZHJlbltpXS5nZXRDb21wb25lbnQoXCJSYWRpb0J1dHRvblwiKTtcbiAgICAgICAgICAgIGlmKG4gIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fa291ZmVpLnB1c2gobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3F1YW5zaHUgPSBbXTtcbiAgICAgICAgdmFyIHQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUodHlwZSkuZ2V0Q2hpbGRCeU5hbWUoXCJxdWFuc2h1XCIpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdC5jaGlsZHJlbkNvdW50OyArK2kpe1xuICAgICAgICAgICAgdmFyIG4gPSB0LmNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIlJhZGlvQnV0dG9uXCIpO1xuICAgICAgICAgICAgaWYobiAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWFuc2h1LnB1c2gobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2ppZXN1YW4gPSBbXTtcbiAgICAgICAgdmFyIHQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUodHlwZSkuZ2V0Q2hpbGRCeU5hbWUoXCJqaWVzdWFuXCIpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdC5jaGlsZHJlbkNvdW50OyArK2kpe1xuICAgICAgICAgICAgdmFyIG4gPSB0LmNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIlJhZGlvQnV0dG9uXCIpO1xuICAgICAgICAgICAgaWYobiAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9qaWVzdWFuLnB1c2gobik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9uQ3JlYXRlID0gZnVuY3Rpb24ocmV0KXtcbiAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlICE9PSAwKXtcbiAgICAgICAgICAgICAgICBjYy52di53Yy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgPT0gMjIyMil7XG4gICAgICAgICAgICAgICAgICAgIGNjLnZ2LmFsZXJ0LnNob3coXCLmj5DnpLpcIixcIuaIv+WNoeS4jei2s++8jOWIm+W7uuaIv+mXtOWksei0pSFcIik7ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgY2MudnYuYWxlcnQuc2hvdyhcIuaPkOekulwiLFwi5Yib5bu65oi/6Ze05aSx6LSlLOmUmeivr+eggTpcIiArIHJldC5lcnJjb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuY29ubmVjdEdhbWVTZXJ2ZXIocmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIC8v5Yik5pat55So5oi35YGa5LqG5ZOq5Lqb6YCJ5oupXG4gICAgICAgIC8v5omj6LS5IDAg5oi/5Li75Ye66LWEIDEg546p5a625bmz5YiGXG4gICAgICAgIC8v5ZyI5pWwIDAgOOebmCAxIOS4gOWciFxuICAgICAgICAvL+e7k+eulyAwIDUwICAxIDEyMFxuXG4gICAgICAgIHZhciBrb3VmZWkgPSAwO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VsZi5fa291ZmVpLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIGlmKHNlbGYuX2tvdWZlaVtpXS5jaGVja2VkKXtcbiAgICAgICAgICAgICAgICBrb3VmZWkgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBxdWFuc2h1ID0gMDtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYuX3F1YW5zaHUubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgaWYoc2VsZi5fcXVhbnNodVtpXS5jaGVja2VkKXtcbiAgICAgICAgICAgICAgICBxdWFuc2h1ID0gaTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgamllc3VhbiA9IDA7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLl9qaWVzdWFuLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIGlmKHNlbGYuX2ppZXN1YW5baV0uY2hlY2tlZCl7XG4gICAgICAgICAgICAgICAgamllc3VhbiA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9ICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGNvbmYgPSB7XG4gICAgICAgICAgICB0eXBlOnR5cGUsXG4gICAgICAgICAgICBrb3VmZWk6a291ZmVpLFxuICAgICAgICAgICAgcXVhbnNodTpxdWFuc2h1LFxuICAgICAgICAgICAgamllc3VhbjpqaWVzdWFuXG4gICAgICAgIH07IFxuICAgICAgICBcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBhY2NvdW50OmNjLnZ2LnVzZXJNZ3IuYWNjb3VudCxcbiAgICAgICAgICAgIHNpZ246Y2MudnYudXNlck1nci5zaWduLFxuICAgICAgICAgICAgY29uZjpKU09OLnN0cmluZ2lmeShjb25mKVxuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgY2MudnYud2Muc2hvdyhcIuato+WcqOWIm+W7uuaIv+mXtFwiKTtcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9jcmVhdGVfcHJpdmF0ZV9yb29tXCIsZGF0YSxvbkNyZWF0ZSk7ICAgXG4gICAgfSxcbiAgICBcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgcXVlWWlNZW46bnVsbCxcbiAgICAgICAgdGlwczpbXSxcbiAgICAgICAgc2VsZWN0ZWQ6W10sXG4gICAgICAgIGRpbmdxdWVzOltdLFxuICAgICAgICAvLyBmb286IHtcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKGNjLnZ2ID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdFZpZXcoKTtcbiAgICAgICAgdGhpcy5pbml0RGluZ1F1ZSgpO1xuICAgICAgICB0aGlzLmluaXRFdmVudEhhbmRsZXJzKCk7XG4gICAgfSxcbiAgICBcbiAgICBpbml0VmlldzpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgZ2FtZUNoaWxkID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKTtcbiAgICAgICAgdGhpcy5xdWVZaU1lbiA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShcImRpbmdxdWVcIik7XG4gICAgICAgIHRoaXMucXVlWWlNZW4uYWN0aXZlID0gY2MudnYuZ2FtZU5ldE1nci5pc0RpbmdRdWVpbmc7XG4gICAgICAgIFxuICAgICAgICB2YXIgYXJyID0gW1wibXlzZWxmXCIsXCJyaWdodFwiLFwidXBcIixcImxlZnRcIl07XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIHNpZGUgPSBnYW1lQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoYXJyW2ldKTtcbiAgICAgICAgICAgIHZhciBzZWF0ID0gc2lkZS5nZXRDaGlsZEJ5TmFtZShcInNlYXRcIik7XG4gICAgICAgICAgICB2YXIgZGluZ3F1ZSA9IHNlYXQuZ2V0Q2hpbGRCeU5hbWUoXCJxdWVcIik7XG4gICAgICAgICAgICB0aGlzLmRpbmdxdWVzLnB1c2goZGluZ3F1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHRpcHMgPSB0aGlzLnF1ZVlpTWVuLmdldENoaWxkQnlOYW1lKFwidGlwc1wiKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRpcHMuY2hpbGRyZW5Db3VudDsgKytpKXtcbiAgICAgICAgICAgIHZhciBuID0gdGlwcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHRoaXMudGlwcy5wdXNoKG4uZ2V0Q29tcG9uZW50KGNjLkxhYmVsKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuZ2FtZXN0YXRlID09IFwiZGluZ3F1ZVwiKXtcbiAgICAgICAgICAgIHRoaXMuc2hvd0RpbmdRdWVDaG9pY2UoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgaW5pdEV2ZW50SGFuZGxlcnM6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2RpbmdxdWVfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHZhciBzZWF0SW5kZXggPSBjYy52di5nYW1lTmV0TWdyLmdldFNlYXRJbmRleEJ5SUQoZGF0YS5kZXRhaWwpO1xuICAgICAgICAgICAgdmFyIGxvY2FsSW5kZXggPSBjYy52di5nYW1lTmV0TWdyLmdldExvY2FsSW5kZXgoc2VhdEluZGV4KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2FtZV9kaW5ncXVlX25vdGlmeTpcIiArIGxvY2FsSW5kZXgpO1xuICAgICAgICAgICAgc2VsZi50aXBzW2xvY2FsSW5kZXhdLm5vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfZGluZ3F1ZV9maW5pc2gnLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvL+mAmuefpeavj+S4gOS4queOqeWutuWumue8uueahOiKseiJslxuICAgICAgICAgICAgc2VsZi5xdWVZaU1lbi5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuaXNEaW5nUXVlaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLmluaXREaW5nUXVlKCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgXG4gICAgc2hvd0RpbmdRdWVDaG9pY2U6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5xdWVZaU1lbi5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB2YXIgc2QgPSBjYy52di5nYW1lTmV0TWdyLmdldFNlbGZEYXRhKCk7XG4gICAgICAgIHZhciB0eXBlQ291bnRzID0gWzAsMCwwXTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNkLmhvbGRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBwYWkgPSBzZC5ob2xkc1tpXTtcbiAgICAgICAgICAgIHZhciB0eXBlID0gY2MudnYubWFoam9uZ21nci5nZXRNYWhqb25nVHlwZShwYWkpO1xuICAgICAgICAgICAgdHlwZUNvdW50c1t0eXBlXSsrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgbWluID0gNjU1MzU7XG4gICAgICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0eXBlQ291bnRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIGlmKHR5cGVDb3VudHNbaV0gPCBtaW4pe1xuICAgICAgICAgICAgICAgIG1pbiA9IHR5cGVDb3VudHNbaV07XG4gICAgICAgICAgICAgICAgbWluSW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgYXJyID0gW1widG9uZ1wiLFwidGlhb1wiLFwid2FuXCJdO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5xdWVZaU1lbi5nZXRDaGlsZEJ5TmFtZShhcnJbaV0pO1xuICAgICAgICAgICAgaWYobWluSW5kZXggPT0gaSl7XG4gICAgICAgICAgICAgICAgbm9kZS5nZXRDb21wb25lbnQoY2MuQW5pbWF0aW9uKS5wbGF5KFwiZGluZ3F1ZV90dWlqaWFuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBub2RlLmdldENvbXBvbmVudChjYy5BbmltYXRpb24pLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vdGhpcy5xdWVZaU1lbi5nZXRDaGlsZEJ5TmFtZShhcnJbaV0pLmdldENoaWxkQnlOYW1lKCdqaWFuJykuYWN0aXZlID0gbWluSW5kZXggPT0gaTsgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudGlwcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgbiA9IHRoaXMudGlwc1tpXTtcbiAgICAgICAgICAgIGlmKGkgPiAwKXtcbiAgICAgICAgICAgICAgICBuLm5vZGUuYWN0aXZlID0gZmFsc2U7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBuLm5vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgaW5pdERpbmdRdWU6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGFyciA9IFtcInRvbmdcIixcInRpYW9cIixcIndhblwiXTtcbiAgICAgICAgdmFyIGRhdGEgPSBjYy52di5nYW1lTmV0TWdyLnNlYXRzO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgcXVlID0gZGF0YVtpXS5kaW5ncXVlO1xuICAgICAgICAgICAgaWYocXVlID09IG51bGwgfHwgcXVlIDwgMCB8fCBxdWUgPj0gYXJyLmxlbmd0aCl7XG4gICAgICAgICAgICAgICAgcXVlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgcXVlID0gYXJyW3F1ZV07IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChpKTtcbiAgICAgICAgICAgIGlmKHF1ZSl7XG4gICAgICAgICAgICAgICAgdGhpcy5kaW5ncXVlc1tsb2NhbEluZGV4XS5nZXRDaGlsZEJ5TmFtZShxdWUpLmFjdGl2ZSA9IHRydWU7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICByZXNldDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnNldEludGVyYWN0YWJsZSh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2VsZWN0ZWQucHVzaCh0aGlzLnF1ZVlpTWVuLmdldENoaWxkQnlOYW1lKFwidG9uZ19zZWxlY3RlZFwiKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQucHVzaCh0aGlzLnF1ZVlpTWVuLmdldENoaWxkQnlOYW1lKFwidGlhb19zZWxlY3RlZFwiKSk7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWQucHVzaCh0aGlzLnF1ZVlpTWVuLmdldENoaWxkQnlOYW1lKFwid2FuX3NlbGVjdGVkXCIpKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0ZWQubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFtpXS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5kaW5ncXVlcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdGhpcy5kaW5ncXVlc1tpXS5jaGlsZHJlbi5sZW5ndGg7ICsrail7XG4gICAgICAgICAgICAgICAgdGhpcy5kaW5ncXVlc1tpXS5jaGlsZHJlbltqXS5hY3RpdmUgPSBmYWxzZTsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIG9uUXVlWWlNZW5DbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgdmFyIHR5cGUgPSAwO1xuICAgICAgICBpZihldmVudC50YXJnZXQubmFtZSA9PSBcInRvbmdcIil7XG4gICAgICAgICAgICB0eXBlID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwidGlhb1wiKXtcbiAgICAgICAgICAgIHR5cGUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJ3YW5cIil7XG4gICAgICAgICAgICB0eXBlID0gMjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuc2VsZWN0ZWQubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFtpXS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSAgXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRbdHlwZV0uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5kaW5ncXVlID0gdHlwZTtcbiAgICAgICAgY2MudnYubmV0LnNlbmQoXCJkaW5ncXVlXCIsdHlwZSk7XG4gICAgICAgIFxuICAgICAgICAvL3RoaXMuc2V0SW50ZXJhY3RhYmxlKGZhbHNlKTtcbiAgICB9LFxuICAgIFxuICAgIHNldEludGVyYWN0YWJsZTpmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIHRoaXMucXVlWWlNZW4uZ2V0Q2hpbGRCeU5hbWUoXCJ0b25nXCIpLmdldENvbXBvbmVudChjYy5CdXR0b24pLmludGVyYWN0YWJsZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnF1ZVlpTWVuLmdldENoaWxkQnlOYW1lKFwidGlhb1wiKS5nZXRDb21wb25lbnQoY2MuQnV0dG9uKS5pbnRlcmFjdGFibGUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5xdWVZaU1lbi5nZXRDaGlsZEJ5TmFtZShcIndhblwiKS5nZXRDb21wb25lbnQoY2MuQnV0dG9uKS5pbnRlcmFjdGFibGUgPSB2YWx1ZTsgICAgICAgIFxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcblxuICAgIC8vIH0sXG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgICAgICBfZm9sZHM6bnVsbCxcbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKGNjLnZ2ID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmluaXRWaWV3KCk7XG4gICAgICAgIHRoaXMuaW5pdEV2ZW50SGFuZGxlcigpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5pbml0QWxsRm9sZHMoKTtcbiAgICB9LFxuICAgIFxuICAgIGluaXRWaWV3OmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX2ZvbGRzID0ge307XG4gICAgICAgIHZhciBnYW1lID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKTtcbiAgICAgICAgdmFyIHNpZGVzID0gW1wibXlzZWxmXCIsXCJyaWdodFwiLFwidXBcIixcImxlZnRcIl07XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzaWRlcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgc2lkZU5hbWUgPSBzaWRlc1tpXTtcbiAgICAgICAgICAgIHZhciBzaWRlUm9vdCA9IGdhbWUuZ2V0Q2hpbGRCeU5hbWUoc2lkZU5hbWUpO1xuICAgICAgICAgICAgdmFyIGZvbGRzID0gW107XG4gICAgICAgICAgICB2YXIgZm9sZFJvb3QgPSBzaWRlUm9vdC5nZXRDaGlsZEJ5TmFtZShcImZvbGRzXCIpO1xuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGZvbGRSb290LmNoaWxkcmVuLmxlbmd0aDsgKytqKXtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGZvbGRSb290LmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgIG4uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG4uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7IFxuICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm9sZHMucHVzaChzcHJpdGUpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZm9sZHNbc2lkZU5hbWVdID0gZm9sZHM7IFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmhpZGVBbGxGb2xkcygpO1xuICAgIH0sXG4gICAgXG4gICAgaGlkZUFsbEZvbGRzOmZ1bmN0aW9uKCl7XG4gICAgICAgIGZvcih2YXIgayBpbiB0aGlzLl9mb2xkcyl7XG4gICAgICAgICAgICB2YXIgZiA9IHRoaXMuX2ZvbGRzW2ldO1xuICAgICAgICAgICAgZm9yKHZhciBpIGluIGYpe1xuICAgICAgICAgICAgICAgIGZbaV0ubm9kZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgaW5pdEV2ZW50SGFuZGxlcjpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9iZWdpbicsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLmluaXRBbGxGb2xkcygpO1xuICAgICAgICB9KTsgIFxuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX3N5bmMnLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgc2VsZi5pbml0QWxsRm9sZHMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfY2h1cGFpX25vdGlmeScsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLmluaXRGb2xkcyhkYXRhLmRldGFpbCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdndW9fbm90aWZ5JyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHNlbGYuaW5pdEZvbGRzKGRhdGEuZGV0YWlsKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBcbiAgICBpbml0QWxsRm9sZHM6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNlYXRzID0gY2MudnYuZ2FtZU5ldE1nci5zZWF0cztcbiAgICAgICAgZm9yKHZhciBpIGluIHNlYXRzKXtcbiAgICAgICAgICAgIHRoaXMuaW5pdEZvbGRzKHNlYXRzW2ldKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgaW5pdEZvbGRzOmZ1bmN0aW9uKHNlYXREYXRhKXtcbiAgICAgICAgdmFyIGZvbGRzID0gc2VhdERhdGEuZm9sZHM7XG4gICAgICAgIGlmKGZvbGRzID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2NhbEluZGV4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KHNlYXREYXRhLnNlYXRpbmRleCk7XG4gICAgICAgIHZhciBwcmUgPSBjYy52di5tYWhqb25nbWdyLmdldEZvbGRQcmUobG9jYWxJbmRleCk7XG4gICAgICAgIHZhciBzaWRlID0gY2MudnYubWFoam9uZ21nci5nZXRTaWRlKGxvY2FsSW5kZXgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGZvbGRzU3ByaXRlcyA9IHRoaXMuX2ZvbGRzW3NpZGVdO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZm9sZHNTcHJpdGVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGk7XG4gICAgICAgICAgICBpZihzaWRlID09IFwicmlnaHRcIiB8fCBzaWRlID09IFwidXBcIil7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb2xkc1Nwcml0ZXMubGVuZ3RoIC0gaSAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gZm9sZHNTcHJpdGVzW2luZGV4XTtcbiAgICAgICAgICAgIHNwcml0ZS5ub2RlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNldFNwcml0ZUZyYW1lQnlNSklEKHByZSxzcHJpdGUsZm9sZHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgaSA9IGZvbGRzLmxlbmd0aDsgaSA8IGZvbGRzU3ByaXRlcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpO1xuICAgICAgICAgICAgaWYoc2lkZSA9PSBcInJpZ2h0XCIgfHwgc2lkZSA9PSBcInVwXCIpe1xuICAgICAgICAgICAgICAgIGluZGV4ID0gZm9sZHNTcHJpdGVzLmxlbmd0aCAtIGkgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IGZvbGRzU3ByaXRlc1tpbmRleF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IG51bGw7XG4gICAgICAgICAgICBzcHJpdGUubm9kZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSAgXG4gICAgfSxcbiAgICBcbiAgICBzZXRTcHJpdGVGcmFtZUJ5TUpJRDpmdW5jdGlvbihwcmUsc3ByaXRlLG1qaWQpe1xuICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKHByZSxtamlkKTtcbiAgICAgICAgc3ByaXRlLm5vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZGF0YUV2ZW50SGFuZGxlcjpudWxsLFxuICAgICAgICByb29tSWQ6bnVsbCxcbiAgICAgICAgbWF4TnVtT2ZHYW1lczotMSxcbiAgICAgICAgbnVtT2ZHYW1lczotMSxcbiAgICAgICAgbnVtT2ZNSjowLFxuICAgICAgICBzZWF0SW5kZXg6LTEsXG4gICAgICAgIHNlYXRzOm51bGwsXG4gICAgICAgIHR1cm46LTEsXG4gICAgICAgIGJ1dHRvbjotMSxcbiAgICAgICAgZGluZ3F1ZTotMSxcbiAgICAgICAgY2h1cGFpOi0xLFxuICAgICAgICBpc0RpbmdRdWVpbmc6ZmFsc2UsXG4gICAgICAgIGlzSHVhblNhblpoYW5nOmZhbHNlLFxuICAgICAgICBnYW1lc3RhdGU6XCJcIixcbiAgICAgICAgaXNPdmVyOmZhbHNlLFxuICAgICAgICBkaXNzb3ZlRGF0YTpudWxsLFxuICAgICAgICBcbiAgICAgICAgLy/oiJ/lsbHpurvlsIbpop3lpJblsZ7mgKdcbiAgICAgICAgZmVuZ3hpYW5nOm51bGwsXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgfSxcbiAgICBcbiAgICByZXNldDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnR1cm4gPSAtMTtcbiAgICAgICAgdGhpcy5jaHVwYWkgPSAtMSxcbiAgICAgICAgdGhpcy5kaW5ncXVlID0gLTE7XG4gICAgICAgIHRoaXMuYnV0dG9uID0gLTE7XG4gICAgICAgIHRoaXMuZ2FtZXN0YXRlID0gXCJcIjtcbiAgICAgICAgdGhpcy5kaW5ncXVlID0gLTE7XG4gICAgICAgIHRoaXMuaXNEaW5nUXVlaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNIdWFuU2FuWmhhbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJhY3Rpb24gPSBudWxsO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWF0cy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB0aGlzLnNlYXRzW2ldLmhvbGRzID0gW107XG4gICAgICAgICAgICB0aGlzLnNlYXRzW2ldLmZvbGRzID0gW107XG4gICAgICAgICAgICB0aGlzLnNlYXRzW2ldLnBlbmdzID0gW107XG4gICAgICAgICAgICB0aGlzLnNlYXRzW2ldLmNoaXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VhdHNbaV0uaHVhcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zZWF0c1tpXS5hbmdhbmdzID0gW107XG4gICAgICAgICAgICB0aGlzLnNlYXRzW2ldLmRpYW5nYW5ncyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zZWF0c1tpXS53YW5nYW5ncyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zZWF0c1tpXS5kaW5ncXVlID0gLTE7XG4gICAgICAgICAgICB0aGlzLnNlYXRzW2ldLnJlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNlYXRzW2ldLmh1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2VhdHNbaV0uaHVhbnBhaXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5odWFucGFpbWV0aG9kID0gLTE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGNsZWFyOmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuZGF0YUV2ZW50SGFuZGxlciA9IG51bGw7XG4gICAgICAgIGlmKHRoaXMuaXNPdmVyID09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5zZWF0cyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJvb21JZCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLm1heE51bU9mR2FtZXMgPSAwO1xuICAgICAgICAgICAgdGhpcy5udW1PZkdhbWVzID0gMDsgXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGRpc3BhdGNoRXZlbnQoZXZlbnQsZGF0YSl7XG4gICAgICAgIGlmKHRoaXMuZGF0YUV2ZW50SGFuZGxlcil7XG4gICAgICAgICAgICB0aGlzLmRhdGFFdmVudEhhbmRsZXIuZW1pdChldmVudCxkYXRhKTtcbiAgICAgICAgfSAgICBcbiAgICB9LFxuICAgIFxuICAgIGdldFNlYXRJbmRleEJ5SUQ6ZnVuY3Rpb24odXNlcklkKXtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuc2VhdHMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnNlYXRzW2ldO1xuICAgICAgICAgICAgaWYocy51c2VyaWQgPT0gdXNlcklkKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfSxcbiAgICBcbiAgICBpc093bmVyOmZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB0aGlzLnNlYXRJbmRleCA9PSAwOyAgIFxuICAgIH0sXG4gICAgXG4gICAgZ2V0U2VhdEJ5SUQ6ZnVuY3Rpb24odXNlcklkKXtcbiAgICAgICAgdmFyIHNlYXRJbmRleCA9IHRoaXMuZ2V0U2VhdEluZGV4QnlJRCh1c2VySWQpO1xuICAgICAgICB2YXIgc2VhdCA9IHRoaXMuc2VhdHNbc2VhdEluZGV4XTtcbiAgICAgICAgcmV0dXJuIHNlYXQ7XG4gICAgfSxcbiAgICBcbiAgICBnZXRTZWxmRGF0YTpmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5zZWF0c1t0aGlzLnNlYXRJbmRleF07XG4gICAgfSxcbiAgICBcbiAgICBnZXRMb2NhbEluZGV4OmZ1bmN0aW9uKGluZGV4KXtcbiAgICAgICAgdmFyIHJldCA9IChpbmRleCAtIHRoaXMuc2VhdEluZGV4ICsgNCkgJSA0O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgXG4gICAgcHJlcGFyZVJlcGxheTpmdW5jdGlvbihyb29tSW5mbyxkZXRhaWxPZkdhbWUpe1xuICAgICAgICBjb25zb2xlLmxvZyhcInByZXBhcmVSZXBsYXkhISFcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKHJvb21JbmZvKTtcbiAgICAgICAgY29uc29sZS5sb2coZGV0YWlsT2ZHYW1lKTtcbiAgICAgICAgdGhpcy5yb29tSWQgPSByb29tSW5mby5pZDtcbiAgICAgICAgdGhpcy5zZWF0cyA9IHJvb21JbmZvLnNlYXRzO1xuICAgICAgICB0aGlzLnR1cm4gPSBkZXRhaWxPZkdhbWUuYmFzZV9pbmZvLmJ1dHRvbjtcbiAgICAgICAgdmFyIGJhc2VJbmZvID0gZGV0YWlsT2ZHYW1lLmJhc2VfaW5mbztcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuc2VhdHMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIHMgPSB0aGlzLnNlYXRzW2ldO1xuICAgICAgICAgICAgcy5zZWF0aW5kZXggPSBpO1xuICAgICAgICAgICAgcy5zY29yZSA9IG51bGw7XG4gICAgICAgICAgICBzLmhvbGRzID0gYmFzZUluZm8uZ2FtZV9zZWF0c1tpXTtcbiAgICAgICAgICAgIHMucGVuZ3MgPSBbXTtcbiAgICAgICAgICAgIHMuY2hpcyA9IFtdO1xuICAgICAgICAgICAgcy5odWFzID0gW107XG4gICAgICAgICAgICBzLmFuZ2FuZ3MgPSBbXTtcbiAgICAgICAgICAgIHMuZGlhbmdhbmdzID0gW107XG4gICAgICAgICAgICBzLndhbmdhbmdzID0gW107XG4gICAgICAgICAgICBzLmZvbGRzID0gW107XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhzKTtcbiAgICAgICAgICAgIGlmKGNjLnZ2LnVzZXJNZ3IudXNlcklkID09IHMudXNlcmlkKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNlYXRJbmRleCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25mID0ge1xuICAgICAgICAgICAgdHlwZTpiYXNlSW5mby50eXBlLFxuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuY29uZi50eXBlID09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5jb25mLnR5cGUgPT0gXCJzam1tbWpcIjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZ2V0V2FuZmE6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGNvbmYgPSB0aGlzLmNvbmY7XG4gICAgICAgIGlmKGNvbmYgJiYgY29uZi5tYXhHYW1lcyE9bnVsbCAmJiBjb25mLm1heEZhbiE9bnVsbCl7XG4gICAgICAgICAgICB2YXIgc3RyQXJyID0gW107XG4gICAgICAgICAgICAvLyBzdHJBcnIucHVzaChjb25mLm1heEdhbWVzICsgXCLlsYBcIik7XG4gICAgICAgICAgICAvLyBzdHJBcnIucHVzaChjb25mLm1heEZhbiArIFwi55Wq5bCB6aG2XCIpO1xuICAgICAgICAgICAgaWYgKGNvbmYudHlwZSA9PSBcInNqbW1qXCIpIHtcbiAgICAgICAgICAgICAgICAoY29uZi5rb3VmZWkgPT0gMCkgPyBzdHJBcnIucHVzaChcIuaIv+S4u+WHuui1hFwiKSA6IHN0ckFyci5wdXNoKFwi546p5a625bmz5YiGXCIpIDtcbiAgICAgICAgICAgICAgICAoY29uZi5ob25nemhvbmdkYW5naHVhKSA/IHN0ckFyci5wdXNoKFwi57qi5Lit5b2T6IqxXCIpIDoge30gO1xuICAgICAgICAgICAgICAgIChjb25mLnF1YW5zaHUgPT0gMCkgPyBzdHJBcnIucHVzaChcIjjlsYBcIikgOiBzdHJBcnIucHVzaChcIuS4gOWciFwiKSA7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmYuamllc3VhbiA9PSAwKSBzdHJBcnIucHVzaChcIuW5uuWNilwiKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb25mLmppZXN1YW4gPT0gMSkgc3RyQXJyLnB1c2goXCLkuIDkuoxcIik7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY29uZi5qaWVzdWFuID09IDIpIHN0ckFyci5wdXNoKFwi5LqM5ZubXCIpO1xuICAgICAgICAgICAgfWVsc2UgaWYgKGNvbmYudHlwZSA9PSBcImRobWpcIikge1xuICAgICAgICAgICAgICAgIChjb25mLmtvdWZlaSA9PSAwKSA/IHN0ckFyci5wdXNoKFwi5oi/5Li75Ye66LWEXCIpIDogc3RyQXJyLnB1c2goXCLnjqnlrrblubPliIZcIikgO1xuICAgICAgICAgICAgICAgIChjb25mLnF1YW5zaHUgPT0gMCkgPyBzdHJBcnIucHVzaChcIjjlsYBcIikgOiBzdHJBcnIucHVzaChcIuS4gOWciFwiKSA7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmYuamllc3VhbiA9PSAwKSBzdHJBcnIucHVzaChcIjEwXCIpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmYuamllc3VhbiA9PSAxKSBzdHJBcnIucHVzaChcIjI1XCIpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmYuamllc3VhbiA9PSAyKSBzdHJBcnIucHVzaChcIjUwXCIpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbmYuamllc3VhbiA9PSAzKSBzdHJBcnIucHVzaChcIjEyMFwiKTtcbiAgICAgICAgICAgIH1lbHNlIGlmIChjb25mLnR5cGUgPT0gXCJ0ZGhcIikge1xuICAgICAgICAgICAgICAgIChjb25mLmtvdWZlaSA9PSAwKSA/IHN0ckFyci5wdXNoKFwi5oi/5Li75Ye66LWEXCIpIDogc3RyQXJyLnB1c2goXCLnjqnlrrblubPliIZcIikgO1xuICAgICAgICAgICAgICAgIChjb25mLnF1YW5zaHUgPT0gMCkgPyBzdHJBcnIucHVzaChcIjjlsYBcIikgOiBzdHJBcnIucHVzaChcIuS4gOWciFwiKSA7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmYuamllc3VhbiA9PSAwKSBzdHJBcnIucHVzaChcIuacieiKsVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmKGNvbmYuemltbyA9PSAxKXtcbiAgICAgICAgICAgIC8vICAgICBzdHJBcnIucHVzaChcIuiHquaRuOWKoOeVqlwiKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGVsc2V7XG4gICAgICAgICAgICAvLyAgICAgc3RyQXJyLnB1c2goXCLoh6rmkbjliqDlupVcIik7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBpZihjb25mLmppYW5nZHVpKXtcbiAgICAgICAgICAgIC8vICAgICBzdHJBcnIucHVzaChcIuWwhuWvuVwiKTsgICBcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGlmKGNvbmYuZGlhbmdhbmdodWEgPT0gMSl7XG4gICAgICAgICAgICAvLyAgICAgc3RyQXJyLnB1c2goXCLngrnmnaDoirEo6Ieq5pG4KVwiKTsgICBcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGVsc2V7XG4gICAgICAgICAgICAvLyAgICAgc3RyQXJyLnB1c2goXCLngrnmnaDoirEo5pS+54KuKVwiKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGlmKGNvbmYubWVucWluZyl7XG4gICAgICAgICAgICAvLyAgICAgc3RyQXJyLnB1c2goXCLpl6jmuIXjgIHkuK3lvKBcIik7ICAgXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBpZihjb25mLnRpYW5kaWh1KXtcbiAgICAgICAgICAgIC8vICAgICBzdHJBcnIucHVzaChcIuWkqeWcsOiDoVwiKTsgICBcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJBcnIuam9pbihcIiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfSxcbiAgICBcbiAgICBpbml0SGFuZGxlcnM6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImxvZ2luX3Jlc3VsdFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJsb2dpbl9yZXN1bHRcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIGlmKGRhdGEuZXJyY29kZSA9PT0gMCl7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRhdGE7XG4gICAgICAgICAgICAgICAgc2VsZi5yb29tSWQgPSBkYXRhLnJvb21pZDtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmYgPSBkYXRhLmNvbmY7XG4gICAgICAgICAgICAgICAgc2VsZi5tYXhOdW1PZkdhbWVzID0gZGF0YS5jb25mLm1heEdhbWVzO1xuICAgICAgICAgICAgICAgIHNlbGYubnVtT2ZHYW1lcyA9IGRhdGEubnVtb2ZnYW1lcztcbiAgICAgICAgICAgICAgICBzZWxmLmZlbmd4aWFuZyA9IGRhdGEuZmVuZ3hpYW5nO1xuICAgICAgICAgICAgICAgIHNlbGYuc2VhdHMgPSBkYXRhLnNlYXRzO1xuICAgICAgICAgICAgICAgIHNlbGYuc2VhdEluZGV4ID0gc2VsZi5nZXRTZWF0SW5kZXhCeUlEKGNjLnZ2LnVzZXJNZ3IudXNlcklkKTtcbiAgICAgICAgICAgICAgICBzZWxmLmlzT3ZlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhLmVycm1zZyk7ICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImxvZ2luX2ZpbmlzaGVkXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImxvZ2luX2ZpbmlzaGVkXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJtamdhbWVcIik7ICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gdmFyIGxvYWRnYW1lID0gZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICAvLyAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKFwibWpnYW1lXCIpOyAgXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyB2YXIgZmFkZW91dCA9IGNjLmZhZGVPdXQoMC4xKTtcbiAgICAgICAgICAgIC8vIHZhciBmaW5pc2ggPSBjYy5jYWxsRnVuYyhsb2FkZ2FtZSwgdGhpcyk7XG4gICAgICAgICAgICAvLyB2YXIgc2VxID0gY2Muc2VxdWVuY2UoZmFkZW91dCwgZmluaXNoKTtcbiAgICAgICAgICAgIC8vIGNjLmRpcmVjdG9yLmdldFNjZW5lKCkuZ2V0Q2hpbGRCeU5hbWUoJ0NhbnZhcycpLnJ1bkFjdGlvbihzZXEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9jYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJtamdhbWVcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZXhpdF9yZXN1bHRcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHNlbGYucm9vbUlkID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYudHVybiA9IC0xO1xuICAgICAgICAgICAgc2VsZi5kaW5ncXVlID0gLTE7XG4gICAgICAgICAgICBzZWxmLmlzRGluZ1F1ZWluZyA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5zZWF0cyA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJleGl0X25vdGlmeV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgIHZhciB1c2VySWQgPSBkYXRhO1xuICAgICAgICAgICB2YXIgcyA9IHNlbGYuZ2V0U2VhdEJ5SUQodXNlcklkKTtcbiAgICAgICAgICAgaWYocyAhPSBudWxsKXtcbiAgICAgICAgICAgICAgIHMudXNlcmlkID0gMDtcbiAgICAgICAgICAgICAgIHMubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJ1c2VyX3N0YXRlX2NoYW5nZWRcIixzKTtcbiAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZGlzcHJlc3NfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgc2VsZi5yb29tSWQgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi50dXJuID0gLTE7XG4gICAgICAgICAgICBzZWxmLmRpbmdxdWUgPSAtMTtcbiAgICAgICAgICAgIHNlbGYuaXNEaW5nUXVlaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLnNlYXRzID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZGlzY29ubmVjdFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgaWYoc2VsZi5yb29tSWQgPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKFwiaGFsbFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgaWYoc2VsZi5pc092ZXIgPT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgICAgICBjYy52di51c2VyTWdyLm9sZFJvb21JZCA9IHNlbGYucm9vbUlkO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJkaXNjb25uZWN0XCIpOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucm9vbUlkID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJuZXdfdXNlcl9jb21lc19wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgICAgdmFyIHNlYXRJbmRleCA9IGRhdGEuc2VhdGluZGV4O1xuICAgICAgICAgICAgaWYoc2VsZi5zZWF0c1tzZWF0SW5kZXhdLnVzZXJpZCA+IDApe1xuICAgICAgICAgICAgICAgIHNlbGYuc2VhdHNbc2VhdEluZGV4XS5vbmxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBkYXRhLm9ubGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5zZWF0c1tzZWF0SW5kZXhdID0gZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnbmV3X3VzZXInLHNlbGYuc2VhdHNbc2VhdEluZGV4XSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJ1c2VyX3N0YXRlX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICB2YXIgdXNlcklkID0gZGF0YS51c2VyaWQ7XG4gICAgICAgICAgICB2YXIgc2VhdCA9IHNlbGYuZ2V0U2VhdEJ5SUQodXNlcklkKTtcbiAgICAgICAgICAgIHNlYXQub25saW5lID0gZGF0YS5vbmxpbmU7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ3VzZXJfc3RhdGVfY2hhbmdlZCcsc2VhdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJ1c2VyX3JlYWR5X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICB2YXIgdXNlcklkID0gZGF0YS51c2VyaWQ7XG4gICAgICAgICAgICB2YXIgc2VhdCA9IHNlbGYuZ2V0U2VhdEJ5SUQodXNlcklkKTtcbiAgICAgICAgICAgIHNlYXQucmVhZHkgPSBkYXRhLnJlYWR5O1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCd1c2VyX3N0YXRlX2NoYW5nZWQnLHNlYXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZ2FtZV9ob2xkc19wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICB2YXIgc2VhdCA9IHNlbGYuc2VhdHNbc2VsZi5zZWF0SW5kZXhdOyBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgICAgc2VhdC5ob2xkcyA9IGRhdGE7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLnNlYXRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IHNlbGYuc2VhdHNbaV07IFxuICAgICAgICAgICAgICAgIGlmKHMuZm9sZHMgPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHMuZm9sZHMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYocy5wZW5ncyA9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgcy5wZW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihzLmFuZ2FuZ3MgPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHMuYW5nYW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihzLmRpYW5nYW5ncyA9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgcy5kaWFuZ2FuZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYocy5jaGlzID09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICBzLmNoaXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYocy5odWFzID09IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICBzLmh1YXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYocy53YW5nYW5ncyA9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgcy53YW5nYW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzLnJlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2dhbWVfaG9sZHMnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImdhbWVfZmVuZ19wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLmZlbmd4aWFuZyA9IGRhdGE7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2dhbWVfZmVuZycpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX2JlZ2luX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnYW1lX2FjdGlvbl9wdXNoJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHNlbGYuYnV0dG9uID0gZGF0YTtcbiAgICAgICAgICAgIHNlbGYudHVybiA9IHNlbGYuYnV0dG9uO1xuICAgICAgICAgICAgc2VsZi5nYW1lc3RhdGUgPSBcImJlZ2luXCI7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2dhbWVfYmVnaW4nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImdhbWVfcGxheWluZ19wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ2FtZV9wbGF5aW5nX3B1c2gnKTsgXG4gICAgICAgICAgICBzZWxmLmdhbWVzdGF0ZSA9IFwicGxheWluZ1wiOyBcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZ2FtZV9wbGF5aW5nJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX3N5bmNfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJnYW1lX3N5bmNfcHVzaFwiKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgICAgc2VsZi5udW1PZk1KID0gZGF0YS5udW1vZm1qO1xuICAgICAgICAgICAgc2VsZi5nYW1lc3RhdGUgPSBkYXRhLnN0YXRlO1xuICAgICAgICAgICAgc2VsZi5mZW5neGlhbmcgPSBkYXRhLmZlbmd4aWFuZztcbiAgICAgICAgICAgIGlmKHNlbGYuZ2FtZXN0YXRlID09IFwiZGluZ3F1ZVwiKXtcbiAgICAgICAgICAgICAgICBzZWxmLmlzRGluZ1F1ZWluZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKHNlbGYuZ2FtZXN0YXRlID09IFwiaHVhbnBhaVwiKXtcbiAgICAgICAgICAgICAgICBzZWxmLmlzSHVhblNhblpoYW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYudHVybiA9IGRhdGEudHVybjtcbiAgICAgICAgICAgIHNlbGYuYnV0dG9uID0gZGF0YS5idXR0b247XG4gICAgICAgICAgICBzZWxmLmNodXBhaSA9IGRhdGEuY2h1UGFpO1xuICAgICAgICAgICAgc2VsZi5odWFucGFpbWV0aG9kID0gZGF0YS5odWFucGFpbWV0aG9kO1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDQ7ICsraSl7XG4gICAgICAgICAgICAgICAgdmFyIHNlYXQgPSBzZWxmLnNlYXRzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBzZCA9IGRhdGEuc2VhdHNbaV07XG4gICAgICAgICAgICAgICAgc2VhdC5ob2xkcyA9IHNkLmhvbGRzO1xuICAgICAgICAgICAgICAgIHNlYXQuZm9sZHMgPSBzZC5mb2xkcztcbiAgICAgICAgICAgICAgICBzZWF0LmFuZ2FuZ3MgPSBzZC5hbmdhbmdzO1xuICAgICAgICAgICAgICAgIHNlYXQuZGlhbmdhbmdzID0gc2QuZGlhbmdhbmdzO1xuICAgICAgICAgICAgICAgIHNlYXQud2FuZ2FuZ3MgPSBzZC53YW5nYW5ncztcbiAgICAgICAgICAgICAgICBzZWF0LnBlbmdzID0gc2QucGVuZ3M7XG4gICAgICAgICAgICAgICAgc2VhdC5jaGlzID0gc2QuY2hpcztcbiAgICAgICAgICAgICAgICBzZWF0Lmh1YXMgPSBzZC5odWFzO1xuICAgICAgICAgICAgICAgIHNlYXQuZGluZ3F1ZSA9IHNkLnF1ZTtcbiAgICAgICAgICAgICAgICBzZWF0Lmh1ZWQgPSBzZC5odWVkOyBcbiAgICAgICAgICAgICAgICBzZWF0LmlzemltbyA9IHNkLmlzemltbztcbiAgICAgICAgICAgICAgICBzZWF0Lmh1aW5mbyA9IHNkLmh1aW5mbztcbiAgICAgICAgICAgICAgICBzZWF0Lmh1YW5wYWlzID0gc2QuaHVhbnBhaXM7XG4gICAgICAgICAgICAgICAgaWYoaSA9PSBzZWxmLnNlYXRJbmRleCl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGluZ3F1ZSA9IHNkLnF1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX2h1YW5wYWlfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgc2VsZi5pc0h1YW5TYW5aaGFuZyA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2dhbWVfaHVhbnBhaScpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiaGFuZ2FuZ19ub3RpZnlfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdoYW5nYW5nX25vdGlmeScsZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX2FjdGlvbl9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLmN1cmFjdGlvbiA9IGRhdGE7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZ2FtZV9hY3Rpb24nLGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX251bV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLm51bU9mR2FtZXMgPSBkYXRhO1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdnYW1lX251bScsZGF0YSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZ2FtZV9vdmVyX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnYW1lX292ZXJfcHVzaCcpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IGRhdGEucmVzdWx0cztcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWxmLnNlYXRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICBzZWxmLnNlYXRzW2ldLnNjb3JlID0gcmVzdWx0cy5sZW5ndGggPT0gMD8gMDpyZXN1bHRzW2ldLnRvdGFsc2NvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2dhbWVfb3ZlcicscmVzdWx0cyk7XG4gICAgICAgICAgICBpZihkYXRhLmVuZGluZm8pe1xuICAgICAgICAgICAgICAgIHNlbGYuaXNPdmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2dhbWVfZW5kJyxkYXRhLmVuZGluZm8pOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVzZXQoKTtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAgc2VsZi5zZWF0cy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCd1c2VyX3N0YXRlX2NoYW5nZWQnLHNlbGYuc2VhdHNbaV0pOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcIm1qX2NvdW50X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdtal9jb3VudF9wdXNoJyk7XG4gICAgICAgICAgICBzZWxmLm51bU9mTUogPSBkYXRhO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnbWpfY291bnQnLGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZ2FtZV9jaHVwYWlfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dhbWVfY2h1cGFpX3B1c2gnKTtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICB2YXIgdHVyblVzZXJJRCA9IGRhdGE7XG4gICAgICAgICAgICB2YXIgc2kgPSBzZWxmLmdldFNlYXRJbmRleEJ5SUQodHVyblVzZXJJRCk7XG4gICAgICAgICAgICBzZWxmLmRvVHVybkNoYW5nZShzaSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJodV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnaHVfcHVzaCcpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICBzZWxmLmRvSHUoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX2NodXBhaV9ub3RpZnlfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgdmFyIHVzZXJJZCA9IGRhdGEudXNlcklkO1xuICAgICAgICAgICAgdmFyIHBhaSA9IGRhdGEucGFpO1xuICAgICAgICAgICAgdmFyIHNpID0gc2VsZi5nZXRTZWF0SW5kZXhCeUlEKHVzZXJJZCk7XG4gICAgICAgICAgICBzZWxmLmRvQ2h1cGFpKHNpLHBhaSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX21vcGFpX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnYW1lX21vcGFpX3B1c2gnKTtcbiAgICAgICAgICAgIHNlbGYuZG9Nb3BhaShzZWxmLnNlYXRJbmRleCxkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImd1b19ub3RpZnlfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2d1b19ub3RpZnlfcHVzaCcpO1xuICAgICAgICAgICAgdmFyIHVzZXJJZCA9IGRhdGEudXNlcklkO1xuICAgICAgICAgICAgdmFyIHBhaSA9IGRhdGEucGFpO1xuICAgICAgICAgICAgdmFyIHNpID0gc2VsZi5nZXRTZWF0SW5kZXhCeUlEKHVzZXJJZCk7XG4gICAgICAgICAgICBzZWxmLmRvR3VvKHNpLHBhaSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJndW9fcmVzdWx0XCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ3VvX3Jlc3VsdCcpO1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdndW9fcmVzdWx0Jyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJndW9odV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ3VvaHVfcHVzaCcpO1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicHVzaF9ub3RpY2VcIix7aW5mbzpcIui/h+iDoVwiLHRpbWU6MS41fSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJodWFucGFpX25vdGlmeVwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgdmFyIHNlYXQgPSBzZWxmLmdldFNlYXRCeUlEKGRhdGEuc2kpO1xuICAgICAgICAgICAgc2VhdC5odWFucGFpcyA9IGRhdGEuaHVhbnBhaXM7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoJ2h1YW5wYWlfbm90aWZ5JyxzZWF0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcImdhbWVfaHVhbnBhaV9vdmVyX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnYW1lX2h1YW5wYWlfb3Zlcl9wdXNoJyk7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gZGF0YS5tZXRob2Q7XG4gICAgICAgICAgICBpZihtZXRob2QgPT0gMCl7XG4gICAgICAgICAgICAgICAgaW5mbyA9IFwi5o2i5a+55a6254mMXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKG1ldGhvZCA9PSAxKXtcbiAgICAgICAgICAgICAgICBpbmZvID0gXCLmjaLkuIvlrrbniYxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgaW5mbyA9IFwi5o2i5LiK5a6254mMXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmh1YW5wYWltZXRob2QgPSBtZXRob2Q7XG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmlzSHVhblNhblpoYW5nID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJnYW1lX2h1YW5wYWlfb3ZlclwiKTtcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcInB1c2hfbm90aWNlXCIse2luZm86aW5mbyx0aW1lOjJ9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcInBlbmdfbm90aWZ5X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwZW5nX25vdGlmeV9wdXNoJyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHZhciB1c2VySWQgPSBkYXRhLnVzZXJpZDtcbiAgICAgICAgICAgIHZhciBwYWkgPSBkYXRhLnBhaTtcbiAgICAgICAgICAgIHZhciBzaSA9IHNlbGYuZ2V0U2VhdEluZGV4QnlJRCh1c2VySWQpO1xuICAgICAgICAgICAgc2VsZi5kb1Blbmcoc2ksZGF0YS5wYWkpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiZ2FuZ19ub3RpZnlfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dhbmdfbm90aWZ5X3B1c2gnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgICAgdmFyIHVzZXJJZCA9IGRhdGEudXNlcmlkO1xuICAgICAgICAgICAgdmFyIHBhaSA9IGRhdGEucGFpO1xuICAgICAgICAgICAgdmFyIHNpID0gc2VsZi5nZXRTZWF0SW5kZXhCeUlEKHVzZXJJZCk7XG4gICAgICAgICAgICBzZWxmLmRvR2FuZyhzaSxwYWksZGF0YS5nYW5ndHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJjaGlfbm90aWZ5X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjaGlfbm90aWZ5X3B1c2gnKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgICAgdmFyIHVzZXJJZCA9IGRhdGEudXNlcmlkO1xuICAgICAgICAgICAgdmFyIHBhaSA9IGRhdGEucGFpO1xuICAgICAgICAgICAgdmFyIGNoaWdyb3VwID0gZGF0YS5jaGlncm91cDtcbiAgICAgICAgICAgIHZhciBzaSA9IHNlbGYuZ2V0U2VhdEluZGV4QnlJRCh1c2VySWQpO1xuICAgICAgICAgICAgc2VsZi5kb0NoaShzaSxkYXRhLnBhaSxjaGlncm91cCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnZXRodWFfbm90aWZ5X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnZXRodWFfbm90aWZ5X3B1c2gnKTtcbiAgICAgICAgICAgIHZhciB1c2VySWQgPSBkYXRhLnVzZXJpZDtcbiAgICAgICAgICAgIHZhciBwYWkgPSBkYXRhLnBhaTtcbiAgICAgICAgICAgIHZhciBzaSA9IHNlbGYuZ2V0U2VhdEluZGV4QnlJRCh1c2VySWQpO1xuICAgICAgICAgICAgc2VsZi5kb0h1YShzaSxkYXRhLnBhaSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgLy/lvIDlsYDooaXoirHkvqblkKwg5YWo5bGAXG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKFwiYnVodWFfbm90aWZ5X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdidWh1YV9ub3RpZnlfcHVzaCcpO1xuICAgICAgICAgICAgdmFyIHVzZXJJZCA9IGRhdGEudXNlcmlkO1xuICAgICAgICAgICAgdmFyIGJ1aHVhcyA9IGRhdGEuYnVodWFzO1xuICAgICAgICAgICAgdmFyIHNpID0gc2VsZi5nZXRTZWF0SW5kZXhCeUlEKHVzZXJJZCk7XG4gICAgICAgICAgICBzZWxmLmRvQnVodWEoc2ksYnVodWFzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvL+W8gOWxgOihpeiKseS+puWQrCDoh6rlt7FcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX2J1aHVhX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnYW1lX2J1aHVhX3B1c2gnKTtcbiAgICAgICAgICAgIHZhciB1c2VySWQgPSBkYXRhLnVzZXJpZDtcbiAgICAgICAgICAgIHZhciBob2xkcyA9IGRhdGEuaG9sZHM7XG4gICAgICAgICAgICB2YXIgYnVodWFzID0gZGF0YS5idWh1YXM7XG4gICAgICAgICAgICB2YXIgc2kgPSBzZWxmLmdldFNlYXRJbmRleEJ5SUQodXNlcklkKTtcbiAgICAgICAgICAgIHNlbGYuZG9CdWh1YWZvcm1lKHNpLGhvbGRzLGJ1aHVhcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX2RpbmdxdWVfbm90aWZ5X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudCgnZ2FtZV9kaW5ncXVlX25vdGlmeScsZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJnYW1lX2RpbmdxdWVfZmluaXNoX3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICBzZWxmLnNlYXRzW2ldLmRpbmdxdWUgPSBkYXRhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KCdnYW1lX2RpbmdxdWVfZmluaXNoJyxkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJjaGF0X3B1c2hcIixmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChcImNoYXRfcHVzaFwiLGRhdGEpOyAgICBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcInF1aWNrX2NoYXRfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwicXVpY2tfY2hhdF9wdXNoXCIsZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJlbW9qaV9wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJlbW9qaV9wdXNoXCIsZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJkaXNzb2x2ZV9ub3RpY2VfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJkaXNzb2x2ZV9ub3RpY2VfcHVzaFwiKTsgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHNlbGYuZGlzc292ZURhdGEgPSBkYXRhO1xuICAgICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KFwiZGlzc29sdmVfbm90aWNlXCIsZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgY2MudnYubmV0LmFkZEhhbmRsZXIoXCJkaXNzb2x2ZV9jYW5jZWxfcHVzaFwiLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgc2VsZi5kaXNzb3ZlRGF0YSA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJkaXNzb2x2ZV9jYW5jZWxcIixkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBjYy52di5uZXQuYWRkSGFuZGxlcihcInZvaWNlX21zZ19wdXNoXCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLmRpc3BhdGNoRXZlbnQoXCJ2b2ljZV9tc2dcIixkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBcbiAgICBkb0d1bzpmdW5jdGlvbihzZWF0SW5kZXgscGFpKXtcbiAgICAgICAgdmFyIHNlYXREYXRhID0gdGhpcy5zZWF0c1tzZWF0SW5kZXhdO1xuICAgICAgICB2YXIgZm9sZHMgPSBzZWF0RGF0YS5mb2xkcztcbiAgICAgICAgZm9sZHMucHVzaChwYWkpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2d1b19ub3RpZnknLHNlYXREYXRhKTsgICAgXG4gICAgfSxcbiAgICBcbiAgICBkb01vcGFpOmZ1bmN0aW9uKHNlYXRJbmRleCxwYWkpe1xuICAgICAgICB2YXIgc2VhdERhdGEgPSB0aGlzLnNlYXRzW3NlYXRJbmRleF07XG4gICAgICAgIGlmKHNlYXREYXRhLmhvbGRzKXtcbiAgICAgICAgICAgIHNlYXREYXRhLmhvbGRzLnB1c2gocGFpKTtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZ2FtZV9tb3BhaScse3NlYXRJbmRleDpzZWF0SW5kZXgscGFpOnBhaX0pOyAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBkb0NodXBhaTpmdW5jdGlvbihzZWF0SW5kZXgscGFpKXtcbiAgICAgICAgdGhpcy5jaHVwYWkgPSBwYWk7XG4gICAgICAgIHZhciBzZWF0RGF0YSA9IHRoaXMuc2VhdHNbc2VhdEluZGV4XTtcbiAgICAgICAgaWYoc2VhdERhdGEuaG9sZHMpeyAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBpZHggPSBzZWF0RGF0YS5ob2xkcy5pbmRleE9mKHBhaSk7XG4gICAgICAgICAgICBzZWF0RGF0YS5ob2xkcy5zcGxpY2UoaWR4LDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZ2FtZV9jaHVwYWlfbm90aWZ5Jyx7c2VhdERhdGE6c2VhdERhdGEscGFpOnBhaX0pOyAgICBcbiAgICB9LFxuICAgIFxuICAgIGRvUGVuZzpmdW5jdGlvbihzZWF0SW5kZXgscGFpKXtcbiAgICAgICAgY29uc29sZS5sb2coc2VhdEluZGV4KTtcbiAgICAgICAgdmFyIHNlYXREYXRhID0gdGhpcy5zZWF0c1tzZWF0SW5kZXhdO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnNlYXRzW3NlYXRJbmRleF0pO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnNlYXRzWzBdKTtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5zZWF0c1tcIjBcIl0pO1xuICAgICAgICBjb25zb2xlLmxvZyhzZWF0RGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKHNlYXREYXRhLmh1YXMpO1xuICAgICAgICBjb25zb2xlLmxvZyhzZWF0RGF0YS51c2VyaWQpO1xuICAgICAgICAvL+enu+mZpOaJi+eJjFxuICAgICAgICBpZihzZWF0RGF0YS5ob2xkcyl7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMjsgKytpKXtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gc2VhdERhdGEuaG9sZHMuaW5kZXhPZihwYWkpO1xuICAgICAgICAgICAgICAgIHNlYXREYXRhLmhvbGRzLnNwbGljZShpZHgsMSk7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgLy/mm7TmlrDnorDniYzmlbDmja5cbiAgICAgICAgdmFyIHBlbmdzID0gc2VhdERhdGEucGVuZ3M7XG4gICAgICAgIHBlbmdzLnB1c2gocGFpKTtcbiAgICAgICAgICAgIFxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3Blbmdfbm90aWZ5JyxzZWF0RGF0YSk7XG4gICAgfSxcbiAgICBcbiAgICBkb0NoaTpmdW5jdGlvbihzZWF0SW5kZXgscGFpLGNoaWdyb3VwKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJkb2NoaVwiKTtcbiAgICAgICAgdmFyIHNlYXREYXRhID0gdGhpcy5zZWF0c1tzZWF0SW5kZXhdO1xuICAgICAgICBjb25zb2xlLmxvZyhzZWF0RGF0YSk7XG4gICAgICAgIC8v56e76Zmk5omL54mMXG4gICAgICAgIGlmKHNlYXREYXRhLmhvbGRzKXtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAzOyArK2kpe1xuICAgICAgICAgICAgICAgIGlmKHBhaSA9PSBjaGlncm91cFtpXSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IHNlYXREYXRhLmhvbGRzLmluZGV4T2YoY2hpZ3JvdXBbaV0pO1xuICAgICAgICAgICAgICAgIHNlYXREYXRhLmhvbGRzLnNwbGljZShpZHgsMSk7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgLy/mm7TmlrDlkIPniYzmlbDmja5cbiAgICAgICAgdmFyIGNoaXMgPSBzZWF0RGF0YS5jaGlzO1xuICAgICAgICBjaGlzLnB1c2goY2hpZ3JvdXApO1xuICAgICAgICAgICAgXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnY2hpX25vdGlmeScsc2VhdERhdGEpO1xuICAgIH0sXG4gICAgXG4gICAgZG9IdWE6ZnVuY3Rpb24oc2VhdEluZGV4LHBhaSl7XG4gICAgICAgIHZhciBzZWF0RGF0YSA9IHRoaXMuc2VhdHNbc2VhdEluZGV4XTtcbiAgICAgICAgLy/mm7TmlrDoirHniYzmlbDmja5cbiAgICAgICAgaWYoc2VhdERhdGEuaHVhcyA9PSB1bmRlZmluZWQgfHwgc2VhdERhdGEuaHVhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBzZWF0RGF0YS5odWFzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGh1YXMgPSBzZWF0RGF0YS5odWFzO1xuICAgICAgICBodWFzLnB1c2gocGFpKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdnZXRodWFfbm90aWZ5JyxzZWF0RGF0YSk7XG4gICAgfSxcbiAgICBcbiAgICBkb0J1aHVhOmZ1bmN0aW9uKHNlYXRJbmRleCxidWh1YXMpe1xuICAgICAgICBjb25zb2xlLmxvZyhcImRhIGJ1aHVhXCIpO1xuICAgICAgICAgdmFyIHNlYXREYXRhID0gdGhpcy5zZWF0c1tzZWF0SW5kZXhdO1xuICAgICAgICAvL+abtOaWsOiKseeJjOaVsOaNrlxuICAgICAgICBpZihzZWF0RGF0YS5odWFzID09IHVuZGVmaW5lZCB8fCBzZWF0RGF0YS5odWFzID09IG51bGwpIHtcbiAgICAgICAgICAgIHNlYXREYXRhLmh1YXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaHVhcyA9IHNlYXREYXRhLmh1YXM7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBidWh1YXMubGVuZ3RoIDsgaSsrKXtcbiAgICAgICAgICAgIGh1YXMucHVzaChidWh1YXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZ2V0aHVhX25vdGlmeScsc2VhdERhdGEpO1xuICAgIH0sXG4gICAgXG4gICAgZG9CdWh1YWZvcm1lOmZ1bmN0aW9uKHNlYXRJbmRleCxob2xkcyxidWh1YXMpe1xuICAgICAgICBjb25zb2xlLmxvZyhcImRhIGJ1aHVhXCIpO1xuICAgICAgICB2YXIgc2VhdERhdGEgPSB0aGlzLnNlYXRzW3NlYXRJbmRleF07XG4gICAgICAgIC8vIGZvcih2YXIgaT0wIDsgaSA8IGhvbGRzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAvLyAgICAgc2VhdERhdGEuaG9sZHMucHVzaChob2xkc1tpXSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZm9yKHZhciBpPTAgOyBpIDwgYnVodWFzLmxlbmd0aCA7IGkrKykge1xuICAgICAgICAvLyAgICAgdmFyIGlkeCA9IHNlYXREYXRhLmhvbGRzLmluZGV4T2YoYnVodWFzW2ldKTtcbiAgICAgICAgLy8gICAgIHNlYXREYXRhLmhvbGRzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgc2VhdERhdGEuaG9sZHMgPSBob2xkcztcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdidWh1YV9ub3RpZnknLHNlYXREYXRhKTtcbiAgICB9LFxuICAgIFxuICAgIGdldEdhbmdUeXBlOmZ1bmN0aW9uKHNlYXREYXRhLHBhaSl7XG4gICAgICAgIGlmKHNlYXREYXRhLnBlbmdzLmluZGV4T2YocGFpKSAhPSAtMSl7XG4gICAgICAgICAgICByZXR1cm4gXCJ3YW5nYW5nXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHZhciBjbnQgPSAwO1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlYXREYXRhLmhvbGRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICBpZihzZWF0RGF0YS5ob2xkc1tpXSA9PSBwYWkpe1xuICAgICAgICAgICAgICAgICAgICBjbnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihjbnQgPT0gMyl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZGlhbmdhbmdcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYW5nYW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGRvR2FuZzpmdW5jdGlvbihzZWF0SW5kZXgscGFpLGdhbmd0eXBlKXtcbiAgICAgICAgdmFyIHNlYXREYXRhID0gdGhpcy5zZWF0c1tzZWF0SW5kZXhdO1xuICAgICAgICBcbiAgICAgICAgaWYoIWdhbmd0eXBlKXtcbiAgICAgICAgICAgIGdhbmd0eXBlID0gdGhpcy5nZXRHYW5nVHlwZShzZWF0RGF0YSxwYWkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihnYW5ndHlwZSA9PSBcIndhbmdhbmdcIil7XG4gICAgICAgICAgICBpZihzZWF0RGF0YS5wZW5ncy5pbmRleE9mKHBhaSkgIT0gLTEpe1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBzZWF0RGF0YS5wZW5ncy5pbmRleE9mKHBhaSk7XG4gICAgICAgICAgICAgICAgaWYoaWR4ICE9IC0xKXtcbiAgICAgICAgICAgICAgICAgICAgc2VhdERhdGEucGVuZ3Muc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWF0RGF0YS53YW5nYW5ncy5wdXNoKHBhaSk7ICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgaWYoc2VhdERhdGEuaG9sZHMpe1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8PSA0OyArK2kpe1xuICAgICAgICAgICAgICAgIHZhciBpZHggPSBzZWF0RGF0YS5ob2xkcy5pbmRleE9mKHBhaSk7XG4gICAgICAgICAgICAgICAgaWYoaWR4ID09IC0xKXtcbiAgICAgICAgICAgICAgICAgICAgLy/lpoLmnpzmsqHmnInmib7liLDvvIzooajnpLrnp7vlrozkuobvvIznm7TmjqXot7Plh7rlvqrnjq9cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlYXREYXRhLmhvbGRzLnNwbGljZShpZHgsMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoZ2FuZ3R5cGUgPT0gXCJhbmdhbmdcIil7XG4gICAgICAgICAgICBzZWF0RGF0YS5hbmdhbmdzLnB1c2gocGFpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGdhbmd0eXBlID09IFwiZGlhbmdhbmdcIil7XG4gICAgICAgICAgICBzZWF0RGF0YS5kaWFuZ2FuZ3MucHVzaChwYWkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnZ2FuZ19ub3RpZnknLHtzZWF0RGF0YTpzZWF0RGF0YSxnYW5ndHlwZTpnYW5ndHlwZX0pO1xuICAgIH0sXG4gICAgXG4gICAgZG9IdTpmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdodXBhaScsZGF0YSk7XG4gICAgfSxcbiAgICBcbiAgICBkb1R1cm5DaGFuZ2U6ZnVuY3Rpb24oc2kpe1xuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGxhc3Q6dGhpcy50dXJuLFxuICAgICAgICAgICAgdHVybjpzaSxcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnR1cm4gPSBzaTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdnYW1lX2NodXBhaScsZGF0YSk7XG4gICAgfSxcbiAgICBcbiAgICBcbiAgICBjb25uZWN0R2FtZVNlcnZlcjpmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgdGhpcy5kaXNzb3ZlRGF0YSA9IG51bGw7XG4gICAgICAgIGNjLnZ2Lm5ldC5pcCA9IGRhdGEuaXAgKyBcIjpcIiArIGRhdGEucG9ydDtcbiAgICAgICAgY29uc29sZS5sb2coY2MudnYubmV0LmlwKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBvbkNvbm5lY3RPSyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9uQ29ubmVjdE9LXCIpO1xuICAgICAgICAgICAgdmFyIHNkID0ge1xuICAgICAgICAgICAgICAgIHRva2VuOmRhdGEudG9rZW4sXG4gICAgICAgICAgICAgICAgcm9vbWlkOmRhdGEucm9vbWlkLFxuICAgICAgICAgICAgICAgIHRpbWU6ZGF0YS50aW1lLFxuICAgICAgICAgICAgICAgIHNpZ246ZGF0YS5zaWduLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwibG9naW5cIixzZCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgb25Db25uZWN0RmFpbGVkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZmFpbGVkLlwiKTtcbiAgICAgICAgICAgIGNjLnZ2LndjLmhpZGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2MudnYud2Muc2hvdyhcIuato+WcqOi/m+WFpeaIv+mXtFwiKTtcbiAgICAgICAgY2MudnYubmV0LmNvbm5lY3Qob25Db25uZWN0T0ssb25Db25uZWN0RmFpbGVkKTtcbiAgICB9XG5cbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG5cbiAgICAvLyB9LFxufSk7XG4iLCJjYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICAvLyBmb286IHtcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICAgICAgX2dhbWVvdmVyOm51bGwsXG4gICAgICAgIF9nYW1lcmVzdWx0Om51bGwsXG4gICAgICAgIF9zZWF0czpbXSxcbiAgICAgICAgX2lzR2FtZUVuZDpmYWxzZSxcbiAgICAgICAgX3BpbmdqdTpudWxsLFxuICAgICAgICBfd2luOm51bGwsXG4gICAgICAgIF9sb3NlOm51bGwsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLmNvbmYgPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy9UT0RPOuWPr+iDveWHuueOsOS4jeWQjOeahOiuoeWIhuadv1xuICAgICAgICB0aGlzLl9nYW1lb3ZlciA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVfb3Zlcl9cIitjYy52di5nYW1lTmV0TWdyLmNvbmYudHlwZSk7XG4gICAgICAgIFxuICAgICAgICBmb3IodmFyIG4gPSAwOyBuIDwgNDsgbisrKXtcbiAgICAgICAgICAgIHZhciBodWFfbm9kZSA9IHRoaXMuX2dhbWVvdmVyLmdldENoaWxkQnlOYW1lKFwicmVzdWx0X2xpc3RcIikuZ2V0Q2hpbGRCeU5hbWUoXCJzXCIrKG4rMSkpLmdldENoaWxkQnlOYW1lKFwiaHVhc1wiKTtcbiAgICAgICAgICAgIGZvcih2YXIgbSA9IDAgOyBtIDwgaHVhX25vZGUuY2hpbGRyZW5Db3VudCA7IG0rKykge1xuICAgICAgICAgICAgICAgIGh1YV9ub2RlLmNoaWxkcmVuW21dLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9nYW1lb3Zlci5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3BpbmdqdSA9IHRoaXMuX2dhbWVvdmVyLmdldENoaWxkQnlOYW1lKFwicGluZ2p1XCIpO1xuICAgICAgICB0aGlzLl93aW4gPSB0aGlzLl9nYW1lb3Zlci5nZXRDaGlsZEJ5TmFtZShcIndpblwiKTtcbiAgICAgICAgdGhpcy5fbG9zZSA9IHRoaXMuX2dhbWVvdmVyLmdldENoaWxkQnlOYW1lKFwibG9zZVwiKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2dhbWVyZXN1bHQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJnYW1lX3Jlc3VsdFwiKTtcbiAgICAgICAgXG4gICAgICAgIHZhciB3YW5mYSA9IHRoaXMuX2dhbWVvdmVyLmdldENoaWxkQnlOYW1lKFwid2FuZmFcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcbiAgICAgICAgd2FuZmEuc3RyaW5nID0gY2MudnYuZ2FtZU5ldE1nci5nZXRXYW5mYSgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGxpc3RSb290ID0gdGhpcy5fZ2FtZW92ZXIuZ2V0Q2hpbGRCeU5hbWUoXCJyZXN1bHRfbGlzdFwiKTtcbiAgICAgICAgZm9yKHZhciBpID0gMTsgaSA8PSA0OyArK2kpe1xuICAgICAgICAgICAgdmFyIHMgPSBcInNcIiArIGk7XG4gICAgICAgICAgICB2YXIgc24gPSBsaXN0Um9vdC5nZXRDaGlsZEJ5TmFtZShzKTtcbiAgICAgICAgICAgIC8v5pW055CG5omA5pyJ6ZyA6KaB5pi+56S65Zyo6K6h5YiG5p2/5LiK55qE5L+h5oGv55qE6IqC54K5XG4gICAgICAgICAgICB2YXIgdmlld2RhdGEgPSB7fTtcbiAgICAgICAgICAgIHZpZXdkYXRhLnVzZXJuYW1lID0gc24uZ2V0Q2hpbGRCeU5hbWUoJ3VzZXJuYW1lJykuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcbiAgICAgICAgICAgIHZpZXdkYXRhLnJlYXNvbiA9IHNuLmdldENoaWxkQnlOYW1lKCdyZWFzb24nKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xuICAgICAgICAgICAgdmlld2RhdGEudGFpc2kgPSBzbi5nZXRDaGlsZEJ5TmFtZSgndGFpc2knKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZiA9IHNuLmdldENoaWxkQnlOYW1lKCdmYW4nKTtcbiAgICAgICAgICAgIGlmKGYgIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgdmlld2RhdGEuZmFuID0gZi5nZXRDb21wb25lbnQoY2MuTGFiZWwpOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmlld2RhdGEuc2NvcmUgPSBzbi5nZXRDaGlsZEJ5TmFtZSgnc2NvcmUnKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xuICAgICAgICAgICAgdmlld2RhdGEuaHUgPSBzbi5nZXRDaGlsZEJ5TmFtZSgnaHUnKTtcbiAgICAgICAgICAgIHZpZXdkYXRhLm1haGpvbmdzID0gc24uZ2V0Q2hpbGRCeU5hbWUoJ3BhaScpO1xuICAgICAgICAgICAgdmlld2RhdGEuemh1YW5nID0gc24uZ2V0Q2hpbGRCeU5hbWUoJ3podWFuZycpO1xuICAgICAgICAgICAgdmlld2RhdGEuaHVwYWkgPSBzbi5nZXRDaGlsZEJ5TmFtZSgnaHVwYWknKTtcbiAgICAgICAgICAgIHZpZXdkYXRhLl9wZW5nYW5kZ2FuZyA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLl9zZWF0cy5wdXNoKHZpZXdkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy/liJ3lp4vljJbnvZHnu5zkuovku7bnm5HlkKzlmahcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfb3ZlcicsZnVuY3Rpb24oZGF0YSl7c2VsZi5vbkdhbWVPdmVyKGRhdGEuZGV0YWlsKTt9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9lbmQnLGZ1bmN0aW9uKGRhdGEpe3NlbGYuX2lzR2FtZUVuZCA9IHRydWU7fSk7XG4gICAgfSxcbiAgICBcbiAgICBvbkdhbWVPdmVyKGRhdGEpe1xuICAgICAgICAvL1RPRE865aSa56eN5Yik5a6aXG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuY29uZi50eXBlID09IFwic2ptbWpcIil7XG4gICAgICAgICAgICB0aGlzLm9uR2FtZU92ZXJfU0pNTUooZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihjYy52di5nYW1lTmV0TWdyLmNvbmYudHlwZSA9PSBcImRobWpcIikge1xuICAgICAgICAgICAgdGhpcy5vbkdhbWVPdmVyX0RITUooZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihjYy52di5nYW1lTmV0TWdyLmNvbmYudHlwZSA9PSBcInRkaFwiKSB7XG4gICAgICAgICAgICB0aGlzLm9uR2FtZU92ZXJfVERIKGRhdGEpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBvbkdhbWVPdmVyX1NKTU1KKGRhdGEpe1xuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICB0aGlzLl9nYW1lcmVzdWx0LmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2FtZW92ZXIuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGluZ2p1LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl93aW4uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xvc2UuYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIG15c2NvcmUgPSBkYXRhW2NjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4XS5zY29yZTtcbiAgICAgICAgaWYobXlzY29yZSA+IDApe1xuICAgICAgICAgICAgdGhpcy5fd2luLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH0gICAgICAgICBcbiAgICAgICAgZWxzZSBpZihteXNjb3JlIDwgMCl7XG4gICAgICAgICAgICB0aGlzLl9sb3NlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHRoaXMuX3BpbmdqdS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgIC8v5pi+56S6546p5a625L+h5oGvXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCA0OyArK2kpe1xuICAgICAgICAgICAgdmFyIHNlYXRWaWV3ID0gdGhpcy5fc2VhdHNbaV07XG4gICAgICAgICAgICB2YXIgdXNlckRhdGEgPSBkYXRhW2ldO1xuICAgICAgICAgICAgdmFyIGh1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8v6IOh54mM55qE546p5a625omN5pi+56S6IOaYr+WQpua4heS4gOiJsiDmoLl4bueahOWtl+agt1xuICAgICAgICAgICAgdmFyIG51bU9mR2FuZ3MgPSB1c2VyRGF0YS5hbmdhbmdzLmxlbmd0aCArIHVzZXJEYXRhLndhbmdhbmdzLmxlbmd0aCArIHVzZXJEYXRhLmRpYW5nYW5ncy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbnVtT2ZHZW4gPSB1c2VyRGF0YS5udW1vZmdlbjtcbiAgICAgICAgICAgIHZhciBhY3Rpb25BcnIgPSBbXTtcbiAgICAgICAgICAgIHZhciBpczdwYWlycyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGlzY2hhZGFqaWFvID0gZmFsc2U7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHVzZXJEYXRhLmFjdGlvbnMubGVuZ3RoOyArK2ope1xuICAgICAgICAgICAgICAgIHZhciBhYyA9IHVzZXJEYXRhLmFjdGlvbnNbal07XG4gICAgICAgICAgICAgICAgaWYoYWMudHlwZSA9PSBcInppbW9cIiB8fCBhYy50eXBlID09IFwiZ2FuZ2h1YVwiIHx8IGFjLnR5cGUgPT0gXCJkaWFuZ2FuZ2h1YVwiIHx8IGFjLnR5cGUgPT0gXCJodVwiIHx8IGFjLnR5cGUgPT0gXCJnYW5ncGFvaHVcIiB8fCBhYy50eXBlID09IFwicWlhbmdnYW5naHVcIiB8fCBhYy50eXBlID09IFwiY2hhZGFqaWFvXCIpe1xuICAgICAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5wYXR0ZXJuID09IFwiN3BhaXJzXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLkuIPlr7lcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih1c2VyRGF0YS5wYXR0ZXJuID09IFwibDdwYWlyc1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6b6Z5LiD5a+5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodXNlckRhdGEucGF0dGVybiA9PSBcImo3cGFpcnNcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuWwhuS4g+WvuVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHVzZXJEYXRhLnBhdHRlcm4gPT0gXCJkdWlkdWlcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIueisOeisOiDoVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHVzZXJEYXRhLnBhdHRlcm4gPT0gXCJqaWFuZ2R1aVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5bCG5a+5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihhYy50eXBlID09IFwiemltb1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6Ieq5pG4XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImdhbmdodWFcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuadoOS4iuiKsVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJkaWFuZ2FuZ2h1YVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi54K55p2g6IqxXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImdhbmdwYW9odVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5p2g54Ku6IOhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcInFpYW5nZ2FuZ2h1XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmiqLmnaDog6FcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiY2hhZGFqaWFvXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNjaGFkYWppYW8gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGh1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJmYW5ncGFvXCIpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaUvueCrlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiYW5nYW5nXCIpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaal+adoFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiZGlhbmdhbmdcIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5piO5p2gXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJ3YW5nYW5nXCIpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuW8r+adoFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiZmFuZ2dhbmdcIil7XG4gICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmlL7mnaBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcInpodWFuc2hvdWdhbmdcIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6L2s5omL5p2gXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJiZWlxaWFuZ2dhbmdcIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6KKr5oqi5p2gXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJiZWljaGFkYWppYW9cIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6KKr5p+l5Y+rXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoaHVlZCl7XG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEucWluZ3lpc2Upe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIua4heS4gOiJslwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEubWVucWluZyl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6Zeo5riFXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS56aG9uZ3poYW5nKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLkuK3lvKBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLmppbmdvdWh1KXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLph5Hpkqnog6FcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5oYWlkaWh1KXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmtbflupXog6FcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLnRpYW5odSl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5aSp6IOhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5kaWh1KXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLlnLDog6FcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYobnVtT2ZHZW4gPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmoLl4XCIgKyBudW1PZkdlbik7IFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoaXNjaGFkYWppYW8pe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuafpeWkp+WPq1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEuaHVueWlzZSl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5re35LiA6ImyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5kdWlkdWlodSl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5a+55a+56IOhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5wYWlodSl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5o6S6IOhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5nYW5nc2hhbmdodWEpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuadoOS4iuiKsVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEua2FuKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLlnY7moaNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLmJpYW4pe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIui+ueaho1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEuZGFuKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLljZXlkIpcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLmR1aWRhbyl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5a+55YCSXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKHZhciBvID0gMDsgbyA8IDM7KytvKXtcbiAgICAgICAgICAgICAgICBzZWF0Vmlldy5odS5jaGlsZHJlbltvXS5hY3RpdmUgPSBmYWxzZTsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih1c2VyRGF0YS5odW9yZGVyID49IDApe1xuICAgICAgICAgICAgICAgIHNlYXRWaWV3Lmh1LmNoaWxkcmVuW3VzZXJEYXRhLmh1b3JkZXJdLmFjdGl2ZSA9IHRydWU7ICAgIFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWF0Vmlldy51c2VybmFtZS5zdHJpbmcgPSBjYy52di5nYW1lTmV0TWdyLnNlYXRzW2ldLm5hbWU7XG4gICAgICAgICAgICBzZWF0Vmlldy56aHVhbmcuYWN0aXZlID0gY2MudnYuZ2FtZU5ldE1nci5idXR0b24gPT0gaTtcbiAgICAgICAgICAgIHNlYXRWaWV3LnJlYXNvbi5zdHJpbmcgPSBhY3Rpb25BcnIuam9pbihcIuOAgVwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy/mmL7npLrkuJ3mlbDlj7DmlbBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwi5pi+56S65Y+w5ZKM5LidXCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codXNlckRhdGEudGFpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHVzZXJEYXRhLnNpKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCBzZWF0Vmlldy50YWlzaS5zdHJpbmcpO1xuICAgICAgICAgICAgc2VhdFZpZXcudGFpc2kuc3RyaW5nID0gdXNlckRhdGEudGFpICsgXCLlj7BcIiArIHVzZXJEYXRhLnNpICsgXCLkuJ1cIjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy/mmL7npLrog6HmlbBcbiAgICAgICAgICAgIHZhciBmYW4gPSAwO1xuICAgICAgICAgICAgZmFuID0gdXNlckRhdGEuZmFuO1xuICAgICAgICAgICAgc2VhdFZpZXcuZmFuLnN0cmluZyA9IGZhbiArIFwi6IOhXCI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYodXNlckRhdGEuc2NvcmUgPiAwKXtcbiAgICAgICAgICAgICAgICBzZWF0Vmlldy5zY29yZS5zdHJpbmcgPSBcIitcIiArIHVzZXJEYXRhLnNjb3JlOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgc2VhdFZpZXcuc2NvcmUuc3RyaW5nID0gdXNlckRhdGEuc2NvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgaHVwYWkgPSAtMTtcbiAgICAgICAgICAgIGlmKGh1ZWQpe1xuICAgICAgICAgICAgICAgIGh1cGFpID0gdXNlckRhdGEuaG9sZHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNjLnZ2Lm1haGpvbmdtZ3Iuc29ydE1KKHVzZXJEYXRhLmhvbGRzLHVzZXJEYXRhLmRpbmdxdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+iDoeeJjOS4jeWPguS4juaOkuW6j1xuICAgICAgICAgICAgaWYoaHVlZCl7XG4gICAgICAgICAgICAgICAgdXNlckRhdGEuaG9sZHMucHVzaChodXBhaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8v6ZqQ6JeP5omA5pyJ54mMXG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgc2VhdFZpZXcubWFoam9uZ3MuY2hpbGRyZW5Db3VudDsgKytrKXtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHNlYXRWaWV3Lm1haGpvbmdzLmNoaWxkcmVuW2tdO1xuICAgICAgICAgICAgICAgIG4uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGxhY2tpbmdOdW0gPSAodXNlckRhdGEucGVuZ3MubGVuZ3RoICsgbnVtT2ZHYW5ncyArIHVzZXJEYXRhLmNoaXMubGVuZ3RoKSozOyBcbiAgICAgICAgICAgIC8v5pi+56S655u45YWz55qE54mMXG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgdXNlckRhdGEuaG9sZHMubGVuZ3RoOyArK2spe1xuICAgICAgICAgICAgICAgIHZhciBwYWkgPSB1c2VyRGF0YS5ob2xkc1trXTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHNlYXRWaWV3Lm1haGpvbmdzLmNoaWxkcmVuW2sgKyBsYWNraW5nTnVtXTtcbiAgICAgICAgICAgICAgICBuLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG4uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XG4gICAgICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIscGFpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgc2VhdFZpZXcuX3BlbmdhbmRnYW5nLmxlbmd0aDsgKytrKXtcbiAgICAgICAgICAgICAgICBzZWF0Vmlldy5fcGVuZ2FuZGdhbmdba10uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8v5Yid5aeL5YyW5p2g54mMXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIGdhbmdzID0gdXNlckRhdGEuYW5nYW5ncztcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBnYW5ncy5sZW5ndGg7ICsrayl7XG4gICAgICAgICAgICAgICAgdmFyIG1qaWQgPSBnYW5nc1trXTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRQZW5nQW5kR2FuZ3Moc2VhdFZpZXcsaW5kZXgsbWppZCxcImFuZ2FuZ1wiKTtcbiAgICAgICAgICAgICAgICBpbmRleCsrOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGdhbmdzID0gdXNlckRhdGEuZGlhbmdhbmdzO1xuICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGdhbmdzLmxlbmd0aDsgKytrKXtcbiAgICAgICAgICAgICAgICB2YXIgbWppZCA9IGdhbmdzW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhzZWF0VmlldyxpbmRleCxtamlkLFwiZGlhbmdhbmdcIik7XG4gICAgICAgICAgICAgICAgaW5kZXgrKzsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBnYW5ncyA9IHVzZXJEYXRhLndhbmdhbmdzO1xuICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGdhbmdzLmxlbmd0aDsgKytrKXtcbiAgICAgICAgICAgICAgICB2YXIgbWppZCA9IGdhbmdzW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhzZWF0VmlldyxpbmRleCxtamlkLFwid2FuZ2FuZ1wiKTtcbiAgICAgICAgICAgICAgICBpbmRleCsrOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy/liJ3lp4vljJbnorDniYxcbiAgICAgICAgICAgIHZhciBwZW5ncyA9IHVzZXJEYXRhLnBlbmdzXG4gICAgICAgICAgICBpZihwZW5ncyl7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IHBlbmdzLmxlbmd0aDsgKytrKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1qaWQgPSBwZW5nc1trXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0UGVuZ0FuZEdhbmdzKHNlYXRWaWV3LGluZGV4LG1qaWQsXCJwZW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrOyAgICBcbiAgICAgICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+WIneWni+WMluWQg+eJjFxuICAgICAgICAgICAgdmFyIGNoaXMgPSB1c2VyRGF0YS5jaGlzIFxuICAgICAgICAgICAgaWYoY2hpcyl7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGNoaXMubGVuZ3RoOyArK2spe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWppZCA9IGNoaXNba107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhzZWF0VmlldyxpbmRleCxtamlkLFwiY2hpXCIpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrOyAgICBcbiAgICAgICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+WIneWni+WMluiKseeJjCBUT0RPOuWSjOS4i+mdouS4gOagt+WGmeWIneWni+WMluWHveaVsCDlubbkuJTopoHpppblhYjpmpDol4/miYDmnInnmoToirFcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBodWFzID0gdXNlckRhdGEuaHVhczsgXG4gICAgICAgICAgICB2YXIgaHVhX25vZGUgPSB0aGlzLl9nYW1lb3Zlci5nZXRDaGlsZEJ5TmFtZShcInJlc3VsdF9saXN0XCIpLmdldENoaWxkQnlOYW1lKFwic1wiKyhpKzEpKS5nZXRDaGlsZEJ5TmFtZShcImh1YXNcIik7XG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgaHVhX25vZGUuY2hpbGRyZW5Db3VudDsgKytrKXtcbiAgICAgICAgICAgICAgICBodWFfbm9kZS5jaGlsZHJlbltrXS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgaWYoaHVhcyl7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGh1YXMubGVuZ3RoOyArK2spe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWppZCA9IGh1YXNba107XG4gICAgICAgICAgICAgICAgICAgIGh1YV9ub2RlLmNoaWxkcmVuW2tdLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcCA9IGh1YV9ub2RlLmNoaWxkcmVuW2tdLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xuICAgICAgICAgICAgICAgICAgICBzcC5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQoXCJNX1wiLG1qaWQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8v5Lic5Y2X6KW/5YyX5bCP5peX5a2Q6L2s5o2iXG4gICAgICAgICAgICB2YXIgc3dpdGNoRmVuZ0ZsYWcgPSBmdW5jdGlvbiAoZGlyZWN0aW9uLGRpcl9zdHIpe1xuICAgICAgICAgICAgICAgIGZvcih2YXIgayA9IDAgOyBrIDwgNCA7IGsgKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uLmNoaWxkcmVuW2tdLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24uZ2V0Q2hpbGRCeU5hbWUoZGlyX3N0cikuYWN0aXZlPXRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+aYvuekuuW9k+WJjemjjuWciOWSjOWxgOaVsFxuICAgICAgICAgICAgdmFyIG51bW9mZ2FtZXMgPSB0aGlzLl9nYW1lb3Zlci5nZXRDaGlsZEJ5TmFtZShcIm51bW9mZ2FtZXNcIik7XG4gICAgICAgICAgICB2YXIgZmVuZ3F1YW4gPSBcIuS4nOmjjuWciFwiO1xuICAgICAgICAgICAgc3dpdGNoIChjYy52di5nYW1lTmV0TWdyLmZlbmd4aWFuZykge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogZmVuZ3F1YW4gPSBcIuS4nOmjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogZmVuZ3F1YW4gPSBcIuWNl+mjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogZmVuZ3F1YW4gPSBcIuilv+mjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogZmVuZ3F1YW4gPSBcIuWMl+mjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtb2ZnYW1lcy5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGZlbmdxdWFuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+WIpOaWreS4nOWNl+ilv+WMl1xuICAgICAgICAgICAgaWYodXNlckRhdGEuYnV0dG9uKXtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZ2FtZW92ZXIuZ2V0Q2hpbGRCeU5hbWUoXCJyZXN1bHRfbGlzdFwiKS5nZXRDaGlsZEJ5TmFtZShcInNcIisoaSU0KzEpKS5nZXRDaGlsZEJ5TmFtZShcImRpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hGZW5nRmxhZyhkaXJlY3Rpb24sXCJkb25nXCIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLl9nYW1lb3Zlci5nZXRDaGlsZEJ5TmFtZShcInJlc3VsdF9saXN0XCIpLmdldENoaWxkQnlOYW1lKFwic1wiKygoKGkrMSklNCkrMSkpLmdldENoaWxkQnlOYW1lKFwiZGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHN3aXRjaEZlbmdGbGFnKGRpcmVjdGlvbixcIm5hblwiKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZ2FtZW92ZXIuZ2V0Q2hpbGRCeU5hbWUoXCJyZXN1bHRfbGlzdFwiKS5nZXRDaGlsZEJ5TmFtZShcInNcIisoKChpKzIpJTQpKzEpKS5nZXRDaGlsZEJ5TmFtZShcImRpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hGZW5nRmxhZyhkaXJlY3Rpb24sXCJ4aVwiKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZ2FtZW92ZXIuZ2V0Q2hpbGRCeU5hbWUoXCJyZXN1bHRfbGlzdFwiKS5nZXRDaGlsZEJ5TmFtZShcInNcIisoKChpKzMpJTQpKzEpKS5nZXRDaGlsZEJ5TmFtZShcImRpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hGZW5nRmxhZyhkaXJlY3Rpb24sXCJiZWlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uR2FtZU92ZXJfREhNSjpmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgIGlmKGRhdGEubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgdGhpcy5fZ2FtZXJlc3VsdC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dhbWVvdmVyLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BpbmdqdS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fd2luLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9sb3NlLmFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBteXNjb3JlID0gZGF0YVtjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleF0uc2NvcmU7XG4gICAgICAgIGlmKG15c2NvcmUgPiAwKXtcbiAgICAgICAgICAgIHRoaXMuX3dpbi5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9ICAgICAgICAgXG4gICAgICAgIGVsc2UgaWYobXlzY29yZSA8IDApe1xuICAgICAgICAgICAgdGhpcy5fbG9zZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0aGlzLl9waW5nanUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAvL+aYvuekuueOqeWutuS/oeaBr1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgNDsgKytpKXtcbiAgICAgICAgICAgIHZhciBzZWF0VmlldyA9IHRoaXMuX3NlYXRzW2ldO1xuICAgICAgICAgICAgdmFyIHVzZXJEYXRhID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHZhciBodWVkID0gZmFsc2U7XG4gICAgICAgICAgICAvL+iDoeeJjOeahOeOqeWutuaJjeaYvuekuiDmmK/lkKbmuIXkuIDoibIg5qC5eG7nmoTlrZfmoLdcbiAgICAgICAgICAgIHZhciBudW1PZkdhbmdzID0gdXNlckRhdGEuYW5nYW5ncy5sZW5ndGggKyB1c2VyRGF0YS53YW5nYW5ncy5sZW5ndGggKyB1c2VyRGF0YS5kaWFuZ2FuZ3MubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIG51bU9mR2VuID0gdXNlckRhdGEubnVtb2ZnZW47XG4gICAgICAgICAgICB2YXIgYWN0aW9uQXJyID0gW107XG4gICAgICAgICAgICB2YXIgaXM3cGFpcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpc2NoYWRhamlhbyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHVzZXJEYXRhLmFjdGlvbnMubGVuZ3RoOyArK2ope1xuICAgICAgICAgICAgICAgIHZhciBhYyA9IHVzZXJEYXRhLmFjdGlvbnNbal07XG4gICAgICAgICAgICAgICAgaWYoYWMudHlwZSA9PSBcInppbW9cIiB8fCBhYy50eXBlID09IFwiZ2FuZ2h1YVwiIHx8IGFjLnR5cGUgPT0gXCJkaWFuZ2FuZ2h1YVwiIHx8IGFjLnR5cGUgPT0gXCJodVwiIHx8IGFjLnR5cGUgPT0gXCJnYW5ncGFvaHVcIiB8fCBhYy50eXBlID09IFwicWlhbmdnYW5naHVcIiB8fCBhYy50eXBlID09IFwiY2hhZGFqaWFvXCIpe1xuICAgICAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5wYXR0ZXJuID09IFwiN3BhaXJzXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLkuIPlr7lcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih1c2VyRGF0YS5wYXR0ZXJuID09IFwibDdwYWlyc1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6b6Z5LiD5a+5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodXNlckRhdGEucGF0dGVybiA9PSBcImo3cGFpcnNcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuWwhuS4g+WvuVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHVzZXJEYXRhLnBhdHRlcm4gPT0gXCJkdWlkdWlcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIueisOeisOiDoVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHVzZXJEYXRhLnBhdHRlcm4gPT0gXCJqaWFuZ2R1aVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5bCG5a+5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihhYy50eXBlID09IFwiemltb1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6Ieq5pG4XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImdhbmdodWFcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuadoOS4iuiKsVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJkaWFuZ2FuZ2h1YVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi54K55p2g6IqxXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImdhbmdwYW9odVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5p2g54Ku6IOhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcInFpYW5nZ2FuZ2h1XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmiqLmnaDog6FcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiY2hhZGFqaWFvXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNjaGFkYWppYW8gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGh1ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJmYW5ncGFvXCIpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaUvueCrlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiYW5nYW5nXCIpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaal+adoFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiZGlhbmdhbmdcIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5piO5p2gXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJ3YW5nYW5nXCIpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuW8r+adoFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiZmFuZ2dhbmdcIil7XG4gICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmlL7mnaBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcInpodWFuc2hvdWdhbmdcIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6L2s5omL5p2gXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJiZWlxaWFuZ2dhbmdcIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6KKr5oqi5p2gXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJiZWljaGFkYWppYW9cIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6KKr5p+l5Y+rXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJzYW5jaGlzYW5wZW5nMFwiKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLkuInlkIPkuInnorDkuJxcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcInNhbmNoaXNhbnBlbmcxXCIpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuS4ieWQg+S4ieeisOWNl1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwic2FuY2hpc2FucGVuZzJcIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5LiJ5ZCD5LiJ56Kw6KW/XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJzYW5jaGlzYW5wZW5nM1wiKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLkuInlkIPkuInnorDljJdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihodWVkKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9nYW1lb3Zlci5nZXRDaGlsZEJ5TmFtZShcInJlc3VsdF9saXN0XCIpLmdldENoaWxkQnlOYW1lKFwic1wiKyhpKzEpKS5nZXRDaGlsZEJ5TmFtZShcImh1XCIpLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEucWluZ3lpc2Upe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIua4heS4gOiJslwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEubWVucWluZyl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6Zeo5riFXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS56aG9uZ3poYW5nKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLkuK3lvKBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLmppbmdvdWh1KXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLph5Hpkqnog6FcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5oYWlkaWh1KXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmtbflupXog6FcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLnRpYW5odSl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5aSp6IOhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5kaWh1KXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLlnLDog6FcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYobnVtT2ZHZW4gPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmoLl4XCIgKyBudW1PZkdlbik7IFxuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoaXNjaGFkYWppYW8pe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuafpeWkp+WPq1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEuaHVueWlzZSl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5re35LiA6ImyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5kdWlkdWlodSl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5a+55a+56IOhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5wYWlodSl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5o6S6IOhXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5nYW5nc2hhbmdodWEpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuadoOS4iuiKsVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEua2FuKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLlnY7moaNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLmJpYW4pe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIui+ueaho1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEuZGFuKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLljZXlkIpcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLmR1aWRhbyl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5a+55YCSXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHRoaXMuX2dhbWVvdmVyLmdldENoaWxkQnlOYW1lKFwicmVzdWx0X2xpc3RcIikuZ2V0Q2hpbGRCeU5hbWUoXCJzXCIrKGkrMSkpLmdldENoaWxkQnlOYW1lKFwiaHVcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGZvcih2YXIgbyA9IDA7IG8gPCAzOysrbyl7XG4gICAgICAgICAgICAvLyAgICAgc2VhdFZpZXcuaHUuY2hpbGRyZW5bb10uYWN0aXZlID0gZmFsc2U7ICAgIFxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gaWYodXNlckRhdGEuaHVvcmRlciA+PSAwKXtcbiAgICAgICAgICAgIC8vICAgICBzZWF0Vmlldy5odS5jaGlsZHJlblt1c2VyRGF0YS5odW9yZGVyXS5hY3RpdmUgPSB0cnVlOyAgICBcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgc2VhdFZpZXcudXNlcm5hbWUuc3RyaW5nID0gY2MudnYuZ2FtZU5ldE1nci5zZWF0c1tpXS5uYW1lO1xuICAgICAgICAgICAgc2VhdFZpZXcuemh1YW5nLmFjdGl2ZSA9IGNjLnZ2LmdhbWVOZXRNZ3IuYnV0dG9uID09IGk7XG4gICAgICAgICAgICBzZWF0Vmlldy5yZWFzb24uc3RyaW5nID0gYWN0aW9uQXJyLmpvaW4oXCLjgIFcIik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8v5pi+56S65Lid5pWw5Y+w5pWwXG4gICAgICAgICAgICBpZih1c2VyRGF0YS50YWkgPT0gLTEpIHNlYXRWaWV3LnRhaXNpLnN0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICBlbHNlIHNlYXRWaWV3LnRhaXNpLnN0cmluZyA9IHVzZXJEYXRhLnRhaSArIFwi5Y+wXCI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBpZih1c2VyRGF0YS5zY29yZSA+IDApe1xuICAgICAgICAgICAgICAgIHNlYXRWaWV3LnNjb3JlLnN0cmluZyA9IFwiK1wiICsgdXNlckRhdGEuc2NvcmU7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBzZWF0Vmlldy5zY29yZS5zdHJpbmcgPSB1c2VyRGF0YS5zY29yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBodXBhaSA9IC0xO1xuICAgICAgICAgICAgaWYoaHVlZCl7XG4gICAgICAgICAgICAgICAgaHVwYWkgPSB1c2VyRGF0YS5ob2xkcy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2MudnYubWFoam9uZ21nci5zb3J0TUoodXNlckRhdGEuaG9sZHMsdXNlckRhdGEuZGluZ3F1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8v6IOh54mM5LiN5Y+C5LiO5o6S5bqPXG4gICAgICAgICAgICBpZihodWVkKXtcbiAgICAgICAgICAgICAgICB1c2VyRGF0YS5ob2xkcy5wdXNoKGh1cGFpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy/pmpDol4/miYDmnInniYxcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBzZWF0Vmlldy5tYWhqb25ncy5jaGlsZHJlbkNvdW50OyArK2spe1xuICAgICAgICAgICAgICAgIHZhciBuID0gc2VhdFZpZXcubWFoam9uZ3MuY2hpbGRyZW5ba107XG4gICAgICAgICAgICAgICAgbi5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbGFja2luZ051bSA9ICh1c2VyRGF0YS5wZW5ncy5sZW5ndGggKyBudW1PZkdhbmdzICsgdXNlckRhdGEuY2hpcy5sZW5ndGgpKjM7IFxuICAgICAgICAgICAgLy/mmL7npLrnm7jlhbPnmoTniYxcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCB1c2VyRGF0YS5ob2xkcy5sZW5ndGg7ICsrayl7XG4gICAgICAgICAgICAgICAgdmFyIHBhaSA9IHVzZXJEYXRhLmhvbGRzW2tdO1xuICAgICAgICAgICAgICAgIHZhciBuID0gc2VhdFZpZXcubWFoam9uZ3MuY2hpbGRyZW5bayArIGxhY2tpbmdOdW1dO1xuICAgICAgICAgICAgICAgIG4uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gbi5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcbiAgICAgICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixwYWkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBzZWF0Vmlldy5fcGVuZ2FuZGdhbmcubGVuZ3RoOyArK2spe1xuICAgICAgICAgICAgICAgIHNlYXRWaWV3Ll9wZW5nYW5kZ2FuZ1trXS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy/liJ3lp4vljJbmnaDniYxcbiAgICAgICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgICAgICB2YXIgZ2FuZ3MgPSB1c2VyRGF0YS5hbmdhbmdzO1xuICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGdhbmdzLmxlbmd0aDsgKytrKXtcbiAgICAgICAgICAgICAgICB2YXIgbWppZCA9IGdhbmdzW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhzZWF0VmlldyxpbmRleCxtamlkLFwiYW5nYW5nXCIpO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgZ2FuZ3MgPSB1c2VyRGF0YS5kaWFuZ2FuZ3M7XG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgZ2FuZ3MubGVuZ3RoOyArK2spe1xuICAgICAgICAgICAgICAgIHZhciBtamlkID0gZ2FuZ3Nba107XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0UGVuZ0FuZEdhbmdzKHNlYXRWaWV3LGluZGV4LG1qaWQsXCJkaWFuZ2FuZ1wiKTtcbiAgICAgICAgICAgICAgICBpbmRleCsrOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGdhbmdzID0gdXNlckRhdGEud2FuZ2FuZ3M7XG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgZ2FuZ3MubGVuZ3RoOyArK2spe1xuICAgICAgICAgICAgICAgIHZhciBtamlkID0gZ2FuZ3Nba107XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0UGVuZ0FuZEdhbmdzKHNlYXRWaWV3LGluZGV4LG1qaWQsXCJ3YW5nYW5nXCIpO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+WIneWni+WMlueisOeJjFxuICAgICAgICAgICAgdmFyIHBlbmdzID0gdXNlckRhdGEucGVuZ3NcbiAgICAgICAgICAgIGlmKHBlbmdzKXtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgcGVuZ3MubGVuZ3RoOyArK2spe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWppZCA9IHBlbmdzW2tdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRQZW5nQW5kR2FuZ3Moc2VhdFZpZXcsaW5kZXgsbWppZCxcInBlbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7ICAgIFxuICAgICAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8v5Yid5aeL5YyW5ZCD54mMXG4gICAgICAgICAgICB2YXIgY2hpcyA9IHVzZXJEYXRhLmNoaXMgXG4gICAgICAgICAgICBpZihjaGlzKXtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgY2hpcy5sZW5ndGg7ICsrayl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtamlkID0gY2hpc1trXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0UGVuZ0FuZEdhbmdzKHNlYXRWaWV3LGluZGV4LG1qaWQsXCJjaGlcIik7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7ICAgIFxuICAgICAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8v5Yid5aeL5YyW6Iqx54mMIFRPRE865ZKM5LiL6Z2i5LiA5qC35YaZ5Yid5aeL5YyW5Ye95pWwIOW5tuS4lOimgemmluWFiOmakOiXj+aJgOacieeahOiKsVxuICAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGh1YXMgPSB1c2VyRGF0YS5odWFzOyBcbiAgICAgICAgICAgIHZhciBodWFfbm9kZSA9IHRoaXMuX2dhbWVvdmVyLmdldENoaWxkQnlOYW1lKFwicmVzdWx0X2xpc3RcIikuZ2V0Q2hpbGRCeU5hbWUoXCJzXCIrKGkrMSkpLmdldENoaWxkQnlOYW1lKFwiaHVhc1wiKTtcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBodWFfbm9kZS5jaGlsZHJlbkNvdW50OyArK2spe1xuICAgICAgICAgICAgICAgIGh1YV9ub2RlLmNoaWxkcmVuW2tdLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICBpZihodWFzKXtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgaHVhcy5sZW5ndGg7ICsrayl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtamlkID0gaHVhc1trXTtcbiAgICAgICAgICAgICAgICAgICAgaHVhX25vZGUuY2hpbGRyZW5ba10uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwID0gaHVhX25vZGUuY2hpbGRyZW5ba10uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHNwLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIsbWppZCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8v5Lic5Y2X6KW/5YyX5bCP5peX5a2Q6L2s5o2iXG4gICAgICAgICAgICB2YXIgc3dpdGNoRmVuZ0ZsYWcgPSBmdW5jdGlvbiAoZGlyZWN0aW9uLGRpcl9zdHIpe1xuICAgICAgICAgICAgICAgIGZvcih2YXIgayA9IDAgOyBrIDwgNCA7IGsgKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyZWN0aW9uLmNoaWxkcmVuW2tdLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXJlY3Rpb24uZ2V0Q2hpbGRCeU5hbWUoZGlyX3N0cikuYWN0aXZlPXRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+aYvuekuuW9k+WJjemjjuWciOWSjOWxgOaVsFxuICAgICAgICAgICAgdmFyIG51bW9mZ2FtZXMgPSB0aGlzLl9nYW1lb3Zlci5nZXRDaGlsZEJ5TmFtZShcIm51bW9mZ2FtZXNcIik7XG4gICAgICAgICAgICB2YXIgZmVuZ3F1YW4gPSBcIuS4nOmjjuWciFwiO1xuICAgICAgICAgICAgc3dpdGNoIChjYy52di5nYW1lTmV0TWdyLmZlbmd4aWFuZykge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogZmVuZ3F1YW4gPSBcIuS4nOmjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTogZmVuZ3F1YW4gPSBcIuWNl+mjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogZmVuZ3F1YW4gPSBcIuilv+mjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogZmVuZ3F1YW4gPSBcIuWMl+mjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbnVtb2ZnYW1lcy5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGZlbmdxdWFuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+WIpOaWreS4nOWNl+ilv+WMl1xuICAgICAgICAgICAgaWYodXNlckRhdGEuYnV0dG9uKXtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZ2FtZW92ZXIuZ2V0Q2hpbGRCeU5hbWUoXCJyZXN1bHRfbGlzdFwiKS5nZXRDaGlsZEJ5TmFtZShcInNcIisoaSU0KzEpKS5nZXRDaGlsZEJ5TmFtZShcImRpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hGZW5nRmxhZyhkaXJlY3Rpb24sXCJkb25nXCIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLl9nYW1lb3Zlci5nZXRDaGlsZEJ5TmFtZShcInJlc3VsdF9saXN0XCIpLmdldENoaWxkQnlOYW1lKFwic1wiKygoKGkrMSklNCkrMSkpLmdldENoaWxkQnlOYW1lKFwiZGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgIHN3aXRjaEZlbmdGbGFnKGRpcmVjdGlvbixcIm5hblwiKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZ2FtZW92ZXIuZ2V0Q2hpbGRCeU5hbWUoXCJyZXN1bHRfbGlzdFwiKS5nZXRDaGlsZEJ5TmFtZShcInNcIisoKChpKzIpJTQpKzEpKS5nZXRDaGlsZEJ5TmFtZShcImRpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hGZW5nRmxhZyhkaXJlY3Rpb24sXCJ4aVwiKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZ2FtZW92ZXIuZ2V0Q2hpbGRCeU5hbWUoXCJyZXN1bHRfbGlzdFwiKS5nZXRDaGlsZEJ5TmFtZShcInNcIisoKChpKzMpJTQpKzEpKS5nZXRDaGlsZEJ5TmFtZShcImRpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hGZW5nRmxhZyhkaXJlY3Rpb24sXCJiZWlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIG9uR2FtZU92ZXJfVERIOmZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgaWYoZGF0YS5sZW5ndGggPT0gMCl7XG4gICAgICAgICAgICB0aGlzLl9nYW1lcmVzdWx0LmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2FtZW92ZXIuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcGluZ2p1LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl93aW4uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xvc2UuYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIG15c2NvcmUgPSBkYXRhW2NjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4XS5zY29yZTtcbiAgICAgICAgaWYobXlzY29yZSA+IDApe1xuICAgICAgICAgICAgdGhpcy5fd2luLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH0gICAgICAgICBcbiAgICAgICAgZWxzZSBpZihteXNjb3JlIDwgMCl7XG4gICAgICAgICAgICB0aGlzLl9sb3NlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHRoaXMuX3BpbmdqdS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgIC8v5pi+56S6546p5a625L+h5oGvXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCA0OyArK2kpe1xuICAgICAgICAgICAgdmFyIHNlYXRWaWV3ID0gdGhpcy5fc2VhdHNbaV07XG4gICAgICAgICAgICB2YXIgdXNlckRhdGEgPSBkYXRhW2ldO1xuICAgICAgICAgICAgdmFyIGh1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8v6IOh54mM55qE546p5a625omN5pi+56S6IOaYr+WQpua4heS4gOiJsiDmoLl4bueahOWtl+agt1xuICAgICAgICAgICAgdmFyIG51bU9mR2FuZ3MgPSB1c2VyRGF0YS5hbmdhbmdzLmxlbmd0aCArIHVzZXJEYXRhLndhbmdhbmdzLmxlbmd0aCArIHVzZXJEYXRhLmRpYW5nYW5ncy5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgbnVtT2ZHZW4gPSB1c2VyRGF0YS5udW1vZmdlbjtcbiAgICAgICAgICAgIHZhciBhY3Rpb25BcnIgPSBbXTtcbiAgICAgICAgICAgIHZhciBpczdwYWlycyA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGlzY2hhZGFqaWFvID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdXNlckRhdGEuYWN0aW9ucy5sZW5ndGg7ICsrail7XG4gICAgICAgICAgICAgICAgdmFyIGFjID0gdXNlckRhdGEuYWN0aW9uc1tqXTtcbiAgICAgICAgICAgICAgICBpZihhYy50eXBlID09IFwiemltb1wiIHx8IGFjLnR5cGUgPT0gXCJnYW5naHVhXCIgfHwgYWMudHlwZSA9PSBcImRpYW5nYW5naHVhXCIgfHwgYWMudHlwZSA9PSBcImh1XCIgfHwgYWMudHlwZSA9PSBcImdhbmdwYW9odVwiIHx8IGFjLnR5cGUgPT0gXCJxaWFuZ2dhbmdodVwiIHx8IGFjLnR5cGUgPT0gXCJjaGFkYWppYW9cIil7XG4gICAgICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLnBhdHRlcm4gPT0gXCI3cGFpcnNcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuS4g+WvuVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKHVzZXJEYXRhLnBhdHRlcm4gPT0gXCJsN3BhaXJzXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLpvpnkuIPlr7lcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZih1c2VyRGF0YS5wYXR0ZXJuID09IFwiajdwYWlyc1wiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5bCG5LiD5a+5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodXNlckRhdGEucGF0dGVybiA9PSBcImR1aWR1aVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi56Kw56Kw6IOhXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYodXNlckRhdGEucGF0dGVybiA9PSBcImppYW5nZHVpXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLlsIblr7lcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKGFjLnR5cGUgPT0gXCJ6aW1vXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLoh6rmkbhcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiZ2FuZ2h1YVwiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5p2g5LiK6IqxXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImRpYW5nYW5naHVhXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLngrnmnaDoirFcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiZ2FuZ3Bhb2h1XCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmnaDngq7og6FcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwicWlhbmdnYW5naHVcIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaKouadoOiDoVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJjaGFkYWppYW9cIil7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc2NoYWRhamlhbyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaHVlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImZhbmdwYW9cIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5pS+54KuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJhbmdhbmdcIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5pqX5p2gXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJkaWFuZ2FuZ1wiKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmmI7mnaBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcIndhbmdhbmdcIil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5byv5p2gXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmKGFjLnR5cGUgPT0gXCJmYW5nZ2FuZ1wiKXtcbiAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaUvuadoFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihhYy50eXBlID09IFwiemh1YW5zaG91Z2FuZ1wiKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLovazmiYvmnaBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImJlaXFpYW5nZ2FuZ1wiKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLooqvmiqLmnaBcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYoYWMudHlwZSA9PSBcImJlaWNoYWRhamlhb1wiKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLooqvmn6Xlj6tcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihodWVkKXtcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5xaW5neWlzZSl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5riF5LiA6ImyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5tZW5xaW5nKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLpl6jmuIVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLnpob25nemhhbmcpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuS4reW8oFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEuamluZ291aHUpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIumHkemSqeiDoVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLmhhaWRpaHUpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIua1t+W6leiDoVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEudGlhbmh1KXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLlpKnog6FcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLmRpaHUpe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuWcsOiDoVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihudW1PZkdlbiA+IDApe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuaguXhcIiArIG51bU9mR2VuKTsgXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihpc2NoYWRhamlhbyl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5p+l5aSn5Y+rXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5odW55aXNlKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmt7fkuIDoibJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLmR1aWR1aWh1KXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLlr7nlr7nog6FcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLnBhaWh1KXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLmjpLog6FcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHVzZXJEYXRhLmdhbmdzaGFuZ2h1YSl7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi5p2g5LiK6IqxXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5rYW4pe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuWdjuaho1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEuYmlhbil7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkFyci5wdXNoKFwi6L655qGjXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih1c2VyRGF0YS5kYW4pe1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25BcnIucHVzaChcIuWNleWQilwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodXNlckRhdGEuZHVpZGFvKXtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uQXJyLnB1c2goXCLlr7nlgJJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IodmFyIG8gPSAwOyBvIDwgMzsrK28pe1xuICAgICAgICAgICAgICAgIHNlYXRWaWV3Lmh1LmNoaWxkcmVuW29dLmFjdGl2ZSA9IGZhbHNlOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHVzZXJEYXRhLmh1b3JkZXIgPj0gMCl7XG4gICAgICAgICAgICAgICAgc2VhdFZpZXcuaHUuY2hpbGRyZW5bdXNlckRhdGEuaHVvcmRlcl0uYWN0aXZlID0gdHJ1ZTsgICAgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlYXRWaWV3LnVzZXJuYW1lLnN0cmluZyA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHNbaV0ubmFtZTtcbiAgICAgICAgICAgIHNlYXRWaWV3LnpodWFuZy5hY3RpdmUgPSBjYy52di5nYW1lTmV0TWdyLmJ1dHRvbiA9PSBpO1xuICAgICAgICAgICAgc2VhdFZpZXcucmVhc29uLnN0cmluZyA9IGFjdGlvbkFyci5qb2luKFwi44CBXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8v5pi+56S65Lid5pWw5Y+w5pWwXG4gICAgICAgICAgICBzZWF0Vmlldy50YWlzaS5zdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgaWYodXNlckRhdGEuc2NvcmUgPiAwKXtcbiAgICAgICAgICAgICAgICBzZWF0Vmlldy5zY29yZS5zdHJpbmcgPSBcIitcIiArIHVzZXJEYXRhLnNjb3JlOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgc2VhdFZpZXcuc2NvcmUuc3RyaW5nID0gdXNlckRhdGEuc2NvcmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgaHVwYWkgPSAtMTtcbiAgICAgICAgICAgIGlmKGh1ZWQpe1xuICAgICAgICAgICAgICAgIGh1cGFpID0gdXNlckRhdGEuaG9sZHMucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNjLnZ2Lm1haGpvbmdtZ3Iuc29ydE1KKHVzZXJEYXRhLmhvbGRzLHVzZXJEYXRhLmRpbmdxdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+iDoeeJjOS4jeWPguS4juaOkuW6j1xuICAgICAgICAgICAgaWYoaHVlZCl7XG4gICAgICAgICAgICAgICAgdXNlckRhdGEuaG9sZHMucHVzaChodXBhaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8v6ZqQ6JeP5omA5pyJ54mMXG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgc2VhdFZpZXcubWFoam9uZ3MuY2hpbGRyZW5Db3VudDsgKytrKXtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHNlYXRWaWV3Lm1haGpvbmdzLmNoaWxkcmVuW2tdO1xuICAgICAgICAgICAgICAgIG4uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGxhY2tpbmdOdW0gPSAodXNlckRhdGEucGVuZ3MubGVuZ3RoICsgbnVtT2ZHYW5ncyArIHVzZXJEYXRhLmNoaXMubGVuZ3RoKSozOyBcbiAgICAgICAgICAgIC8v5pi+56S655u45YWz55qE54mMXG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgdXNlckRhdGEuaG9sZHMubGVuZ3RoOyArK2spe1xuICAgICAgICAgICAgICAgIHZhciBwYWkgPSB1c2VyRGF0YS5ob2xkc1trXTtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IHNlYXRWaWV3Lm1haGpvbmdzLmNoaWxkcmVuW2sgKyBsYWNraW5nTnVtXTtcbiAgICAgICAgICAgICAgICBuLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG4uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XG4gICAgICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIscGFpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgc2VhdFZpZXcuX3BlbmdhbmRnYW5nLmxlbmd0aDsgKytrKXtcbiAgICAgICAgICAgICAgICBzZWF0Vmlldy5fcGVuZ2FuZGdhbmdba10uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8v5Yid5aeL5YyW5p2g54mMXG4gICAgICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIGdhbmdzID0gdXNlckRhdGEuYW5nYW5ncztcbiAgICAgICAgICAgIGZvcih2YXIgayA9IDA7IGsgPCBnYW5ncy5sZW5ndGg7ICsrayl7XG4gICAgICAgICAgICAgICAgdmFyIG1qaWQgPSBnYW5nc1trXTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRQZW5nQW5kR2FuZ3Moc2VhdFZpZXcsaW5kZXgsbWppZCxcImFuZ2FuZ1wiKTtcbiAgICAgICAgICAgICAgICBpbmRleCsrOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGdhbmdzID0gdXNlckRhdGEuZGlhbmdhbmdzO1xuICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGdhbmdzLmxlbmd0aDsgKytrKXtcbiAgICAgICAgICAgICAgICB2YXIgbWppZCA9IGdhbmdzW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhzZWF0VmlldyxpbmRleCxtamlkLFwiZGlhbmdhbmdcIik7XG4gICAgICAgICAgICAgICAgaW5kZXgrKzsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBnYW5ncyA9IHVzZXJEYXRhLndhbmdhbmdzO1xuICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGdhbmdzLmxlbmd0aDsgKytrKXtcbiAgICAgICAgICAgICAgICB2YXIgbWppZCA9IGdhbmdzW2tdO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhzZWF0VmlldyxpbmRleCxtamlkLFwid2FuZ2FuZ1wiKTtcbiAgICAgICAgICAgICAgICBpbmRleCsrOyAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy/liJ3lp4vljJbnorDniYxcbiAgICAgICAgICAgIHZhciBwZW5ncyA9IHVzZXJEYXRhLnBlbmdzXG4gICAgICAgICAgICBpZihwZW5ncyl7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IHBlbmdzLmxlbmd0aDsgKytrKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1qaWQgPSBwZW5nc1trXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbml0UGVuZ0FuZEdhbmdzKHNlYXRWaWV3LGluZGV4LG1qaWQsXCJwZW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrOyAgICBcbiAgICAgICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+WIneWni+WMluWQg+eJjFxuICAgICAgICAgICAgdmFyIGNoaXMgPSB1c2VyRGF0YS5jaGlzIFxuICAgICAgICAgICAgaWYoY2hpcyl7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGNoaXMubGVuZ3RoOyArK2spe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWppZCA9IGNoaXNba107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhzZWF0VmlldyxpbmRleCxtamlkLFwiY2hpXCIpO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrOyAgICBcbiAgICAgICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+WIneWni+WMluiKseeJjCBUT0RPOuWSjOS4i+mdouS4gOagt+WGmeWIneWni+WMluWHveaVsCDlubbkuJTopoHpppblhYjpmpDol4/miYDmnInnmoToirFcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBodWFzID0gdXNlckRhdGEuaHVhczsgXG4gICAgICAgICAgICB2YXIgaHVhX25vZGUgPSB0aGlzLl9nYW1lb3Zlci5nZXRDaGlsZEJ5TmFtZShcInJlc3VsdF9saXN0XCIpLmdldENoaWxkQnlOYW1lKFwic1wiKyhpKzEpKS5nZXRDaGlsZEJ5TmFtZShcImh1YXNcIik7XG4gICAgICAgICAgICBmb3IodmFyIGsgPSAwOyBrIDwgaHVhX25vZGUuY2hpbGRyZW5Db3VudDsgKytrKXtcbiAgICAgICAgICAgICAgICBodWFfbm9kZS5jaGlsZHJlbltrXS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgaWYoaHVhcyl7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IGh1YXMubGVuZ3RoOyArK2spe1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWppZCA9IGh1YXNba107XG4gICAgICAgICAgICAgICAgICAgIGh1YV9ub2RlLmNoaWxkcmVuW2tdLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcCA9IGh1YV9ub2RlLmNoaWxkcmVuW2tdLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xuICAgICAgICAgICAgICAgICAgICBzcC5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQoXCJNX1wiLG1qaWQpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL+S4nOWNl+ilv+WMl+Wwj+aXl+WtkOi9rOaNolxuICAgICAgICAgICAgdmFyIHN3aXRjaEZlbmdGbGFnID0gZnVuY3Rpb24gKGRpcmVjdGlvbixkaXJfc3RyKXtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGsgPSAwIDsgayA8IDQgOyBrICsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbi5jaGlsZHJlbltrXS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uLmdldENoaWxkQnlOYW1lKGRpcl9zdHIpLmFjdGl2ZT10cnVlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy/mmL7npLrlvZPliY3po47lnIjlkozlsYDmlbBcbiAgICAgICAgICAgIHZhciBudW1vZmdhbWVzID0gdGhpcy5fZ2FtZW92ZXIuZ2V0Q2hpbGRCeU5hbWUoXCJudW1vZmdhbWVzXCIpO1xuICAgICAgICAgICAgdmFyIGZlbmdxdWFuID0gXCLkuJzpo47lnIhcIjtcbiAgICAgICAgICAgIHN3aXRjaCAoY2MudnYuZ2FtZU5ldE1nci5mZW5neGlhbmcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGZlbmdxdWFuID0gXCLkuJzpo47lnIhcIjticmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6IGZlbmdxdWFuID0gXCLljZfpo47lnIhcIjticmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6IGZlbmdxdWFuID0gXCLopb/po47lnIhcIjticmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6IGZlbmdxdWFuID0gXCLljJfpo47lnIhcIjticmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG51bW9mZ2FtZXMuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBmZW5ncXVhbjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy/liKTmlq3kuJzljZfopb/ljJdcbiAgICAgICAgICAgIGlmKHVzZXJEYXRhLmJ1dHRvbil7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2dhbWVvdmVyLmdldENoaWxkQnlOYW1lKFwicmVzdWx0X2xpc3RcIikuZ2V0Q2hpbGRCeU5hbWUoXCJzXCIrKGklNCsxKSkuZ2V0Q2hpbGRCeU5hbWUoXCJkaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgc3dpdGNoRmVuZ0ZsYWcoZGlyZWN0aW9uLFwiZG9uZ1wiKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGhpcy5fZ2FtZW92ZXIuZ2V0Q2hpbGRCeU5hbWUoXCJyZXN1bHRfbGlzdFwiKS5nZXRDaGlsZEJ5TmFtZShcInNcIisoKChpKzEpJTQpKzEpKS5nZXRDaGlsZEJ5TmFtZShcImRpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2hGZW5nRmxhZyhkaXJlY3Rpb24sXCJuYW5cIik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2dhbWVvdmVyLmdldENoaWxkQnlOYW1lKFwicmVzdWx0X2xpc3RcIikuZ2V0Q2hpbGRCeU5hbWUoXCJzXCIrKCgoaSsyKSU0KSsxKSkuZ2V0Q2hpbGRCeU5hbWUoXCJkaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgc3dpdGNoRmVuZ0ZsYWcoZGlyZWN0aW9uLFwieGlcIik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMuX2dhbWVvdmVyLmdldENoaWxkQnlOYW1lKFwicmVzdWx0X2xpc3RcIikuZ2V0Q2hpbGRCeU5hbWUoXCJzXCIrKCgoaSszKSU0KSsxKSkuZ2V0Q2hpbGRCeU5hbWUoXCJkaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgc3dpdGNoRmVuZ0ZsYWcoZGlyZWN0aW9uLFwiYmVpXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBpbml0UGVuZ0FuZEdhbmdzOmZ1bmN0aW9uKHNlYXRWaWV3LGluZGV4LG1qaWQsZmxhZyl7XG4gICAgICAgIHZhciBwZ3Jvb3QgPSBudWxsO1xuICAgICAgICBpZihzZWF0Vmlldy5fcGVuZ2FuZGdhbmcubGVuZ3RoIDw9IGluZGV4KXtcbiAgICAgICAgICAgIHBncm9vdCA9IGNjLmluc3RhbnRpYXRlKGNjLnZ2Lm1haGpvbmdtZ3IucGVuZ1ByZWZhYlNlbGYpO1xuICAgICAgICAgICAgc2VhdFZpZXcuX3BlbmdhbmRnYW5nLnB1c2gocGdyb290KTtcbiAgICAgICAgICAgIHNlYXRWaWV3Lm1haGpvbmdzLmFkZENoaWxkKHBncm9vdCk7ICAgIFxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBwZ3Jvb3QgPSBzZWF0Vmlldy5fcGVuZ2FuZGdhbmdbaW5kZXhdO1xuICAgICAgICAgICAgcGdyb290LmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICB2YXIgc3ByaXRlcyA9IHBncm9vdC5nZXRDb21wb25lbnRzSW5DaGlsZHJlbihjYy5TcHJpdGUpO1xuICAgICAgICBmb3IodmFyIHMgPSAwOyBzIDwgc3ByaXRlcy5sZW5ndGg7ICsrcyl7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gc3ByaXRlc1tzXTtcbiAgICAgICAgICAgIGlmKHNwcml0ZS5ub2RlLm5hbWUgPT0gXCJnYW5nXCIpe1xuICAgICAgICAgICAgICAgIHZhciBpc0dhbmcgPSBmbGFnICE9IFwicGVuZ1wiO1xuICAgICAgICAgICAgICAgIHNwcml0ZS5ub2RlLmFjdGl2ZSA9IGlzR2FuZztcbiAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5zY2FsZVggPSAxLjA7XG4gICAgICAgICAgICAgICAgc3ByaXRlLm5vZGUuc2NhbGVZID0gMS4wO1xuICAgICAgICAgICAgICAgIGlmKGZsYWcgPT0gXCJhbmdhbmdcIil7XG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0RW1wdHlTcHJpdGVGcmFtZShcIm15c2VsZlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlLm5vZGUuc2NhbGVYID0gMS40O1xuICAgICAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5zY2FsZVkgPSAxLjQ7ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQoXCJCX1wiLG1qaWQpOyAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGlmKGZsYWc9PVwicGVuZ1wiKVxuICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQoXCJCX1wiLG1qaWQpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZsYWc9PVwiY2hpXCIpe1xuICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChcIkJfXCIsbWppZFtzXSk7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQoXCJCX1wiLG1qaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwZ3Jvb3QueCA9IGluZGV4ICogNTUgKiAzICsgaW5kZXggKiAxMDtcbiAgICB9LFxuXG4gICAgXG4gICAgb25CdG5SZWFkeUNsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJvbkJ0blJlYWR5Q2xpY2tlZFwiKTtcbiAgICAgICAgaWYodGhpcy5faXNHYW1lRW5kKXtcbiAgICAgICAgICAgIHRoaXMuX2dhbWVyZXN1bHQuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgY2MudnYubmV0LnNlbmQoJ3JlYWR5Jyk7ICAgXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZ2FtZW92ZXIuYWN0aXZlID0gZmFsc2U7XG4gICAgfSxcbiAgICBcbiAgICBvbkJ0blNoYXJlQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICBjb25zb2xlLmxvZyhcIm9uQnRuU2hhcmVDbGlja2VkXCIpO1xuICAgIH1cblxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcblxuICAgIC8vIH0sXG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgICAgICBfZ2FtZXJlc3VsdDpudWxsLFxuICAgICAgICBfc2VhdHM6W10sXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5fZ2FtZXJlc3VsdCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVfcmVzdWx0XCIpO1xuICAgICAgICAvL3RoaXMuX2dhbWVyZXN1bHQuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICB2YXIgc2VhdHMgPSB0aGlzLl9nYW1lcmVzdWx0LmdldENoaWxkQnlOYW1lKFwic2VhdHNcIik7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWF0cy5jaGlsZHJlbi5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB0aGlzLl9zZWF0cy5wdXNoKHNlYXRzLmNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIlNlYXRcIikpOyAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgYnRuQ2xvc2UgPSBjYy5maW5kKFwiQ2FudmFzL2dhbWVfcmVzdWx0L2J0bkNsb3NlXCIpO1xuICAgICAgICBpZihidG5DbG9zZSl7XG4gICAgICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KGJ0bkNsb3NlLHRoaXMubm9kZSxcIkdhbWVSZXN1bHRcIixcIm9uQnRuQ2xvc2VDbGlja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgYnRuU2hhcmUgPSBjYy5maW5kKFwiQ2FudmFzL2dhbWVfcmVzdWx0L2J0blNoYXJlXCIpO1xuICAgICAgICBpZihidG5TaGFyZSl7XG4gICAgICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KGJ0blNoYXJlLHRoaXMubm9kZSxcIkdhbWVSZXN1bHRcIixcIm9uQnRuU2hhcmVDbGlja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL+WIneWni+WMlue9kee7nOS6i+S7tuebkeWQrOWZqFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9lbmQnLGZ1bmN0aW9uKGRhdGEpe3NlbGYub25HYW1lRW5kKGRhdGEuZGV0YWlsKTt9KTtcbiAgICB9LFxuICAgIFxuICAgIHNob3dSZXN1bHQ6ZnVuY3Rpb24oc2VhdCxpbmZvLGlzWnVpSmlhUGFvU2hvdSl7XG4gICAgICAgIHNlYXQubm9kZS5nZXRDaGlsZEJ5TmFtZShcInp1aWppYXBhb3Nob3VcIikuYWN0aXZlID0gaXNadWlKaWFQYW9TaG91O1xuICAgICAgICBcbiAgICAgICAgc2VhdC5ub2RlLmdldENoaWxkQnlOYW1lKFwiemltb2Npc2h1XCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gaW5mby5udW16aW1vO1xuICAgICAgICBzZWF0Lm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJqaWVwYW9jaXNodVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGluZm8ubnVtamllcGFvO1xuICAgICAgICBzZWF0Lm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJkaWFucGFvY2lzaHVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBpbmZvLm51bWRpYW5wYW87XG4gICAgICAgIHNlYXQubm9kZS5nZXRDaGlsZEJ5TmFtZShcImFuZ2FuZ2Npc2h1XCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gaW5mby5udW1hbmdhbmc7XG4gICAgICAgIHNlYXQubm9kZS5nZXRDaGlsZEJ5TmFtZShcIm1pbmdnYW5nY2lzaHVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBpbmZvLm51bW1pbmdnYW5nO1xuICAgICAgICAvL3NlYXQubm9kZS5nZXRDaGlsZEJ5TmFtZShcImNoYWppYW9jaXNodVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGluZm8ubnVtY2hhZGFqaWFvO1xuICAgIH0sXG4gICAgXG4gICAgb25HYW1lRW5kOmZ1bmN0aW9uKGVuZGluZm8pe1xuICAgICAgICB2YXIgc2VhdHMgPSBjYy52di5nYW1lTmV0TWdyLnNlYXRzO1xuICAgICAgICB2YXIgbWF4c2NvcmUgPSAtMTtcbiAgICAgICAgdmFyIG1heGRpYW5wYW8gPSAwO1xuICAgICAgICB2YXIgZGlhbnBhb2dhb3Nob3UgPSAtMTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlYXRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBzZWF0ID0gc2VhdHNbaV07XG4gICAgICAgICAgICBpZihzZWF0LnNjb3JlID4gbWF4c2NvcmUpe1xuICAgICAgICAgICAgICAgIG1heHNjb3JlID0gc2VhdC5zY29yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGVuZGluZm9baV0ubnVtZGlhbnBhbyA+IG1heGRpYW5wYW8pe1xuICAgICAgICAgICAgICAgIG1heGRpYW5wYW8gPSBlbmRpbmZvW2ldLm51bWRpYW5wYW87XG4gICAgICAgICAgICAgICAgZGlhbnBhb2dhb3Nob3UgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VhdHMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIHNlYXQgPSBzZWF0c1tpXTtcbiAgICAgICAgICAgIHZhciBpc0JpZ3dpbiA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoc2VhdC5zY29yZSA+IDApe1xuICAgICAgICAgICAgICAgIGlzQmlnd2luID0gc2VhdC5zY29yZSA9PSBtYXhzY29yZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NlYXRzW2ldLnNldEluZm8oc2VhdC5uYW1lLHNlYXQuc2NvcmUsIGlzQmlnd2luKTtcbiAgICAgICAgICAgIHRoaXMuX3NlYXRzW2ldLnNldElEKHNlYXQudXNlcmlkKTtcbiAgICAgICAgICAgIHZhciBpc1p1aUppYVBhb1Nob3UgPSBkaWFucGFvZ2Fvc2hvdSA9PSBpO1xuICAgICAgICAgICAgdGhpcy5zaG93UmVzdWx0KHRoaXMuX3NlYXRzW2ldLGVuZGluZm9baV0saXNadWlKaWFQYW9TaG91KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgb25CdG5DbG9zZUNsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKFwiaGFsbFwiKTtcbiAgICB9LFxuICAgIFxuICAgIG9uQnRuU2hhcmVDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIGNjLnZ2LmFueXNka01nci5zaGFyZVJlc3VsdCgpO1xuICAgIH1cbn0pO1xuIiwidmFyIEdsb2JhbCA9IGNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG4gICAgc3RhdGljczoge1xuICAgICAgICBpc3N0YXJ0ZWQ6ZmFsc2UsXG4gICAgICAgIG5ldGluaXRlZDpmYWxzZSxcbiAgICAgICAgdXNlcmd1aWQ6MCxcbiAgICAgICAgbmlja25hbWU6XCJcIixcbiAgICAgICAgbW9uZXk6MCxcbiAgICAgICAgbHY6MCxcbiAgICAgICAgcm9vbUlkOjAsXG4gICAgICAgIFxuICAgIH0sXG59KTsiLCIvL2xvY2FsXG5cbi8vIHZhciBVUkwgPSBcImh0dHA6Ly8xOTIuMTY4LjAuMTE1OjkwMDBcIjtcbnZhciBVUkwgPSBcImh0dHA6Ly8xMTYuNjIuMjI3LjkzOjkwMDBcIjtcbi8vREVWIFNFUlZFUlxuLy92YXIgVVJMID0gXCJodHRwOi8vMTM5LjIxOS4yMjQuMTQzOjkwMDBcIjtcbi8vRk9STUFMIFNFUlZFUlxuLy92YXIgVVJMID0gXCJodHRwOi8vMTE5LjIzLjI1MC4xMTU6OTAwMFwiO1xuXG5jYy5WRVJTSU9OID0gMjAxNzA2MDk7XG52YXIgSFRUUCA9IGNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBzdGF0aWNzOntcbiAgICAgICAgc2Vzc2lvbklkIDogMCxcbiAgICAgICAgdXNlcklkIDogMCxcbiAgICAgICAgbWFzdGVyX3VybDpVUkwsXG4gICAgICAgIHVybDpVUkwsXG4gICAgICAgIHNlbmRSZXF1ZXN0IDogZnVuY3Rpb24ocGF0aCxkYXRhLGhhbmRsZXIsZXh0cmFVcmwpe1xuICAgICAgICAgICAgdmFyIHhociA9IGNjLmxvYWRlci5nZXRYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLnRpbWVvdXQgPSA1MDAwO1xuICAgICAgICAgICAgdmFyIHN0ciA9IFwiP1wiO1xuICAgICAgICAgICAgZm9yKHZhciBrIGluIGRhdGEpe1xuICAgICAgICAgICAgICAgIGlmKHN0ciAhPSBcIj9cIil7XG4gICAgICAgICAgICAgICAgICAgIHN0ciArPSBcIiZcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyICs9IGsgKyBcIj1cIiArIGRhdGFba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihleHRyYVVybCA9PSBudWxsKXtcbiAgICAgICAgICAgICAgICBleHRyYVVybCA9IEhUVFAudXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlcXVlc3RVUkwgPSBleHRyYVVybCArIHBhdGggKyBlbmNvZGVVUkkoc3RyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmVxdWVzdFVSTDpcIiArIHJlcXVlc3RVUkwpO1xuICAgICAgICAgICAgeGhyLm9wZW4oXCJHRVRcIixyZXF1ZXN0VVJMLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChjYy5zeXMuaXNOYXRpdmUpe1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQWNjZXB0LUVuY29kaW5nXCIsXCJnemlwLGRlZmxhdGVcIixcInRleHQvaHRtbDtjaGFyc2V0PVVURi04XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coeGhyKTtcbiAgICAgICAgICAgICAgICBpZih4aHIucmVhZHlTdGF0ZSA9PT0gNCAmJiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkpe1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImh0dHAgcmVzKFwiKyB4aHIucmVzcG9uc2VUZXh0Lmxlbmd0aCArIFwiKTpcIiArIHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldCA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihoYW5kbGVyICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKHJldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgLyogY29kZSAqL1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImVycjpcIiArIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9oYW5kbGVyKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjYy52diAmJiBjYy52di53Yyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBjYy52di53Yy5oaWRlKCk7ICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RhdHVzPVwiK3hoci5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgICAgICAgICAvL3NlbGYudXJsID0gXCJodHRwOi8vMTM5LjIxOS4yMjQuMTQzOjkwMDBcIjtcbiAgICAgICAgICAgICAgICAgICAgLy9IVFRQLnVybCA9IFwiaHR0cDovLzEzOS4yMTkuMjI0LjE0Mzo5MDAwXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoY2MudnYgJiYgY2MudnYud2Mpe1xuICAgICAgICAgICAgICAgIC8vY2MudnYud2Muc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgICAgIHJldHVybiB4aHI7XG4gICAgICAgIH0sXG4gICAgfSxcbn0pOyIsInZhciBOZXQgPSByZXF1aXJlKFwiTmV0XCIpXG52YXIgR2xvYmFsID0gcmVxdWlyZShcIkdsb2JhbFwiKVxuY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgbGJsTmFtZTpjYy5MYWJlbCxcbiAgICAgICAgbGJsTW9uZXk6Y2MuTGFiZWwsXG4gICAgICAgIGxibEdlbXM6Y2MuTGFiZWwsXG4gICAgICAgIGxibElEOmNjLkxhYmVsLFxuICAgICAgICBsYmxOb3RpY2U6Y2MuTGFiZWwsXG4gICAgICAgIGpvaW5HYW1lV2luOmNjLk5vZGUsXG4gICAgICAgIGNyZWF0ZVJvb21XaW46Y2MuTm9kZSxcbiAgICAgICAgc2V0dGluZ3NXaW46Y2MuTm9kZSxcbiAgICAgICAgaGVscFdpbjpjYy5Ob2RlLFxuICAgICAgICB4aWFveGlXaW46Y2MuTm9kZSxcbiAgICAgICAgYnRuSm9pbkdhbWU6Y2MuTm9kZSxcbiAgICAgICAgYnRuUmV0dXJuR2FtZTpjYy5Ob2RlLFxuICAgICAgICBzcHJIZWFkSW1nOmNjLlNwcml0ZSxcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgfSxcbiAgICBcbiAgICBpbml0TmV0SGFuZGxlcnM6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIH0sXG4gICAgXG4gICAgb25TaGFyZTpmdW5jdGlvbigpe1xuICAgICAgICBjYy5maW5kKFwiQ2FudmFzL1NoYXJlQm94XCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBjYy52di5hbnlzZGtNZ3Iuc2hhcmUoXCLoiJ/lsbHpurvlsIZcIixcIuiIn+Wxsem6u+Wwhu+8jOWMheWQq+S6huayiOWutumXqOm6u+WwhuOAgeWumua1t+m6u+WwhuOAgeaOqOWIsOiDoeetieWkmuenjeiIn+Wxsea1geihjOm6u+WwhueOqeazleOAglwiKTsgXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgdXNlcmlkOmNjLnZ2LnVzZXJNZ3IudXNlcklkLFxuICAgICAgICAgICAgdHlwZTpcInNoYXJlXCJcbiAgICAgICAgfTtcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9zaGFyZV9nZXRfZ2Vtc1wiLGRhdGEsZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2hhcmVfZ2V0X2dlbXNcIik7XG4gICAgICAgICAgICBpZihyZXMuZXJyY29kZS5kYXRhLmdlbXM+MCl7XG4gICAgICAgICAgICAgICAgY2MudnYuYWxlcnQuc2hvdyhcIuaPkOekulwiLFwi5b6u5L+h5YiG5Lqr5oiQ5Yqf77yM6I635b6XXCIrcmVzLmVycmNvZGUuZGF0YS5nZW1zK1wi6ZK7XCIpO1xuICAgICAgICAgICAgICAgIGNjLnZ2LnVzZXJNZ3IuZ2VtcyArPSByZXMuZXJyY29kZS5kYXRhLmdlbXM7XG4gICAgICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy90b3BfbGVmdC9oZWFkaW5mby9sYmxHZW1zXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gY2MudnYudXNlck1nci5nZW1zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9TaGFyZUJveFwiKS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlcyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgXG4gICAgb25UaW1lbGluZTpmdW5jdGlvbigpe1xuICAgICAgICBjYy5maW5kKFwiQ2FudmFzL1NoYXJlQm94XCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBjYy52di5hbnlzZGtNZ3Iuc2hhcmVPblRpbWVsaW5lKFwi6Iif5bGx6bq75bCGXCIsXCLoiJ/lsbHpurvlsIbvvIzljIXlkKvkuobmsojlrrbpl6jpurvlsIbjgIHlrprmtbfpurvlsIbjgIHmjqjliLDog6HnrYnlpJrnp43oiJ/lsbHmtYHooYzpurvlsIbnjqnms5XjgIJcIik7ICBcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICB1c2VyaWQ6Y2MudnYudXNlck1nci51c2VySWQsXG4gICAgICAgICAgICB0eXBlOlwidGltZWxpbmVcIlxuICAgICAgICB9O1xuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL3NoYXJlX2dldF9nZW1zXCIsZGF0YSxmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJzaGFyZV9nZXRfZ2Vtc1wiKTtcbiAgICAgICAgICAgIGlmKHJlcy5lcnJjb2RlLmRhdGEuZ2Vtcz4wKXtcbiAgICAgICAgICAgICAgICBjYy52di5hbGVydC5zaG93KFwi5o+Q56S6XCIsXCLlvq7kv6HliIbkuqvliLDmnIvlj4vlnIjmiJDlip/vvIzojrflvpdcIityZXMuZXJyY29kZS5kYXRhLmdlbXMrXCLpkrtcIik7XG4gICAgICAgICAgICAgICAgY2MudnYudXNlck1nci5nZW1zICs9IHJlcy5lcnJjb2RlLmRhdGEuZ2VtcztcbiAgICAgICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL3RvcF9sZWZ0L2hlYWRpbmZvL2xibEdlbXNcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBjYy52di51c2VyTWdyLmdlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL1NoYXJlQm94XCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighY2Muc3lzLmlzTmF0aXZlICYmIGNjLnN5cy5pc01vYmlsZSl7XG4gICAgICAgICAgICB2YXIgY3ZzID0gdGhpcy5ub2RlLmdldENvbXBvbmVudChjYy5DYW52YXMpO1xuICAgICAgICAgICAgY3ZzLmZpdEhlaWdodCA9IHRydWU7XG4gICAgICAgICAgICBjdnMuZml0V2lkdGggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmKCFjYy52dil7XG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJsb2FkaW5nXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdExhYmVscygpO1xuICAgICAgICBcbiAgICAgICAgaWYoY2MudnYuZ2FtZU5ldE1nci5yb29tSWQgPT0gbnVsbCl7XG4gICAgICAgICAgICB0aGlzLmJ0bkpvaW5HYW1lLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmJ0blJldHVybkdhbWUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHRoaXMuYnRuSm9pbkdhbWUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmJ0blJldHVybkdhbWUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy92YXIgcGFyYW1zID0gY2MudnYuYXJncztcbiAgICAgICAgdmFyIHJvb21JZCA9IGNjLnZ2LnVzZXJNZ3Iub2xkUm9vbUlkIFxuICAgICAgICBpZiggcm9vbUlkICE9IG51bGwpe1xuICAgICAgICAgICAgY2MudnYudXNlck1nci5vbGRSb29tSWQgPSBudWxsO1xuICAgICAgICAgICAgY2MudnYudXNlck1nci5lbnRlclJvb20ocm9vbUlkKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGltZ0xvYWRlciA9IHRoaXMuc3BySGVhZEltZy5ub2RlLmdldENvbXBvbmVudChcIkltYWdlTG9hZGVyXCIpO1xuICAgICAgICBpbWdMb2FkZXIuc2V0VXNlcklEKGNjLnZ2LnVzZXJNZ3IudXNlcklkKTtcbiAgICAgICAgY2MudnYudXRpbHMuYWRkQ2xpY2tFdmVudCh0aGlzLnNwckhlYWRJbWcubm9kZSx0aGlzLm5vZGUsXCJIYWxsXCIsXCJvbkJ0bkNsaWNrZWRcIik7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoXCJVc2VySW5mb1Nob3dcIik7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmluaXRCdXR0b25IYW5kbGVyKFwiQ2FudmFzL3JpZ2h0X2JvdHRvbS9idG5fc2hlemhpXCIpO1xuICAgICAgICB0aGlzLmluaXRCdXR0b25IYW5kbGVyKFwiQ2FudmFzL3JpZ2h0X2JvdHRvbS9idG5faGVscFwiKTtcbiAgICAgICAgdGhpcy5pbml0QnV0dG9uSGFuZGxlcihcIkNhbnZhcy9yaWdodF9ib3R0b20vYnRuX3hpYW94aVwiKTtcbiAgICAgICAgdGhpcy5oZWxwV2luLmFkZENvbXBvbmVudChcIk9uQmFja1wiKTtcbiAgICAgICAgdGhpcy54aWFveGlXaW4uYWRkQ29tcG9uZW50KFwiT25CYWNrXCIpO1xuICAgICAgICBcbiAgICAgICAgaWYoIWNjLnZ2LnVzZXJNZ3Iubm90aWNlKXtcbiAgICAgICAgICAgIGNjLnZ2LnVzZXJNZ3Iubm90aWNlID0ge1xuICAgICAgICAgICAgICAgIHZlcnNpb246bnVsbCxcbiAgICAgICAgICAgICAgICBtc2c6XCLmlbDmja7or7fmsYLkuK0uLi5cIixcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIWNjLnZ2LnVzZXJNZ3IuZ2Vtc3RpcCl7XG4gICAgICAgICAgICBjYy52di51c2VyTWdyLmdlbXN0aXAgPSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbjpudWxsLFxuICAgICAgICAgICAgICAgIG1zZzpcIuaVsOaNruivt+axguS4rS4uLlwiLFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmxibE5vdGljZS5zdHJpbmcgPSBjYy52di51c2VyTWdyLm5vdGljZS5tc2c7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnJlZnJlc2hJbmZvKCk7XG4gICAgICAgIHRoaXMucmVmcmVzaE5vdGljZSgpO1xuICAgICAgICB0aGlzLnJlZnJlc2hHZW1zVGlwKCk7XG4gICAgICAgIFxuICAgICAgICBjYy52di5hdWRpb01nci5wbGF5QkdNKFwiYmdNYWluLm1wM1wiKTtcbiAgICAgICAgXG4gICAgICAgIC8v5Yid5aeL5YyW562+5Yiw5L+h5oGvXG4gICAgICAgIHRoaXMuaW5pdENoZWNraW4oKTtcbiAgICAgICAgXG4gICAgICAgIC8v6aKE5Yqg6L296bq75bCG5ri45oiP55WM6Z2iXG4gICAgICAgIGNjLmRpcmVjdG9yLnByZWxvYWRTY2VuZSgnbWpnYW1lJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2MubG9nKCdwcmVsb2FkIG1qZ2FtZSBjb21wbGV0ZSEhIScpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHZhciB5b3VrZW9yd2VpeGluID0gY2Muc3lzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwieW91a2VvcndlaXhpblwiKTtcbiAgICAgICAgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1MgJiYgeW91a2VvcndlaXhpbiA9PSBcIjBcIil7XG4gICAgICAgICAgICAvL+makOiXj+aYvuekuuS4i+i+ueaMiemSrlxuICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9oYWxsQmcvZnVqaWFubWFqaWFuZ1wiKS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNjLmZpbmQoXCJDYW52YXMvaGFsbEJnL2FuaHVpbWFqaWFuZ1wiKS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNjLmZpbmQoXCJDYW52YXMvaGFsbEJnL3FpcWlidXl1XCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9oYWxsQmcvcWlxaXB1a2VcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL2hhbGxCZy9tb3JlXCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9oYWxsQmcveGl4aWEwMDFcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBjYy5maW5kKFwiQ2FudmFzL3RvcF9sZWZ0L2hlYWRpbmZvL2JnXCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gY2MuZmluZChcIkNhbnZhcy90b3BfbGVmdC9oZWFkaW5mby9nZW1zXCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gY2MuZmluZChcIkNhbnZhcy90b3BfbGVmdC9oZWFkaW5mby9idG5fYWRkX2dlbXNcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBjYy5maW5kKFwiQ2FudmFzL3RvcF9sZWZ0L2hlYWRpbmZvL2xibEdlbXNcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL3JpZ2h0X2JvdHRvbS9idG5femhhbmppXCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9yaWdodF9ib3R0b20vYnRuX3NoYXJlXCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9yaWdodF9ib3R0b20vYnRuX2NoZWNraW5cIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBjYy5maW5kKFwiQ2FudmFzL0NyZWF0ZVJvb20vc2ptbWovY29zdFwiKS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIGNjLmZpbmQoXCJDYW52YXMvQ3JlYXRlUm9vbS9kaG1qL2Nvc3RcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBjYy5maW5kKFwiQ2FudmFzL0NyZWF0ZVJvb20vdGRoL2Nvc3RcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL0NyZWF0ZVJvb20vYmcvTmV3IExhYmVsXCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgY2MudnYudXRpbHMuc2hvd0FjdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjYy52di51dGlscy5zaG93QWN0KSB7XG4gICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL0FjdGl2aXR5XCIpLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICAvL+WIneWni+WMluetvuWIsOS/oeaBr1xuICAgIGluaXRDaGVja2luOmZ1bmN0aW9uKCl7XG4gICAgICAgIC8v6I635Y+W562+5Yiw5L+h5oGvXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgdXNlcmlkOmNjLnZ2LnVzZXJNZ3IudXNlcklkXG4gICAgICAgIH07XG4gICAgICAgIGNjLnZ2Lmh0dHAuc2VuZFJlcXVlc3QoXCIvZ2V0X2NoZWNraW5fc3RhdHVzXCIsZGF0YSxmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJnZXRfY2hlY2tpbl9zdGF0dXNcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhyZXMpO1xuICAgICAgICAgICAgLy/lvZPliY3lt7Lnrb7liLDmrKHmlbBcbiAgICAgICAgICAgIHZhciBjaGVja2luX2RheXMgPSByZXMuZXJyY29kZS5kYXRhLmNoZWNraW5fZGF5cztcbiAgICAgICAgICAgIC8v5LiK5qyh562+5Yiw5pe26Ze0XG4gICAgICAgICAgICB2YXIgY2hlY2tpbl9kYXRlID0gcmVzLmVycmNvZGUuZGF0YS5jaGVja2luX2RhdGE7XG4gICAgICAgICAgICAvL+W9k+WJjeaXpeacn1xuICAgICAgICAgICAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdmFyIHkgPSBkLmdldEZ1bGxZZWFyKCk7XG4gICAgICAgICAgICB2YXIgbSA9IGQuZ2V0TW9udGgoKSsxO1xuICAgICAgICAgICAgbSA9IG0gPCAxMCA/IChcIjBcIiArIG0pIDogbTtcbiAgICAgICAgICAgIHZhciBkYXkgPSBkLmdldERhdGUoKTtcbiAgICAgICAgICAgIGRheSA9IGRheSA8IDEwID8gKFwiMFwiICsgZGF5KSA6IGRheTtcbiAgICAgICAgICAgIHZhciBub3dkYXRlID0geStcIi1cIittK1wiLVwiK2RheTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy/ojrflj5Y35aSp55qE562+5Yiw5Zu+54mHXG4gICAgICAgICAgICB2YXIgZGF5cyA9IGNjLmZpbmQoXCJDYW52YXMvQ2hlY2tpbkJveC9iZ1wiKS5jaGlsZHJlbjtcbiAgICAgICAgICAgIHZhciBjaGVja2luX2RheXMgPSBjaGVja2luX2RheXMgJSA3O1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgY2hlY2tpbl9kYXlzIDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF5c1tpXS5nZXRDaGlsZEJ5TmFtZShcImhhc2NoZWNraW5cIikuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkYXlzW2ldLmdldENvbXBvbmVudChjYy5CdXR0b24pLmludGVyYWN0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRheXNbaV0uY29sb3IgPSAgbmV3IGNjLkNvbG9yKDE2OCwgMTY4LCAxNjgpO1xuICAgICAgICAgICAgICAgIGRheXNbaV0ub3BhY2l0eSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBjaGVja2luX2RheXMgOyBpIDwgNyA7IGkrKykge1xuICAgICAgICAgICAgICAgIGRheXNbaV0uZ2V0Q2hpbGRCeU5hbWUoXCJoYXNjaGVja2luXCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGRheXNbaV0uZ2V0Q29tcG9uZW50KGNjLkJ1dHRvbikuaW50ZXJhY3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZGF5c1tpXS5jb2xvciA9IG5ldyBjYy5Db2xvcigyNTUsIDI1NSwgMjU1KTtcbiAgICAgICAgICAgICAgICBkYXlzW2ldLm9wYWNpdHkgPSAxNjA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihjaGVja2luX2RhdGUgIT0gbm93ZGF0ZSl7XG4gICAgICAgICAgICAgICAgZGF5c1tjaGVja2luX2RheXNdLm9wYWNpdHkgPSAyNTU7XG4gICAgICAgICAgICAgICAgZGF5c1tjaGVja2luX2RheXNdLmdldENvbXBvbmVudChjYy5CdXR0b24pLmludGVyYWN0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIG9wZW5TaGFyZUJveDpmdW5jdGlvbigpe1xuICAgICAgICBjYy5maW5kKFwiQ2FudmFzL1NoYXJlQm94XCIpLmFjdGl2ZSA9IHRydWU7XG4gICAgfSxcbiAgICBcbiAgICBjbG9zZVNoYXJlQm94OmZ1bmN0aW9uKCl7XG4gICAgICAgIGNjLmZpbmQoXCJDYW52YXMvU2hhcmVCb3hcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgfSxcbiAgICBcbiAgICBjbG9zZUFjdGl2aXR5OmZ1bmN0aW9uKCl7XG4gICAgICAgIGNjLmZpbmQoXCJDYW52YXMvQWN0aXZpdHlcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGNjLnZ2LnV0aWxzLnNob3dBY3QgPSBmYWxzZTtcbiAgICB9LFxuICAgIFxuICAgIG9uRGF5c0NsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJvbkRheXNDbGlja2VkXCIpO1xuICAgICAgICAvL+makOiXj+etvuWIsOmdouadv1xuICAgICAgICBjYy5maW5kKFwiQ2FudmFzL0NoZWNraW5Cb3hcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8v5Y+R6YCB6K+35rGCXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgdXNlcmlkOmNjLnZ2LnVzZXJNZ3IudXNlcklkXG4gICAgICAgIH07XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9jaGVja2luXCIsZGF0YSxmdW5jdGlvbihyZXMpe1xuICAgICAgICAgICAgdmFyIGFkZGdlbXMgPSByZXMuZXJyY29kZS5kYXRhLmdlbXM7XG4gICAgICAgICAgICBzZWxmLmluaXRDaGVja2luKCk7XG4gICAgICAgICAgICBjYy52di5hbGVydC5zaG93KFwi5o+Q56S6XCIsXCLnrb7liLDmiJDlip/vvIzojrflvpdcIithZGRnZW1zK1wi6ZK7XCIpO1xuICAgICAgICAgICAgY2MudnYudXNlck1nci5nZW1zICs9IGFkZGdlbXM7XG4gICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL3RvcF9sZWZ0L2hlYWRpbmZvL2xibEdlbXNcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBjYy52di51c2VyTWdyLmdlbXM7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICB9LFxuICAgIFxuICAgIHJlZnJlc2hJbmZvOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9uR2V0ID0gZnVuY3Rpb24ocmV0KXtcbiAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlICE9PSAwKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXQuZXJybXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgaWYocmV0LmdlbXMgIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGJsR2Vtcy5zdHJpbmcgPSByZXQuZ2VtczsgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBhY2NvdW50OmNjLnZ2LnVzZXJNZ3IuYWNjb3VudCxcbiAgICAgICAgICAgIHNpZ246Y2MudnYudXNlck1nci5zaWduLFxuICAgICAgICB9O1xuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL2dldF91c2VyX3N0YXR1c1wiLGRhdGEsb25HZXQuYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBcbiAgICByZWZyZXNoR2Vtc1RpcDpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBvbkdldCA9IGZ1bmN0aW9uKHJldCl7XG4gICAgICAgICAgICBpZihyZXQuZXJyY29kZSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmV0LmVycm1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGNjLnZ2LnVzZXJNZ3IuZ2Vtc3RpcC52ZXJzaW9uID0gcmV0LnZlcnNpb247XG4gICAgICAgICAgICAgICAgY2MudnYudXNlck1nci5nZW1zdGlwLm1zZyA9IHJldC5tc2cucmVwbGFjZShcIjxuZXdsaW5lPlwiLFwiXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBhY2NvdW50OmNjLnZ2LnVzZXJNZ3IuYWNjb3VudCxcbiAgICAgICAgICAgIHNpZ246Y2MudnYudXNlck1nci5zaWduLFxuICAgICAgICAgICAgdHlwZTpcImZrZ21cIixcbiAgICAgICAgICAgIHZlcnNpb246Y2MudnYudXNlck1nci5nZW1zdGlwLnZlcnNpb25cbiAgICAgICAgfTtcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9nZXRfbWVzc2FnZVwiLGRhdGEsb25HZXQuYmluZCh0aGlzKSk7XG4gICAgfSxcbiAgICBcbiAgICByZWZyZXNoTm90aWNlOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9uR2V0ID0gZnVuY3Rpb24ocmV0KXtcbiAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlICE9PSAwKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXQuZXJybXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgY2MudnYudXNlck1nci5ub3RpY2UudmVyc2lvbiA9IHJldC52ZXJzaW9uO1xuICAgICAgICAgICAgICAgIGNjLnZ2LnVzZXJNZ3Iubm90aWNlLm1zZyA9IHJldC5tc2c7XG4gICAgICAgICAgICAgICAgdGhpcy5sYmxOb3RpY2Uuc3RyaW5nID0gcmV0Lm1zZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgYWNjb3VudDpjYy52di51c2VyTWdyLmFjY291bnQsXG4gICAgICAgICAgICBzaWduOmNjLnZ2LnVzZXJNZ3Iuc2lnbixcbiAgICAgICAgICAgIHR5cGU6XCJub3RpY2VcIixcbiAgICAgICAgICAgIHZlcnNpb246Y2MudnYudXNlck1nci5ub3RpY2UudmVyc2lvblxuICAgICAgICB9O1xuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL2dldF9tZXNzYWdlXCIsZGF0YSxvbkdldC5iaW5kKHRoaXMpKTtcbiAgICB9LFxuICAgIFxuICAgIGluaXRCdXR0b25IYW5kbGVyOmZ1bmN0aW9uKGJ0blBhdGgpe1xuICAgICAgICB2YXIgYnRuID0gY2MuZmluZChidG5QYXRoKTtcbiAgICAgICAgY2MudnYudXRpbHMuYWRkQ2xpY2tFdmVudChidG4sdGhpcy5ub2RlLFwiSGFsbFwiLFwib25CdG5DbGlja2VkXCIpOyAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBcbiAgICBcbiAgICBpbml0TGFiZWxzOmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMubGJsTmFtZS5zdHJpbmcgPSBjYy52di51c2VyTWdyLnVzZXJOYW1lO1xuICAgICAgICB0aGlzLmxibE1vbmV5LnN0cmluZyA9IGNjLnZ2LnVzZXJNZ3IuY29pbnM7XG4gICAgICAgIHRoaXMubGJsR2Vtcy5zdHJpbmcgPSBjYy52di51c2VyTWdyLmdlbXM7XG4gICAgICAgIHRoaXMubGJsSUQuc3RyaW5nID0gXCJJRDpcIiArIGNjLnZ2LnVzZXJNZ3IudXNlcklkO1xuICAgIH0sXG4gICAgXG4gICAgb25CdG5DbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJidG5fc2hlemhpXCIpe1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc1dpbi5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9ICAgXG4gICAgICAgIGVsc2UgaWYoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJidG5faGVscFwiKXtcbiAgICAgICAgICAgIHRoaXMuaGVscFdpbi5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJidG5feGlhb3hpXCIpe1xuICAgICAgICAgICAgdGhpcy54aWFveGlXaW4uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiaGVhZFwiKXtcbiAgICAgICAgICAgIGNjLnZ2LnVzZXJpbmZvU2hvdy5zaG93KGNjLnZ2LnVzZXJNZ3IudXNlck5hbWUsY2MudnYudXNlck1nci51c2VySWQsdGhpcy5zcHJIZWFkSW1nLGNjLnZ2LnVzZXJNZ3Iuc2V4LGNjLnZ2LnVzZXJNZ3IuaXApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBvbkpvaW5HYW1lQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmpvaW5HYW1lV2luLmFjdGl2ZSA9IHRydWU7XG4gICAgfSxcbiAgICBcbiAgICBvblJldHVybkdhbWVDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBsb2FkZ2FtZSA9IGZ1bmN0aW9uICgpe1xuICAgICAgICAgICAgY2MuZGlyZWN0b3IubG9hZFNjZW5lKFwibWpnYW1lXCIpOyAgXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZhZGVvdXQgPSBjYy5mYWRlT3V0KDAuMSk7XG4gICAgICAgIHZhciBmaW5pc2ggPSBjYy5jYWxsRnVuYyhsb2FkZ2FtZSwgdGhpcyk7XG4gICAgICAgIHZhciBzZXEgPSBjYy5zZXF1ZW5jZShmYWRlb3V0LCBmaW5pc2gpO1xuICAgICAgICB0aGlzLm5vZGUucnVuQWN0aW9uKHNlcSk7XG4gICAgfSxcbiAgICBcbiAgICBvbkJ0bkFkZEdlbXNDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIGNjLnZ2LmFsZXJ0LnNob3coXCLmj5DnpLpcIixjYy52di51c2VyTWdyLmdlbXN0aXAubXNnKTtcbiAgICAgICAgLy8gdGhpcy5yZWZyZXNoSW5mbygpO1xuICAgICAgICAgY2MubG9nKFwiYXBwbGUg5YaF6LStXCIpO1xuICAgICAgXG4gICAgICAgIGlmIChjYy5zeXMuaXNOYXRpdmUmJmNjLnN5cy5vcz09Y2Muc3lzLk9TX0lPUykge1xuICAgICAgICBsZXQgcmV0ID0ganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChcIkFkTWFzdGVyXCIsXCJzaG93QWQ6dGl0bGU6XCIsXCJhcHBsZVwiLFwi5YaF6LStXCIpO1xuICAgICAgICB9XG4gXG4gICAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgb25DcmVhdGVSb29tQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLnJvb21JZCAhPSBudWxsKXtcbiAgICAgICAgICAgIGNjLnZ2LmFsZXJ0LnNob3coXCLmj5DnpLpcIixcIuaIv+mXtOW3sue7j+WIm+W7uiFcXG7lv4Xpobvop6PmlaPlvZPliY3miL/pl7TmiY3og73liJvlu7rmlrDnmoTmiL/pl7RcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJvbkNyZWF0ZVJvb21DbGlja2VkXCIpO1xuICAgICAgICB0aGlzLmNyZWF0ZVJvb21XaW4uYWN0aXZlID0gdHJ1ZTsgICBcbiAgICB9LFxuICAgIFxuICAgIG9uQ2hlY2tpbkNsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgY2MuZmluZChcIkNhbnZhcy9DaGVja2luQm94XCIpLmFjdGl2ZSA9IHRydWU7XG4gICAgfSxcbiAgICBvbkNoZWNraW5DbG9zZTpmdW5jdGlvbigpe1xuICAgICAgICBjYy5maW5kKFwiQ2FudmFzL0NoZWNraW5Cb3hcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgfSxcblxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmxibE5vdGljZS5ub2RlLng7XG4gICAgICAgIHggLT0gZHQqMTAwO1xuICAgICAgICBpZih4ICsgdGhpcy5sYmxOb3RpY2Uubm9kZS53aWR0aCA8IC0xMDAwKXtcbiAgICAgICAgICAgIHggPSA1MDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYmxOb3RpY2Uubm9kZS54ID0geDtcbiAgICAgICAgXG4gICAgICAgIGlmKGNjLnZ2ICYmIGNjLnZ2LnVzZXJNZ3Iucm9vbURhdGEgIT0gbnVsbCl7XG4gICAgICAgICAgICBjYy52di51c2VyTWdyLmVudGVyUm9vbShjYy52di51c2VyTWdyLnJvb21EYXRhKTtcbiAgICAgICAgICAgIGNjLnZ2LnVzZXJNZ3Iucm9vbURhdGEgPSBudWxsO1xuICAgICAgICB9XG4gICAgfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgSGlzdG9yeUl0ZW1QcmVmYWI6e1xuICAgICAgICAgICAgZGVmYXVsdDpudWxsLFxuICAgICAgICAgICAgdHlwZTpjYy5QcmVmYWIsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgICAgICBfaGlzdG9yeTpudWxsLFxuICAgICAgICBfdmlld2xpc3Q6bnVsbCxcbiAgICAgICAgX2NvbnRlbnQ6bnVsbCxcbiAgICAgICAgX3ZpZXdpdGVtVGVtcDpudWxsLFxuICAgICAgICBfaGlzdG9yeURhdGE6bnVsbCxcbiAgICAgICAgX2N1clJvb21JbmZvOm51bGwsXG4gICAgICAgIF9lbXB0eVRpcDpudWxsLFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5faGlzdG9yeSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImhpc3RvcnlcIik7XG4gICAgICAgIHRoaXMuX2hpc3RvcnkuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9lbXB0eVRpcCA9IHRoaXMuX2hpc3RvcnkuZ2V0Q2hpbGRCeU5hbWUoXCJlbXB0eVRpcFwiKTtcbiAgICAgICAgdGhpcy5fZW1wdHlUaXAuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3ZpZXdsaXN0ID0gdGhpcy5faGlzdG9yeS5nZXRDaGlsZEJ5TmFtZShcInZpZXdsaXN0XCIpO1xuICAgICAgICB0aGlzLl9jb250ZW50ID0gY2MuZmluZChcInZpZXcvY29udGVudFwiLHRoaXMuX3ZpZXdsaXN0KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3ZpZXdpdGVtVGVtcCA9IHRoaXMuX2NvbnRlbnQuY2hpbGRyZW5bMF07XG4gICAgICAgIHRoaXMuX2NvbnRlbnQucmVtb3ZlQ2hpbGQodGhpcy5fdmlld2l0ZW1UZW1wKTtcblxuICAgICAgICB2YXIgbm9kZSA9IGNjLmZpbmQoXCJDYW52YXMvcmlnaHRfYm90dG9tL2J0bl96aGFuamlcIik7ICAgICAgICBcbiAgICAgICAgdGhpcy5hZGRDbGlja0V2ZW50KG5vZGUsdGhpcy5ub2RlLFwiSGlzdG9yeVwiLFwib25CdG5IaXN0b3J5Q2xpY2tlZFwiKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBub2RlID0gY2MuZmluZChcIkNhbnZhcy9oaXN0b3J5L2J0bl9iYWNrXCIpOyAgXG4gICAgICAgIHRoaXMuYWRkQ2xpY2tFdmVudChub2RlLHRoaXMubm9kZSxcIkhpc3RvcnlcIixcIm9uQnRuQmFja0NsaWNrZWRcIik7XG4gICAgfSxcbiAgICBcbiAgICBhZGRDbGlja0V2ZW50OmZ1bmN0aW9uKG5vZGUsdGFyZ2V0LGNvbXBvbmVudCxoYW5kbGVyKXtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IG5ldyBjYy5Db21wb25lbnQuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgIGV2ZW50SGFuZGxlci50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGV2ZW50SGFuZGxlci5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIGV2ZW50SGFuZGxlci5oYW5kbGVyID0gaGFuZGxlcjtcblxuICAgICAgICB2YXIgY2xpY2tFdmVudHMgPSBub2RlLmdldENvbXBvbmVudChjYy5CdXR0b24pLmNsaWNrRXZlbnRzO1xuICAgICAgICBjbGlja0V2ZW50cy5wdXNoKGV2ZW50SGFuZGxlcik7XG4gICAgfSxcbiAgICBcbiAgICBvbkJ0bkJhY2tDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKHRoaXMuX2N1clJvb21JbmZvID09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5faGlzdG9yeURhdGEgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGlzdG9yeS5hY3RpdmUgPSBmYWxzZTsgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgdGhpcy5pbml0Um9vbUhpc3RvcnlMaXN0KHRoaXMuX2hpc3RvcnlEYXRhKTsgICBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgb25CdG5IaXN0b3J5Q2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLl9oaXN0b3J5LmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgY2MudnYudXNlck1nci5nZXRIaXN0b3J5TGlzdChmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGRhdGEuc29ydChmdW5jdGlvbihhLGIpe1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnRpbWUgPCBiLnRpbWU7IFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxmLl9oaXN0b3J5RGF0YSA9IGRhdGE7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7ICsrail7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gZGF0YVtpXS5zZWF0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgcy5uYW1lID0gbmV3IEJ1ZmZlcihzLm5hbWUsJ2Jhc2U2NCcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5pbml0Um9vbUhpc3RvcnlMaXN0KGRhdGEpO1xuICAgICAgICAgICAgXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgXG4gICAgZGF0ZUZvcm1hdDpmdW5jdGlvbih0aW1lKXtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSh0aW1lKTtcbiAgICAgICAgdmFyIGRhdGV0aW1lID0gXCJ7MH0tezF9LXsyfSB7M306ezR9Ons1fVwiO1xuICAgICAgICB2YXIgeWVhciA9IGRhdGUuZ2V0RnVsbFllYXIoKTtcbiAgICAgICAgdmFyIG1vbnRoID0gZGF0ZS5nZXRNb250aCgpICsgMTtcbiAgICAgICAgbW9udGggPSBtb250aCA+PSAxMD8gbW9udGggOiAoXCIwXCIrbW9udGgpO1xuICAgICAgICB2YXIgZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgICAgIGRheSA9IGRheSA+PSAxMD8gZGF5IDogKFwiMFwiK2RheSk7XG4gICAgICAgIHZhciBoID0gZGF0ZS5nZXRIb3VycygpO1xuICAgICAgICBoID0gaCA+PSAxMD8gaCA6IChcIjBcIitoKTtcbiAgICAgICAgdmFyIG0gPSBkYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgbSA9IG0gPj0gMTA/IG0gOiAoXCIwXCIrbSk7XG4gICAgICAgIHZhciBzID0gZGF0ZS5nZXRTZWNvbmRzKCk7XG4gICAgICAgIHMgPSBzID49IDEwPyBzIDogKFwiMFwiK3MpO1xuICAgICAgICBkYXRldGltZSA9IGRhdGV0aW1lLmZvcm1hdCh5ZWFyLG1vbnRoLGRheSxoLG0scyk7XG4gICAgICAgIHJldHVybiBkYXRldGltZTtcbiAgICB9LFxuICAgIFxuICAgIGluaXRSb29tSGlzdG9yeUxpc3Q6ZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiaW5pdFJvb21IaXN0b3J5TGlzdFwiKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmdldFZpZXdJdGVtKGkpO1xuICAgICAgICAgICAgbm9kZS5pZHggPSBpO1xuICAgICAgICAgICAgdmFyIHRpdGxlSWQgPSBcIlwiICsgKGkgKyAxKTtcbiAgICAgICAgICAgIG5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJ0aXRsZVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IHRpdGxlSWQ7XG4gICAgICAgICAgICBub2RlLmdldENoaWxkQnlOYW1lKFwicm9vbU5vXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCLmiL/pl7RJRDpcIiArIGRhdGFbaV0uaWQ7XG4gICAgICAgICAgICB2YXIgZGF0ZXRpbWUgPSB0aGlzLmRhdGVGb3JtYXQoZGF0YVtpXS50aW1lICogMTAwMCk7XG4gICAgICAgICAgICBub2RlLmdldENoaWxkQnlOYW1lKFwidGltZVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGRhdGV0aW1lO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygxKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGJ0bk9wID0gbm9kZS5nZXRDaGlsZEJ5TmFtZShcImJ0bk9wXCIpO1xuICAgICAgICAgICAgYnRuT3AuaWR4ID0gaTtcbiAgICAgICAgICAgIC8vYnRuT3AuZ2V0Q2hpbGRCeU5hbWUoXCJMYWJlbFwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwi6K+m5oOFXCI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKDIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgNDsgKytqKXtcbiAgICAgICAgICAgICAgICB2YXIgcyA9IGRhdGFbaV0uc2VhdHNbal07XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBzLm5hbWUgKyBcIjpcIiArICBzLnNjb3JlO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coaW5mbyk7XG4gICAgICAgICAgICAgICAgbm9kZS5nZXRDaGlsZEJ5TmFtZShcImluZm9cIiArIGopLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gaW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coMyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW1wdHlUaXAuYWN0aXZlID0gZGF0YS5sZW5ndGggPT0gMDtcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5fZW1wdHlUaXAuYWN0aXZlKTtcbiAgICAgICAgdGhpcy5zaHJpbmtDb250ZW50KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5fY3VyUm9vbUluZm8gPSBudWxsO1xuICAgIH0sXG4gICAgXG4gICAgaW5pdEdhbWVIaXN0b3J5TGlzdDpmdW5jdGlvbihyb29tSW5mbyxkYXRhKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJpbml0R2FtZUhpc3RvcnlMaXN0XCIpO1xuICAgICAgICBkYXRhLnNvcnQoZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgICAgcmV0dXJuIGEuY3JlYXRlX3RpbWUgPCBiLmNyZWF0ZV90aW1lOyBcbiAgICAgICAgfSk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5nZXRWaWV3SXRlbShpKTtcbiAgICAgICAgICAgIHZhciBpZHggPSBkYXRhLmxlbmd0aCAtIGkgLSAxO1xuICAgICAgICAgICAgbm9kZS5pZHggPSBpZHg7XG4gICAgICAgICAgICB2YXIgdGl0bGVJZCA9IFwiXCIgKyAoaWR4ICsgMSk7XG4gICAgICAgICAgICBub2RlLmdldENoaWxkQnlOYW1lKFwidGl0bGVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSB0aXRsZUlkO1xuICAgICAgICAgICAgbm9kZS5nZXRDaGlsZEJ5TmFtZShcInJvb21Ob1wiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwi5oi/6Ze0SUQ6XCIgKyByb29tSW5mby5pZDtcbiAgICAgICAgICAgIHZhciBkYXRldGltZSA9IHRoaXMuZGF0ZUZvcm1hdChkYXRhW2ldLmNyZWF0ZV90aW1lICogMTAwMCk7XG4gICAgICAgICAgICBub2RlLmdldENoaWxkQnlOYW1lKFwidGltZVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IGRhdGV0aW1lO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgYnRuT3AgPSBub2RlLmdldENoaWxkQnlOYW1lKFwiYnRuT3BcIik7XG4gICAgICAgICAgICBidG5PcC5pZHggPSBpZHg7IFxuICAgICAgICAgICAgLy9idG5PcC5nZXRDaGlsZEJ5TmFtZShcIkxhYmVsXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCLlm57mlL5cIjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YVtpXS5yZXN1bHQpO1xuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7ICsrail7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSByb29tSW5mby5zZWF0c1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHMubmFtZSArIFwiOlwiICsgcmVzdWx0W2pdO1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coaW5mbyk7XG4gICAgICAgICAgICAgICAgbm9kZS5nZXRDaGlsZEJ5TmFtZShcImluZm9cIiArIGopLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gaW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNocmlua0NvbnRlbnQoZGF0YS5sZW5ndGgpO1xuICAgICAgICB0aGlzLl9jdXJSb29tSW5mbyA9IHJvb21JbmZvO1xuICAgIH0sXG4gICAgXG4gICAgZ2V0Vmlld0l0ZW06ZnVuY3Rpb24oaW5kZXgpe1xuICAgICAgICB2YXIgY29udGVudCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgIGlmKGNvbnRlbnQuY2hpbGRyZW5Db3VudCA+IGluZGV4KXtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50LmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9kZSA9IGNjLmluc3RhbnRpYXRlKHRoaXMuX3ZpZXdpdGVtVGVtcCk7XG4gICAgICAgIGNvbnRlbnQuYWRkQ2hpbGQobm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgc2hyaW5rQ29udGVudDpmdW5jdGlvbihudW0pe1xuICAgICAgICB3aGlsZSh0aGlzLl9jb250ZW50LmNoaWxkcmVuQ291bnQgPiBudW0pe1xuICAgICAgICAgICAgdmFyIGxhc3RPbmUgPSB0aGlzLl9jb250ZW50LmNoaWxkcmVuW3RoaXMuX2NvbnRlbnQuY2hpbGRyZW5Db3VudCAtMV07XG4gICAgICAgICAgICB0aGlzLl9jb250ZW50LnJlbW92ZUNoaWxkKGxhc3RPbmUsdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGdldEdhbWVMaXN0T2ZSb29tOmZ1bmN0aW9uKGlkeCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHJvb21JbmZvID0gdGhpcy5faGlzdG9yeURhdGFbaWR4XTsgICAgICAgIFxuICAgICAgICBjYy52di51c2VyTWdyLmdldEdhbWVzT2ZSb29tKHJvb21JbmZvLnV1aWQsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBpZihkYXRhICE9IG51bGwgJiYgZGF0YS5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgICAgICBzZWxmLmluaXRHYW1lSGlzdG9yeUxpc3Qocm9vbUluZm8sZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgXG4gICAgZ2V0RGV0YWlsT2ZHYW1lOmZ1bmN0aW9uKGlkeCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHJvb21VVUlEID0gdGhpcy5fY3VyUm9vbUluZm8udXVpZDtcbiAgICAgICAgY2MudnYudXNlck1nci5nZXREZXRhaWxPZkdhbWUocm9vbVVVSUQsaWR4LGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgZGF0YS5iYXNlX2luZm8gPSBKU09OLnBhcnNlKGRhdGEuYmFzZV9pbmZvKTtcbiAgICAgICAgICAgIGRhdGEuYWN0aW9uX3JlY29yZHMgPSBKU09OLnBhcnNlKGRhdGEuYWN0aW9uX3JlY29yZHMpO1xuICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5wcmVwYXJlUmVwbGF5KHNlbGYuX2N1clJvb21JbmZvLGRhdGEpO1xuICAgICAgICAgICAgY2MudnYucmVwbGF5TWdyLmluaXQoZGF0YSk7XG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJtamdhbWVcIik7IFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIG9uVmlld0l0ZW1DbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgdmFyIGlkeCA9IGV2ZW50LnRhcmdldC5pZHg7XG4gICAgICAgIGNvbnNvbGUubG9nKGlkeCk7XG4gICAgICAgIGlmKHRoaXMuX2N1clJvb21JbmZvID09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5nZXRHYW1lTGlzdE9mUm9vbShpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0aGlzLmdldERldGFpbE9mR2FtZShpZHgrMSk7ICAgICAgXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIG9uQnRuT3BDbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgdmFyIGlkeCA9IGV2ZW50LnRhcmdldC5wYXJlbnQuaWR4O1xuICAgICAgICBjb25zb2xlLmxvZyhpZHgpO1xuICAgICAgICBpZih0aGlzLl9jdXJSb29tSW5mbyA9PSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuZ2V0R2FtZUxpc3RPZlJvb20oaWR4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgdGhpcy5nZXREZXRhaWxPZkdhbWUoaWR4KzEpOyAgICAgIFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcblxuICAgIC8vIH0sXG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHVwZGF0ZVBhbmVsOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAgICAgdHlwZTogY2MuTm9kZVxuICAgICAgICB9LFxuICAgICAgICBtYW5pZmVzdFVybDoge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIHVybDogY2MuUmF3QXNzZXRcbiAgICAgICAgfSxcbiAgICAgICAgcGVyY2VudDoge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6IGNjLkxhYmVsXG4gICAgICAgIH0sXG4gICAgICAgIGxibEVycjoge1xuICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6IGNjLkxhYmVsXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2hlY2tDYjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNjLmxvZygnQ29kZTogJyArIGV2ZW50LmdldEV2ZW50Q29kZSgpKTtcbiAgICAgICAgc3dpdGNoIChldmVudC5nZXRFdmVudENvZGUoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgY2FzZSBqc2IuRXZlbnRBc3NldHNNYW5hZ2VyLkVSUk9SX05PX0xPQ0FMX01BTklGRVNUOlxuICAgICAgICAgICAgICAgIGNjLmxvZyhcIk5vIGxvY2FsIG1hbmlmZXN0IGZpbGUgZm91bmQsIGhvdCB1cGRhdGUgc2tpcHBlZC5cIik7XG4gICAgICAgICAgICAgICAgY2MuZXZlbnRNYW5hZ2VyLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2NoZWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBqc2IuRXZlbnRBc3NldHNNYW5hZ2VyLkVSUk9SX0RPV05MT0FEX01BTklGRVNUOlxuICAgICAgICAgICAgY2FzZSBqc2IuRXZlbnRBc3NldHNNYW5hZ2VyLkVSUk9SX1BBUlNFX01BTklGRVNUOlxuICAgICAgICAgICAgICAgIGNjLmxvZyhcIkZhaWwgdG8gZG93bmxvYWQgbWFuaWZlc3QgZmlsZSwgaG90IHVwZGF0ZSBza2lwcGVkLlwiKTtcbiAgICAgICAgICAgICAgICBjYy5ldmVudE1hbmFnZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5fY2hlY2tMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuQUxSRUFEWV9VUF9UT19EQVRFOlxuICAgICAgICAgICAgICAgIGNjLmxvZyhcIkFscmVhZHkgdXAgdG8gZGF0ZSB3aXRoIHRoZSBsYXRlc3QgcmVtb3RlIHZlcnNpb24uXCIpO1xuICAgICAgICAgICAgICAgIGNjLmV2ZW50TWFuYWdlci5yZW1vdmVMaXN0ZW5lcih0aGlzLl9jaGVja0xpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxibEVyci5zdHJpbmcgKz0gXCLmuLjmiI/kuI3pnIDopoHmm7TmlrBcXG5cIjtcbiAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJsb2FkaW5nXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBqc2IuRXZlbnRBc3NldHNNYW5hZ2VyLk5FV19WRVJTSU9OX0ZPVU5EOlxuICAgICAgICAgICAgICAgIHRoaXMuX25lZWRVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUGFuZWwuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmNlbnQuc3RyaW5nID0gJzAwLjAwJSc7XG4gICAgICAgICAgICAgICAgY2MuZXZlbnRNYW5hZ2VyLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2NoZWNrTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhvdFVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVDYjogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBuZWVkUmVzdGFydCA9IGZhbHNlO1xuICAgICAgICB2YXIgZmFpbGVkID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQuZ2V0RXZlbnRDb2RlKCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhc2UganNiLkV2ZW50QXNzZXRzTWFuYWdlci5FUlJPUl9OT19MT0NBTF9NQU5JRkVTVDpcbiAgICAgICAgICAgICAgICBjYy5sb2coJ05vIGxvY2FsIG1hbmlmZXN0IGZpbGUgZm91bmQsIGhvdCB1cGRhdGUgc2tpcHBlZC4nKTtcbiAgICAgICAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBqc2IuRXZlbnRBc3NldHNNYW5hZ2VyLlVQREFURV9QUk9HUkVTU0lPTjpcbiAgICAgICAgICAgICAgICB2YXIgcGVyY2VudCA9IGV2ZW50LmdldFBlcmNlbnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgcGVyY2VudEJ5RmlsZSA9IGV2ZW50LmdldFBlcmNlbnRCeUZpbGUoKTtcblxuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBldmVudC5nZXRNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgaWYgKG1zZykge1xuICAgICAgICAgICAgICAgICAgICBjYy5sb2cobXNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2MubG9nKHBlcmNlbnQudG9GaXhlZCgyKSArICclJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJjZW50LnN0cmluZyA9IHBlcmNlbnQgKyAnJSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuRVJST1JfRE9XTkxPQURfTUFOSUZFU1Q6XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuRVJST1JfUEFSU0VfTUFOSUZFU1Q6XG4gICAgICAgICAgICAgICAgY2MubG9nKCdGYWlsIHRvIGRvd25sb2FkIG1hbmlmZXN0IGZpbGUsIGhvdCB1cGRhdGUgc2tpcHBlZC4nKTtcbiAgICAgICAgICAgICAgICBmYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBqc2IuRXZlbnRBc3NldHNNYW5hZ2VyLkFMUkVBRFlfVVBfVE9fREFURTpcbiAgICAgICAgICAgICAgICBjYy5sb2coJ0FscmVhZHkgdXAgdG8gZGF0ZSB3aXRoIHRoZSBsYXRlc3QgcmVtb3RlIHZlcnNpb24uJyk7XG4gICAgICAgICAgICAgICAgZmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UganNiLkV2ZW50QXNzZXRzTWFuYWdlci5VUERBVEVfRklOSVNIRUQ6XG4gICAgICAgICAgICAgICAgY2MubG9nKCdVcGRhdGUgZmluaXNoZWQuICcgKyBldmVudC5nZXRNZXNzYWdlKCkpO1xuXG4gICAgICAgICAgICAgICAgbmVlZFJlc3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBqc2IuRXZlbnRBc3NldHNNYW5hZ2VyLlVQREFURV9GQUlMRUQ6XG4gICAgICAgICAgICAgICAgY2MubG9nKCdVcGRhdGUgZmFpbGVkLiAnICsgZXZlbnQuZ2V0TWVzc2FnZSgpKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2ZhaWxDb3VudCArKztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmFpbENvdW50IDwgNSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FtLmRvd25sb2FkRmFpbGVkQXNzZXRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGNjLmxvZygnUmVhY2ggbWF4aW11bSBmYWlsIGNvdW50LCBleGl0IHVwZGF0ZSBwcm9jZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZhaWxDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBqc2IuRXZlbnRBc3NldHNNYW5hZ2VyLkVSUk9SX1VQREFUSU5HOlxuICAgICAgICAgICAgICAgIGNjLmxvZygnQXNzZXQgdXBkYXRlIGVycm9yOiAnICsgZXZlbnQuZ2V0QXNzZXRJZCgpICsgJywgJyArIGV2ZW50LmdldE1lc3NhZ2UoKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGpzYi5FdmVudEFzc2V0c01hbmFnZXIuRVJST1JfREVDT01QUkVTUzpcbiAgICAgICAgICAgICAgICBjYy5sb2coZXZlbnQuZ2V0TWVzc2FnZSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmFpbGVkKSB7XG4gICAgICAgICAgICBjYy5ldmVudE1hbmFnZXIucmVtb3ZlTGlzdGVuZXIodGhpcy5fdXBkYXRlTGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQYW5lbC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWVkUmVzdGFydCkge1xuICAgICAgICAgICAgY2MuZXZlbnRNYW5hZ2VyLnJlbW92ZUxpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIC8vIFByZXBlbmQgdGhlIG1hbmlmZXN0J3Mgc2VhcmNoIHBhdGhcbiAgICAgICAgICAgIHZhciBzZWFyY2hQYXRocyA9IGpzYi5maWxlVXRpbHMuZ2V0U2VhcmNoUGF0aHMoKTtcbiAgICAgICAgICAgIHZhciBuZXdQYXRocyA9IHRoaXMuX2FtLmdldExvY2FsTWFuaWZlc3QoKS5nZXRTZWFyY2hQYXRocygpO1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQoc2VhcmNoUGF0aHMsIG5ld1BhdGhzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgdmFsdWUgd2lsbCBiZSByZXRyaWV2ZWQgYW5kIGFwcGVuZGVkIHRvIHRoZSBkZWZhdWx0IHNlYXJjaCBwYXRoIGR1cmluZyBnYW1lIHN0YXJ0dXAsXG4gICAgICAgICAgICAvLyBwbGVhc2UgcmVmZXIgdG8gc2FtcGxlcy9qcy10ZXN0cy9tYWluLmpzIGZvciBkZXRhaWxlZCB1c2FnZS5cbiAgICAgICAgICAgIC8vICEhISBSZS1hZGQgdGhlIHNlYXJjaCBwYXRocyBpbiBtYWluLmpzIGlzIHZlcnkgaW1wb3J0YW50LCBvdGhlcndpc2UsIG5ldyBzY3JpcHRzIHdvbid0IHRha2UgZWZmZWN0LlxuICAgICAgICAgICAgY2Muc3lzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKCdIb3RVcGRhdGVTZWFyY2hQYXRocycsIEpTT04uc3RyaW5naWZ5KHNlYXJjaFBhdGhzKSk7XG5cbiAgICAgICAgICAgIGpzYi5maWxlVXRpbHMuc2V0U2VhcmNoUGF0aHMoc2VhcmNoUGF0aHMpO1xuICAgICAgICAgICAgdGhpcy5sYmxFcnIuc3RyaW5nICs9IFwi5ri45oiP6LWE5rqQ5pu05paw5a6M5q+VXFxuXCI7XG4gICAgICAgICAgICBjYy5nYW1lLnJlc3RhcnQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBob3RVcGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FtICYmIHRoaXMuX25lZWRVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMubGJsRXJyLnN0cmluZyArPSBcIuW8gOWni+abtOaWsOa4uOaIj+i1hOa6kC4uLlxcblwiO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlTGlzdGVuZXIgPSBuZXcganNiLkV2ZW50TGlzdGVuZXJBc3NldHNNYW5hZ2VyKHRoaXMuX2FtLCB0aGlzLnVwZGF0ZUNiLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgY2MuZXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKHRoaXMuX3VwZGF0ZUxpc3RlbmVyLCAxKTtcblxuICAgICAgICAgICAgdGhpcy5fZmFpbENvdW50ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2FtLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBIb3QgdXBkYXRlIGlzIG9ubHkgYXZhaWxhYmxlIGluIE5hdGl2ZSBidWlsZFxuICAgICAgICBpZiAoIWNjLnN5cy5pc05hdGl2ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGJsRXJyLnN0cmluZyArPSBcIuajgOafpea4uOaIj+i1hOa6kC4uLlxcblwiO1xuICAgICAgICB2YXIgc3RvcmFnZVBhdGggPSAoKGpzYi5maWxlVXRpbHMgPyBqc2IuZmlsZVV0aWxzLmdldFdyaXRhYmxlUGF0aCgpIDogJy8nKSArICd0aWFudGlhbnFpcGFpLWFzc2V0Jyk7XG4gICAgICAgIGNjLmxvZygnU3RvcmFnZSBwYXRoIGZvciByZW1vdGUgYXNzZXQgOiAnICsgc3RvcmFnZVBhdGgpO1xuICAgICAgICB0aGlzLmxibEVyci5zdHJpbmcgKz0gc3RvcmFnZVBhdGggKyBcIlxcblwiO1xuICAgICAgICBjYy5sb2coJ0xvY2FsIG1hbmlmZXN0IFVSTCA6ICcgKyB0aGlzLm1hbmlmZXN0VXJsKTtcbiAgICAgICAgdGhpcy5fYW0gPSBuZXcganNiLkFzc2V0c01hbmFnZXIodGhpcy5tYW5pZmVzdFVybCwgc3RvcmFnZVBhdGgpO1xuICAgICAgICB0aGlzLl9hbS5yZXRhaW4oKTtcblxuICAgICAgICB0aGlzLl9uZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9hbS5nZXRMb2NhbE1hbmlmZXN0KCkuaXNMb2FkZWQoKSlcbiAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tMaXN0ZW5lciA9IG5ldyBqc2IuRXZlbnRMaXN0ZW5lckFzc2V0c01hbmFnZXIodGhpcy5fYW0sIHRoaXMuY2hlY2tDYi5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGNjLmV2ZW50TWFuYWdlci5hZGRMaXN0ZW5lcih0aGlzLl9jaGVja0xpc3RlbmVyLCAxKTtcblxuICAgICAgICAgICAgdGhpcy5fYW0uY2hlY2tVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fYW0gJiYgdGhpcy5fYW0ucmVsZWFzZSgpO1xuICAgIH1cbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICAgICAgX2h1YW5wYWl0aXA6bnVsbCxcbiAgICAgICAgX2h1YW5wYWlBcnI6W11cbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2h1YW5wYWl0aXAgPSBjYy5maW5kKFwiQ2FudmFzL2h1YW5zYW56aGFuZ1wiKTtcbiAgICAgICAgdGhpcy5faHVhbnBhaXRpcC5hY3RpdmUgPSBjYy52di5nYW1lTmV0TWdyLmlzSHVhblNhblpoYW5nO1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5faHVhbnBhaXRpcC5hY3RpdmUpe1xuICAgICAgICAgICAgdGhpcy5zaG93SHVhbnBhaShjYy52di5nYW1lTmV0TWdyLmdldFNlbGZEYXRhKCkuaHVhbnBhaXMgPT0gbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0SHVhaXBhaUluZm8oKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBidG5PayA9IGNjLmZpbmQoXCJDYW52YXMvaHVhbnNhbnpoYW5nL2J0bl9va1wiKTtcbiAgICAgICAgaWYoYnRuT2spe1xuICAgICAgICAgICAgY2MudnYudXRpbHMuYWRkQ2xpY2tFdmVudChidG5Payx0aGlzLm5vZGUsXCJIdWFuU2FuWmhhbmdcIixcIm9uSHVhblNhblpoYW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfaHVhbnBhaScsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgIHNlbGYuX2h1YW5wYWl0aXAuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgc2VsZi5zaG93SHVhbnBhaSh0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2h1YW5wYWlfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGlmKGRhdGEuZGV0YWlsLnNlYXRpbmRleCA9PSBjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleCl7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0SHVhaXBhaUluZm8oKTsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2h1YW5wYWlfb3ZlcicsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLl9odWFucGFpdGlwLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYuX2h1YW5wYWlBcnIubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgIHNlbGYuX2h1YW5wYWlBcnJbaV0ueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9odWFucGFpQXJyID0gW107XG4gICAgICAgICAgICBzZWxmLmluaXRIdWFpcGFpSW5mbygpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9odWFucGFpX3Jlc3VsdCcsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmlzSHVhblNhblpoYW5nID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmLl9odWFucGFpdGlwLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlbGYuX2h1YW5wYWlBcnIubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgIHNlbGYuX2h1YW5wYWlBcnJbaV0ueSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLl9odWFucGFpQXJyID0gW107XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdtal9jbGlja2VkJyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBkYXRhLmRldGFpbDtcbiAgICAgICAgICAgIC8v5aaC5p6c5bey57uP54K56LW35p2l77yM5YiZ5Y+W5raIXG4gICAgICAgICAgICB2YXIgaWR4ID0gc2VsZi5faHVhbnBhaUFyci5pbmRleE9mKHRhcmdldCk7IFxuICAgICAgICAgICAgaWYoaWR4ICE9IC0xKXtcbiAgICAgICAgICAgICAgICB0YXJnZXQueSA9IDA7XG4gICAgICAgICAgICAgICAgc2VsZi5faHVhbnBhaUFyci5zcGxpY2UoaWR4LDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAvL+WmguaenOaYr+aWsOeahO+8jOWImeWKoOWFpVxuICAgICAgICAgICAgICAgIGlmKHNlbGYuX2h1YW5wYWlBcnIubGVuZ3RoIDwgMyl7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX2h1YW5wYWlBcnIucHVzaCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXQueSA9IDE1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgXG4gICAgc2hvd0h1YW5wYWk6ZnVuY3Rpb24oaW50ZXJhY3RhYmxlKXtcbiAgICAgICAgdGhpcy5faHVhbnBhaXRpcC5nZXRDaGlsZEJ5TmFtZShcImluZm9cIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBcIuivt+mAieaLqeS4ieW8oOS4gOagt+iKseiJsueahOeJjFwiO1xuICAgICAgICB0aGlzLl9odWFucGFpdGlwLmdldENoaWxkQnlOYW1lKFwiYnRuX29rXCIpLmdldENvbXBvbmVudChjYy5CdXR0b24pLmludGVyYWN0YWJsZSA9IGludGVyYWN0YWJsZTtcbiAgICAgICAgdGhpcy5faHVhbnBhaXRpcC5nZXRDaGlsZEJ5TmFtZShcIm1hc2tcIikuYWN0aXZlID0gZmFsc2U7ICAgICAgICBcbiAgICB9LFxuICAgIFxuICAgIGluaXRIdWFpcGFpSW5mbzpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgaHVhaXBhaWluZm8gPSBjYy5maW5kKFwiQ2FudmFzL2dhbWUvaHVhbnBhaWluZm9cIik7XG4gICAgICAgIHZhciBzZWF0ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRTZWxmRGF0YSgpO1xuICAgICAgICBpZihzZWF0Lmh1YW5wYWlzID09IG51bGwpe1xuICAgICAgICAgICAgaHVhaXBhaWluZm8uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaHVhaXBhaWluZm8uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNlYXQuaHVhbnBhaXMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgaHVhaXBhaWluZm8uZ2V0Q2hpbGRCeU5hbWUoXCJocFwiICsgKGkgKyAxKSkuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSkuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixzZWF0Lmh1YW5wYWlzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGhwbSA9IGh1YWlwYWlpbmZvLmdldENoaWxkQnlOYW1lKFwiaHBtXCIpO1xuICAgICAgICBocG0uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgaWYoY2MudnYuZ2FtZU5ldE1nci5odWFucGFpbWV0aG9kID09IDApe1xuICAgICAgICAgICAgaHBtLnJvdGF0aW9uID0gOTA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihjYy52di5nYW1lTmV0TWdyLmh1YW5wYWltZXRob2QgPT0gMSl7XG4gICAgICAgICAgICBocG0ucm90YXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoY2MudnYuZ2FtZU5ldE1nci5odWFucGFpbWV0aG9kID09IDIpe1xuICAgICAgICAgICAgaHBtLnJvdGF0aW9uID0gMTgwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBocG0uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIG9uSHVhblNhblpoYW5nOmZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgaWYodGhpcy5faHVhbnBhaUFyci5sZW5ndGggIT0gMyl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciB0eXBlID0gbnVsbDtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2h1YW5wYWlBcnIubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIHBhaSA9IHRoaXMuX2h1YW5wYWlBcnJbaV0ubWpJZDtcbiAgICAgICAgICAgIHZhciBudCA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0TWFoam9uZ1R5cGUocGFpKTsgXG4gICAgICAgICAgICBpZih0eXBlID09IG51bGwpe1xuICAgICAgICAgICAgICAgIHR5cGUgPSBudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgaWYodHlwZSAhPSBudCl7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgcDE6dGhpcy5faHVhbnBhaUFyclswXS5taklkLFxuICAgICAgICAgICAgcDI6dGhpcy5faHVhbnBhaUFyclsxXS5taklkLFxuICAgICAgICAgICAgcDM6dGhpcy5faHVhbnBhaUFyclsyXS5taklkLFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9odWFucGFpdGlwLmdldENoaWxkQnlOYW1lKFwiaW5mb1wiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwi562J5b6F5YW25LuW546p5a626YCJ54mMLi4uXCI7XG4gICAgICAgIHRoaXMuX2h1YW5wYWl0aXAuZ2V0Q2hpbGRCeU5hbWUoXCJidG5fb2tcIikuZ2V0Q29tcG9uZW50KGNjLkJ1dHRvbikuaW50ZXJhY3RhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2h1YW5wYWl0aXAuZ2V0Q2hpbGRCeU5hbWUoXCJtYXNrXCIpLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICBjYy52di5uZXQuc2VuZChcImh1YW5wYWlcIixkYXRhKTtcbiAgICB9LFxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbn0pO1xuIiwiZnVuY3Rpb24gbG9hZEltYWdlKHVybCxjb2RlLGNhbGxiYWNrKXtcbiAgICAvKlxuICAgIGlmKGNjLnZ2LmltYWdlcyA9PSBudWxsKXtcbiAgICAgICAgY2MudnYuaW1hZ2VzID0ge307XG4gICAgfVxuICAgIHZhciBpbWFnZUluZm8gPSBjYy52di5pbWFnZXNbdXJsXTtcbiAgICBpZihpbWFnZUluZm8gPT0gbnVsbCl7XG4gICAgICAgIGltYWdlSW5mbyA9IHtcbiAgICAgICAgICAgIGltYWdlOm51bGwsXG4gICAgICAgICAgICBxdWV1ZTpbXSxcbiAgICAgICAgfTtcbiAgICAgICAgY2MudnYuaW1hZ2VzW3VybF0gPSBpbWFnZUluZm87XG4gICAgfVxuICAgIFxuICAgIGNjLmxvYWRlci5sb2FkKHVybCxmdW5jdGlvbiAoZXJyLHRleCkge1xuICAgICAgICBpbWFnZUluZm8uaW1hZ2UgPSB0ZXg7XG4gICAgICAgIHZhciBzcHJpdGVGcmFtZSA9IG5ldyBjYy5TcHJpdGVGcmFtZSh0ZXgsIGNjLlJlY3QoMCwgMCwgdGV4LndpZHRoLCB0ZXguaGVpZ2h0KSk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbWFnZUluZm8ucXVldWUubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIGl0bSA9IGltYWdlSW5mby5xdWV1ZVtpXTtcbiAgICAgICAgICAgIGl0bS5jYWxsYmFjayhpdG0uY29kZSxzcHJpdGVGcmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaXRtLnF1ZXVlID0gW107XG4gICAgfSk7XG4gICAgaWYoaW1hZ2VJbmZvLmltYWdlICE9IG51bGwpe1xuICAgICAgICB2YXIgdGV4ID0gaW1hZ2VJbmZvLmltYWdlO1xuICAgICAgICB2YXIgc3ByaXRlRnJhbWUgPSBuZXcgY2MuU3ByaXRlRnJhbWUodGV4LCBjYy5SZWN0KDAsIDAsIHRleC53aWR0aCwgdGV4LmhlaWdodCkpO1xuICAgICAgICBjYWxsYmFjayhjb2RlLHNwcml0ZUZyYW1lKTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgaW1hZ2VJbmZvLnF1ZXVlLnB1c2goe2NvZGU6Y29kZSxjYWxsYmFjazpjYWxsYmFja30pO1xuICAgIH0qL1xuICAgIGNjLmxvYWRlci5sb2FkKHVybCxmdW5jdGlvbiAoZXJyLHRleCkge1xuICAgICAgICB2YXIgc3ByaXRlRnJhbWUgPSBuZXcgY2MuU3ByaXRlRnJhbWUodGV4LCBjYy5SZWN0KDAsIDAsIHRleC53aWR0aCwgdGV4LmhlaWdodCkpO1xuICAgICAgICBjYWxsYmFjayhjb2RlLHNwcml0ZUZyYW1lKTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldEJhc2VJbmZvKHVzZXJpZCxjYWxsYmFjayl7XG4gICAgaWYoY2MudnYuYmFzZUluZm9NYXAgPT0gbnVsbCl7XG4gICAgICAgIGNjLnZ2LmJhc2VJbmZvTWFwID0ge307XG4gICAgfVxuICAgIFxuICAgIGlmKGNjLnZ2LmJhc2VJbmZvTWFwW3VzZXJpZF0gIT0gbnVsbCl7XG4gICAgICAgIGNhbGxiYWNrKHVzZXJpZCxjYy52di5iYXNlSW5mb01hcFt1c2VyaWRdKTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdCgnL2Jhc2VfaW5mbycse3VzZXJpZDp1c2VyaWR9LGZ1bmN0aW9uKHJldCl7XG4gICAgICAgICAgICB2YXIgdXJsID0gbnVsbDtcbiAgICAgICAgICAgIGlmKHJldC5oZWFkaW1ndXJsKXtcbiAgICAgICAgICAgICAgIHVybCA9IHJldC5oZWFkaW1ndXJsICsgXCIuanBnXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOnJldC5uYW1lLFxuICAgICAgICAgICAgICAgIHNleDpyZXQuc2V4LFxuICAgICAgICAgICAgICAgIHVybDp1cmwsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYy52di5iYXNlSW5mb01hcFt1c2VyaWRdID0gaW5mbztcbiAgICAgICAgICAgIGNhbGxiYWNrKHVzZXJpZCxpbmZvKTtcbiAgICAgICAgICAgIFxuICAgICAgICB9LGNjLnZ2Lmh0dHAubWFzdGVyX3VybCk7ICAgXG4gICAgfSAgXG59O1xuXG5jYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0dXBTcHJpdGVGcmFtZSgpO1xuICAgIH0sXG4gICAgXG4gICAgc2V0VXNlcklEOmZ1bmN0aW9uKHVzZXJpZCl7XG4gICAgICAgIGlmKGNjLnN5cy5pc05hdGl2ZSA9PSBmYWxzZSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYoIXVzZXJpZCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYoY2MudnYuaW1hZ2VzID09IG51bGwpe1xuICAgICAgICAgICAgY2MudnYuaW1hZ2VzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgZ2V0QmFzZUluZm8odXNlcmlkLGZ1bmN0aW9uKGNvZGUsaW5mbyl7XG4gICAgICAgICAgIGlmKGluZm8gJiYgaW5mby51cmwpe1xuICAgICAgICAgICAgICAgIGxvYWRJbWFnZShpbmZvLnVybCx1c2VyaWQsZnVuY3Rpb24gKGVycixzcHJpdGVGcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zcHJpdGVGcmFtZSA9IHNwcml0ZUZyYW1lO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNldHVwU3ByaXRlRnJhbWUoKTtcbiAgICAgICAgICAgICAgICB9KTsgICBcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgXG4gICAgc2V0dXBTcHJpdGVGcmFtZTpmdW5jdGlvbigpe1xuICAgICAgICBpZih0aGlzLl9zcHJpdGVGcmFtZSl7XG4gICAgICAgICAgICB2YXIgc3ByID0gdGhpcy5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcbiAgICAgICAgICAgIGlmKHNwcil7XG4gICAgICAgICAgICAgICAgc3ByLnNwcml0ZUZyYW1lID0gdGhpcy5fc3ByaXRlRnJhbWU7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcblxuICAgIC8vIH0sXG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIG51bXM6e1xuICAgICAgICAgICAgZGVmYXVsdDpbXSxcbiAgICAgICAgICAgIHR5cGU6W2NjLkxhYmVsXVxuICAgICAgICB9LFxuICAgICAgICBfaW5wdXRJbmRleDowLFxuICAgICAgICAvLyBmb286IHtcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgb25FbmFibGU6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5vblJlc2V0Q2xpY2tlZCgpO1xuICAgIH0sXG4gICAgXG4gICAgb25JbnB1dEZpbmlzaGVkOmZ1bmN0aW9uKHJvb21JZCl7XG4gICAgICAgIGNjLnZ2LnVzZXJNZ3IuZW50ZXJSb29tKHJvb21JZCxmdW5jdGlvbihyZXQpe1xuICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgPT0gMCl7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudCA9IFwi5oi/6Ze0W1wiKyByb29tSWQgK1wiXeS4jeWtmOWcqO+8jOivt+mHjeaWsOi+k+WFpSFcIjtcbiAgICAgICAgICAgICAgICBpZihyZXQuZXJyY29kZSA9PSA0KXtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IFwi5oi/6Ze0W1wiKyByb29tSWQgKyBcIl3lt7Lmu6EhXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlID09IDUpe1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gXCLpkrvnn7PkuI3otrPor7flhYXlgLzvvIFcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2MudnYuYWxlcnQuc2hvdyhcIuaPkOekulwiLGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMub25SZXNldENsaWNrZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTsgXG4gICAgfSxcbiAgICBcbiAgICBvbklucHV0OmZ1bmN0aW9uKG51bSl7XG4gICAgICAgIGlmKHRoaXMuX2lucHV0SW5kZXggPj0gdGhpcy5udW1zLmxlbmd0aCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5udW1zW3RoaXMuX2lucHV0SW5kZXhdLnN0cmluZyA9IG51bTtcbiAgICAgICAgdGhpcy5faW5wdXRJbmRleCArPSAxO1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5faW5wdXRJbmRleCA9PSB0aGlzLm51bXMubGVuZ3RoKXtcbiAgICAgICAgICAgIHZhciByb29tSWQgPSB0aGlzLnBhcnNlUm9vbUlEKCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9rOlwiICsgcm9vbUlkKTtcbiAgICAgICAgICAgIHRoaXMub25JbnB1dEZpbmlzaGVkKHJvb21JZCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIG9uTjBDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMub25JbnB1dCgwKTsgIFxuICAgIH0sXG4gICAgb25OMUNsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5vbklucHV0KDEpOyAgXG4gICAgfSxcbiAgICBvbk4yQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm9uSW5wdXQoMik7XG4gICAgfSxcbiAgICBvbk4zQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm9uSW5wdXQoMyk7XG4gICAgfSxcbiAgICBvbk40Q2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm9uSW5wdXQoNCk7XG4gICAgfSxcbiAgICBvbk41Q2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm9uSW5wdXQoNSk7XG4gICAgfSxcbiAgICBvbk42Q2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm9uSW5wdXQoNik7XG4gICAgfSxcbiAgICBvbk43Q2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm9uSW5wdXQoNyk7XG4gICAgfSxcbiAgICBvbk44Q2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm9uSW5wdXQoOCk7XG4gICAgfSxcbiAgICBvbk45Q2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm9uSW5wdXQoOSk7XG4gICAgfSxcbiAgICBvblJlc2V0Q2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1zLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHRoaXMubnVtc1tpXS5zdHJpbmcgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lucHV0SW5kZXggPSAwO1xuICAgIH0sXG4gICAgb25EZWxDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKHRoaXMuX2lucHV0SW5kZXggPiAwKXtcbiAgICAgICAgICAgIHRoaXMuX2lucHV0SW5kZXggLT0gMTtcbiAgICAgICAgICAgIHRoaXMubnVtc1t0aGlzLl9pbnB1dEluZGV4XS5zdHJpbmcgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBvbkNsb3NlQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gZmFsc2U7XG4gICAgfSxcbiAgICBcbiAgICBwYXJzZVJvb21JRDpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgc3RyID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubnVtcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBzdHIgKz0gdGhpcy5udW1zW2ldLnN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcblxuICAgIC8vIH0sXG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHRpcExhYmVsOmNjLkxhYmVsLFxuICAgICAgICBfc3RhdGVTdHI6JycsXG4gICAgICAgIF9wcm9ncmVzczowLjAsXG4gICAgICAgIF9zcGxhc2g6bnVsbCxcbiAgICAgICAgX2lzTG9hZGluZzpmYWxzZSxcbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUgJiYgY2Muc3lzLmlzTW9iaWxlKXtcbiAgICAgICAgICAgIHZhciBjdnMgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KGNjLkNhbnZhcyk7XG4gICAgICAgICAgICBjdnMuZml0SGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGN2cy5maXRXaWR0aCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0TWdyKCk7XG4gICAgICAgIHRoaXMudGlwTGFiZWwuc3RyaW5nID0gdGhpcy5fc3RhdGVTdHI7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9zcGxhc2ggPSBjYy5maW5kKFwiQ2FudmFzL3NwbGFzaFwiKTtcbiAgICAgICAgdGhpcy5fc3BsYXNoLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL21qX2xvZ2luXCIsIDEsIGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgY2Muc3lzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKFwieW91a2VvcndlaXhpblwiLCBkYXRhLmRhdGEueW91a2VvcndlaXhpbik7XG4gICAgICAgICAgICBpZiAoY2Muc3lzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwieW91a2VvcndlaXhpblwiKT09XCIwXCIgJiYgY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1MpIHtcbiAgICAgICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL05ldyBMYWJlbFwiKS5hY3RpdmUgPSBmYWxzZTsgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgc3RhcnQ6ZnVuY3Rpb24oKXsgICAgICAgIFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBTSE9XX1RJTUUgPSAzMDAwO1xuICAgICAgICB2YXIgRkFERV9USU1FID0gNTAwO1xuICAgICAgICBpZihjYy5zeXMub3MgIT0gY2Muc3lzLk9TX0lPUyB8fCAhY2Muc3lzLmlzTmF0aXZlKXtcbiAgICAgICAgICAgIHNlbGYuX3NwbGFzaC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB2YXIgZHQgPSBEYXRlLm5vdygpIC0gdDtcbiAgICAgICAgICAgICAgICBpZihkdCA8IFNIT1dfVElNRSl7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sMzMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG9wID0gKDEgLSAoKGR0IC0gU0hPV19USU1FKSAvIEZBREVfVElNRSkpICogMjU1O1xuICAgICAgICAgICAgICAgICAgICBpZihvcCA8IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fc3BsYXNoLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5jaGVja1ZlcnNpb24oKTsgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3NwbGFzaC5vcGFjaXR5ID0gb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLDMzKTsgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZuLDMzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgdGhpcy5fc3BsYXNoLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5jaGVja1ZlcnNpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgaW5pdE1ncjpmdW5jdGlvbigpe1xuICAgICAgICBjYy52diA9IHt9O1xuICAgICAgICB2YXIgVXNlck1nciA9IHJlcXVpcmUoXCJVc2VyTWdyXCIpO1xuICAgICAgICBjYy52di51c2VyTWdyID0gbmV3IFVzZXJNZ3IoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBSZXBsYXlNZ3IgPSByZXF1aXJlKFwiUmVwbGF5TWdyXCIpO1xuICAgICAgICBjYy52di5yZXBsYXlNZ3IgPSBuZXcgUmVwbGF5TWdyKCk7XG4gICAgICAgIFxuICAgICAgICBjYy52di5odHRwID0gcmVxdWlyZShcIkhUVFBcIik7XG4gICAgICAgIGNjLnZ2Lmdsb2JhbCA9IHJlcXVpcmUoXCJHbG9iYWxcIik7XG4gICAgICAgIGNjLnZ2Lm5ldCA9IHJlcXVpcmUoXCJOZXRcIik7XG4gICAgICAgIFxuICAgICAgICB2YXIgR2FtZU5ldE1nciA9IHJlcXVpcmUoXCJHYW1lTmV0TWdyXCIpO1xuICAgICAgICBjYy52di5nYW1lTmV0TWdyID0gbmV3IEdhbWVOZXRNZ3IoKTtcbiAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5pbml0SGFuZGxlcnMoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBBbnlzZGtNZ3IgPSByZXF1aXJlKFwiQW55c2RrTWdyXCIpO1xuICAgICAgICBjYy52di5hbnlzZGtNZ3IgPSBuZXcgQW55c2RrTWdyKCk7XG4gICAgICAgIGNjLnZ2LmFueXNka01nci5pbml0KCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgVm9pY2VNZ3IgPSByZXF1aXJlKFwiVm9pY2VNZ3JcIik7XG4gICAgICAgIGNjLnZ2LnZvaWNlTWdyID0gbmV3IFZvaWNlTWdyKCk7XG4gICAgICAgIGNjLnZ2LnZvaWNlTWdyLmluaXQoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBBdWRpb01nciA9IHJlcXVpcmUoXCJBdWRpb01nclwiKTtcbiAgICAgICAgY2MudnYuYXVkaW9NZ3IgPSBuZXcgQXVkaW9NZ3IoKTtcbiAgICAgICAgY2MudnYuYXVkaW9NZ3IuaW5pdCgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIFV0aWxzID0gcmVxdWlyZShcIlV0aWxzXCIpO1xuICAgICAgICBjYy52di51dGlscyA9IG5ldyBVdGlscygpO1xuICAgICAgICBcbiAgICAgICAgY2MuYXJncyA9IHRoaXMudXJsUGFyc2UoKTtcbiAgICB9LFxuICAgIFxuICAgIHVybFBhcnNlOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgaWYod2luZG93LmxvY2F0aW9uID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZSx2YWx1ZTsgXG4gICAgICAgIHZhciBzdHI9d2luZG93LmxvY2F0aW9uLmhyZWY7IC8v5Y+W5b6X5pW05Liq5Zyw5Z2A5qCPXG4gICAgICAgIHZhciBudW09c3RyLmluZGV4T2YoXCI/XCIpIFxuICAgICAgICBzdHI9c3RyLnN1YnN0cihudW0rMSk7IC8v5Y+W5b6X5omA5pyJ5Y+C5pWwICAgc3RyaW5ndmFyLnN1YnN0cihzdGFydCBbLCBsZW5ndGggXVxuICAgICAgICBcbiAgICAgICAgdmFyIGFycj1zdHIuc3BsaXQoXCImXCIpOyAvL+WQhOS4quWPguaVsOaUvuWIsOaVsOe7hOmHjFxuICAgICAgICBmb3IodmFyIGk9MDtpIDwgYXJyLmxlbmd0aDtpKyspeyBcbiAgICAgICAgICAgIG51bT1hcnJbaV0uaW5kZXhPZihcIj1cIik7IFxuICAgICAgICAgICAgaWYobnVtPjApeyBcbiAgICAgICAgICAgICAgICBuYW1lPWFycltpXS5zdWJzdHJpbmcoMCxudW0pO1xuICAgICAgICAgICAgICAgIHZhbHVlPWFycltpXS5zdWJzdHIobnVtKzEpO1xuICAgICAgICAgICAgICAgIHBhcmFtc1tuYW1lXT12YWx1ZTtcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuICAgIFxuICAgIGNoZWNrVmVyc2lvbjpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBvbkdldFZlcnNpb24gPSBmdW5jdGlvbihyZXQpe1xuICAgICAgICAgICAgaWYocmV0LnZlcnNpb24gPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJlcnJvci5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGNjLnZ2LlNJID0gcmV0O1xuICAgICAgICAgICAgICAgIGlmKHJldC52ZXJzaW9uICE9IGNjLlZFUlNJT04pe1xuICAgICAgICAgICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL2FsZXJ0XCIpLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc3RhcnRQcmVsb2FkaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIHhociA9IG51bGw7XG4gICAgICAgIHZhciBjb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICB2YXIgZm5SZXF1ZXN0ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYuX3N0YXRlU3RyID0gXCLmraPlnKjov57mjqXmnI3liqHlmahcIjtcbiAgICAgICAgICAgIHhociA9IGNjLnZ2Lmh0dHAuc2VuZFJlcXVlc3QoXCIvZ2V0X3NlcnZlcmluZm9cIixudWxsLGZ1bmN0aW9uKHJldCl7XG4gICAgICAgICAgICAgICAgeGhyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgb25HZXRWZXJzaW9uKHJldCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZm4sNTAwMCk7ICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZighY29tcGxldGUpe1xuICAgICAgICAgICAgICAgIGlmKHhocil7XG4gICAgICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zdGF0ZVN0ciA9IFwi6L+e5o6l5aSx6LSl77yM5Y2z5bCG6YeN6K+VXCI7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZuUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICB9LDUwMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBmblJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZuKCk7XG4gICAgfSxcbiAgICBcbiAgICBvbkJ0bkRvd25sb2FkQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICBjYy5zeXMub3BlblVSTChjYy52di5TSS5hcHB3ZWIpO1xuICAgIH0sXG4gICAgXG4gICAgc3RhcnRQcmVsb2FkaW5nOmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX3N0YXRlU3RyID0gXCLmraPlnKjliqDovb3otYTmupDvvIzor7fnqI3lgJlcIjtcbiAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgY2MubG9hZGVyLm9uUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoIGNvbXBsZXRlZENvdW50LCB0b3RhbENvdW50LCAgaXRlbSApe1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNvbXBsZXRlZENvdW50OlwiICsgY29tcGxldGVkQ291bnQgKyBcIix0b3RhbENvdW50OlwiICsgdG90YWxDb3VudCApO1xuICAgICAgICAgICAgaWYoc2VsZi5faXNMb2FkaW5nKXtcbiAgICAgICAgICAgICAgICBzZWxmLl9wcm9ncmVzcyA9IGNvbXBsZXRlZENvdW50L3RvdGFsQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjYy5sb2FkZXIubG9hZFJlc0FsbChcInRleHR1cmVzXCIsIGZ1bmN0aW9uIChlcnIsIGFzc2V0cykge1xuICAgICAgICAgICAgc2VsZi5vbkxvYWRDb21wbGV0ZSgpO1xuICAgICAgICB9KTsgICAgICBcbiAgICB9LFxuICAgIFxuICAgIG9uTG9hZENvbXBsZXRlOmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX2lzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zdGF0ZVN0ciA9IFwi5YeG5aSH55m76ZmGXCI7XG4gICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcImxvZ2luXCIpO1xuICAgICAgICBjYy5sb2FkZXIub25Db21wbGV0ZSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgaWYodGhpcy5fc3RhdGVTdHIubGVuZ3RoID09IDApe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlwTGFiZWwuc3RyaW5nID0gdGhpcy5fc3RhdGVTdHIgKyAnICc7XG4gICAgICAgIGlmKHRoaXMuX2lzTG9hZGluZyl7XG4gICAgICAgICAgICB0aGlzLnRpcExhYmVsLnN0cmluZyArPSBNYXRoLmZsb29yKHRoaXMuX3Byb2dyZXNzICogMTAwKSArIFwiJVwiOyAgIFxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB2YXIgdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICUgNDtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0OyArKyBpKXtcbiAgICAgICAgICAgICAgICB0aGlzLnRpcExhYmVsLnN0cmluZyArPSAnLic7XG4gICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG59KTsiLCJTdHJpbmcucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKGFyZ3MpIHsgXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGg+MCkgeyBcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7IFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIHR5cGVvZiAoYXJncykgPT0gXCJvYmplY3RcIikgeyBcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmdzKSB7IFxuICAgICAgICAgICAgICAgIHZhciByZWc9bmV3IFJlZ0V4cCAoXCIoe1wiK2tleStcIn0pXCIsXCJnXCIpOyBcbiAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShyZWcsIGFyZ3Nba2V5XSk7IFxuICAgICAgICAgICAgfSBcbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSB7IFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgXG4gICAgICAgICAgICAgICAgaWYoYXJndW1lbnRzW2ldPT11bmRlZmluZWQpIHsgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiOyBcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgIGVsc2UgeyBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZz1uZXcgUmVnRXhwIChcIih7W1wiK2krXCJdfSlcIixcImdcIik7IFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShyZWcsIGFyZ3VtZW50c1tpXSk7IFxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9IFxuICAgICAgICB9IFxuICAgICAgICByZXR1cm4gcmVzdWx0OyBcbiAgICB9IFxuICAgIGVsc2UgeyBcbiAgICAgICAgcmV0dXJuIHRoaXM7IFxuICAgIH0gXG59O1xuIFxuY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgICAgIF9taW1hOm51bGwsXG4gICAgICAgIF9taW1hSW5kZXg6MCxcbiAgICAgICAgbWpkbDoxLCAgLy/vv73pvavvv73vv73CvO+/vcO777+90K3vv73po6zWu++/vdC577+90aHvv73vv73Fpe+/vc6/zbXvv73CvO+/ve+/vc6i77+9xbXvv73CvO+/vcW/77+977+91L3vv73IpVxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoIWNjLnN5cy5pc05hdGl2ZSAmJiBjYy5zeXMuaXNNb2JpbGUpe1xuICAgICAgICAgICAgdmFyIGN2cyA9IHRoaXMubm9kZS5nZXRDb21wb25lbnQoY2MuQ2FudmFzKTtcbiAgICAgICAgICAgIGN2cy5maXRIZWlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgY3ZzLmZpdFdpZHRoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIWNjLnZ2KXtcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcImxvYWRpbmdcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2MudnYuaHR0cC51cmwgPSBjYy52di5odHRwLm1hc3Rlcl91cmw7XG4gICAgICAgIGNjLnZ2Lm5ldC5hZGRIYW5kbGVyKCdwdXNoX25lZWRfY3JlYXRlX3JvbGUnLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIm9uTG9hZDpwdXNoX25lZWRfY3JlYXRlX3JvbGVcIik7XG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJjcmVhdGVyb2xlXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBsYXlCR00oXCJiZ01haW4ubXAzXCIpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fbWltYSA9IFtcIkFcIixcIkFcIixcIkJcIixcIkJcIixcIkFcIixcIkJcIixcIkFcIixcIkJcIixcIkFcIixcIkFcIixcIkFcIixcIkJcIixcIkJcIixcIkJcIl07XG4gICAgICAgIFxuICAgICAgICBpZighY2Muc3lzLmlzTmF0aXZlIHx8IGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfV0lORE9XUyl7XG4gICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL2J0bl95a1wiKS5hY3RpdmUgPSB0cnVlOyAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB5b3VrZW9yd2VpeGluID0gY2Muc3lzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwieW91a2VvcndlaXhpblwiKTtcbiAgICAgICAgLy/lronljZPlj6rmmL7npLrlvq7kv6HnmbvpmYZcbiAgICAgICAgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19BTkRST0lEKXsgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBsYXRmb3JtOlwiICsgY2Muc3lzLk9TX0FORFJPSUQgKyBcIiBPU19BTkRST0lELlwiKTtcbiAgICAgICAgICAgIGNjLmZpbmQoXCJDYW52YXMvYnRuX3lrXCIpLmFjdGl2ZSA9IGZhbHNlOyBcbiAgICAgICAgICAgIGNjLmZpbmQoXCJDYW52YXMvel93ZWl4aW5kZW5nbHVcIikuYWN0aXZlID0gdHJ1ZTsgIFxuICAgICAgICB9XG4gICAgICAgIC8vSU9T5a6h5qC454mI5pysIOWPquaYvuekuua4uOWuoueZu+W9lSDov4flrqHniYjmnKwg5Y+q5pi+56S65b6u5L+h55m76ZmGXG4gICAgICAgIGVsc2UgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1Mpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwbGF0Zm9ybTpcIiArIGNjLnN5cy5PU19JT1MgKyBcIiBPU19JT1MuXCIpO1xuICAgICAgICAgICAgaWYoeW91a2VvcndlaXhpbiA9PSBcIjBcIil7XG4gICAgICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9idG5feWtcIikuYWN0aXZlID0gdHJ1ZTsgXG4gICAgICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy96X3dlaXhpbmRlbmdsdVwiKS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL3loeHlcIikuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHlvdWtlb3J3ZWl4aW4gPT0gXCIxXCIgfHwgeW91a2VvcndlaXhpbiA9PSBcIm51bGxcIiApe1xuICAgICAgICAgICAgICAgIGNjLmZpbmQoXCJDYW52YXMvel93ZWl4aW5kZW5nbHVcIikuYWN0aXZlID0gdHJ1ZTsgXG4gICAgICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9idG5feWtcIikuYWN0aXZlID0gZmFsc2U7ICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9idG5feWtcIikuYWN0aXZlID0gdHJ1ZTsgXG4gICAgICAgICAgICBjYy5maW5kKFwiQ2FudmFzL3pfd2VpeGluZGVuZ2x1XCIpLmFjdGl2ZSA9IGZhbHNlOyAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBsYXRmb3JtOlwiICsgY2Muc3lzLm9zICsgXCIgZG9zbid0IGltcGxlbWVudCBzaGFyZS5cIik7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGNjLnN5c3RlbUV2ZW50Lm9uKGNjLlN5c3RlbUV2ZW50LkV2ZW50VHlwZS5LRVlfVVAsIGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgIGNjLmdhbWUuZW5kICgpOyBcbiAgICAgICAgfSwgY2MuR2FtZSk7XG4gICAgXG4gICAgICAgIFxuICAgIH0sXG5cbiAgIFxuICAgIHN0YXJ0OmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBhY2NvdW50ID0gIGNjLnN5cy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInd4X2FjY291bnRcIik7XG4gICAgICAgIHZhciBzaWduID0gY2Muc3lzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwid3hfc2lnblwiKTtcbiAgICAgICAgaWYoYWNjb3VudCAhPSBudWxsICYmIHNpZ24gIT0gbnVsbCl7XG4gICAgICAgICAgICB2YXIgcmV0ID0ge1xuICAgICAgICAgICAgICAgIGVycmNvZGU6MCxcbiAgICAgICAgICAgICAgICBhY2NvdW50OmFjY291bnQsXG4gICAgICAgICAgICAgICAgc2lnbjpzaWduXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYy52di51c2VyTWdyLm9uQXV0aChyZXQpO1xuICAgICAgICB9ICAgXG4gICAgfSxcbiAgICBcbiAgICBvbkJ0blJldHVybjpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgeWh4eSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInloeHlcIik7XG4gICAgICAgIHloeHkuYWN0aXZlID0gZmFsc2U7XG4gICAgfSxcbiAgICBjaGVja19tYXJrOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB0eXloeHkgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJ0eXloeHlcIik7XG4gICAgICAgIHZhciBidG5fY2hlY2tib3ggPSB0eXloeHkuZ2V0Q2hpbGRCeU5hbWUoXCJidG5fY2hlY2tib3hcIik7XG4gICAgICAgIHZhciBjaGVja19tYXJrID0gYnRuX2NoZWNrYm94LmdldENoaWxkQnlOYW1lKFwiY2hlY2tfbWFya1wiKTtcbiAgICAgICAgaWYodGhpcy5tamRsID09IDEpe1xuICAgICAgICAgICAgY2hlY2tfbWFyay5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubWpkbCA9IDA7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY2hlY2tfbWFyay5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tamRsID0gMTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhcInRoaXMubWpkbDpcIit0aGlzLm1qZGwpXG4gICAgfSxcbiAgICB5b25naHV4aWV5aTpmdW5jdGlvbigpe1xuICAgIFxuICAgICAgICB2YXIgeWh4eSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInloeHlcIik7XG4gICAgICAgIHloeHkuYWN0aXZlID0gdHJ1ZTtcbiAgICB9LFxuICAgIHByb21wdDpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcHJvbXB0ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwicHJvbXB0XCIpO1xuICAgICAgICAgICAgcHJvbXB0LmFjdGl2ZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgb25CdG5RdWlja1N0YXJ0Q2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICBpZih0aGlzLm1qZGwgPT0gMCl7XG4gICAgICAgICAgICB2YXIgcHJvbXB0ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwicHJvbXB0XCIpO1xuICAgICAgICAgICAgcHJvbXB0LmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJzc3lcIilcbiAgICAgICAgXG4gICAgICAgIGNjLnZ2LnVzZXJNZ3IuZ3Vlc3RBdXRoKCk7XG4gICAgfSxcbiAgICBcbiAgICBvbkJ0bkRvd25sb2FkQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICBjYy5zeXMub3BlblVSTChjYy52di5TSS5hcHB3ZWIpO1xuICAgIH0sXG4gICBcbiAgICBcbiAgICBvbkJ0bldlaWNoYXRDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICBcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZihzZWxmLm1qZGwgPT0gMCl7XG4gICAgICAgICAgICB2YXIgcHJvbXB0ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwicHJvbXB0XCIpO1xuICAgICAgICAgICAgcHJvbXB0LmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coXCJzc1wiKVxuICAgICAgICBjYy52di5hbnlzZGtNZ3IubG9naW4oKTtcbiAgICB9LFxuICAgIFxuICAgIG9uQnRuTUlNQUNsaWNrZWQ6ZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICBpZih0aGlzLl9taW1hW3RoaXMuX21pbWFJbmRleF0gPT0gZXZlbnQudGFyZ2V0Lm5hbWUpe1xuICAgICAgICAgICAgdGhpcy5fbWltYUluZGV4Kys7XG4gICAgICAgICAgICBpZih0aGlzLl9taW1hSW5kZXggPT0gdGhpcy5fbWltYS5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIGNjLmZpbmQoXCJDYW52YXMvYnRuX3lrXCIpLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwib2ggaG9+fn5cIik7XG4gICAgICAgICAgICB0aGlzLl9taW1hSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHsgICAgICAgIFxuICAgICAgICBnYW1lUm9vdDp7XG4gICAgICAgICAgICBkZWZhdWx0Om51bGwsXG4gICAgICAgICAgICB0eXBlOmNjLk5vZGVcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHByZXBhcmVSb290OntcbiAgICAgICAgICAgIGRlZmF1bHQ6bnVsbCxcbiAgICAgICAgICAgIHR5cGU6Y2MuTm9kZSAgIFxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgX215TUpBcnI6W10sXG4gICAgICAgIF9vcHRpb25zOm51bGwsXG4gICAgICAgIF9zZWxlY3RlZE1KOm51bGwsXG4gICAgICAgIF9jaHVwYWlTcHJpdGU6W10sXG4gICAgICAgIF9tamNvdW50Om51bGwsXG4gICAgICAgIF9nYW1lY291bnQ6bnVsbCxcbiAgICAgICAgX2h1cGFpVGlwczpbXSxcbiAgICAgICAgX2h1cGFpTGlzdHM6W10sXG4gICAgICAgIF9wbGF5RWZ4czpbXSxcbiAgICAgICAgX29wdHM6W10sXG4gICAgICAgIF9nYW1ldHlwZTpudWxsLFxuICAgIH0sXG4gICAgXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUgJiYgY2Muc3lzLmlzTW9iaWxlKXtcbiAgICAgICAgICAgIHZhciBjdnMgPSB0aGlzLm5vZGUuZ2V0Q29tcG9uZW50KGNjLkNhbnZhcyk7XG4gICAgICAgICAgICBjdnMuZml0SGVpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGN2cy5maXRXaWR0aCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYoIWNjLnZ2KXtcbiAgICAgICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcImxvYWRpbmdcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoXCJOb3RpY2VUaXBcIik7XG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiR2FtZU92ZXJcIik7XG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiRGluZ1F1ZVwiKTtcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoXCJQZW5nR2FuZ3NcIik7XG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiTUpSb29tXCIpO1xuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChcIlRpbWVQb2ludGVyXCIpO1xuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChcIkdhbWVSZXN1bHRcIik7XG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiQ2hhdFwiKTtcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoXCJGb2xkc1wiKTtcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoXCJSZXBsYXlDdHJsXCIpO1xuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChcIlBvcHVwTWdyXCIpO1xuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChcIkh1YW5TYW5aaGFuZ1wiKTtcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoXCJSZUNvbm5lY3RcIik7XG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiVm9pY2VcIik7XG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KFwiVXNlckluZm9TaG93XCIpO1xuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChcIkFsZXJ0XCIpO1xuICAgICAgICB0aGlzLmluaXRWaWV3KCk7XG4gICAgICAgIHRoaXMuaW5pdEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZ2FtZVJvb3QuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlcGFyZVJvb3QuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbml0V2FuZmFMYWJlbCgpO1xuICAgICAgICB0aGlzLm9uR2FtZUJlaWduKCk7XG4gICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBsYXlCR00oXCJiZ01haW4ubXAzXCIpO1xuICAgICAgICBcbiAgICAgICAgLy/mt6HlhaVcbiAgICAgICAgLy8gdmFyIGZhZGVpbiA9IGNjLmZhZGVJbigwLjEpO1xuICAgICAgICAvLyB0aGlzLm5vZGUucnVuQWN0aW9uKGZhZGVpbik7XG4gICAgfSxcbiAgICBcbiAgICBpbml0VmlldzpmdW5jdGlvbigpe1xuICAgICAgICBcbiAgICAgICAgLy/mkJzntKLpnIDopoHnmoTlrZDoioLngrlcbiAgICAgICAgdmFyIGdhbWVDaGlsZCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIik7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9tamNvdW50ID0gZ2FtZUNoaWxkLmdldENoaWxkQnlOYW1lKCdtamNvdW50JykuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcbiAgICAgICAgaWYodGhpcy5fbWpjb3VudD4wKXtcbiAgICAgICAgICAgIHRoaXMuX21qY291bnQuc3RyaW5nID0gXCLliankvZlcIiArIGNjLnZ2LmdhbWVOZXRNZ3IubnVtT2ZNSiArIFwi5bygXCI7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5fbWpjb3VudC5zdHJpbmcgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2dhbWVjb3VudCA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZSgnZ2FtZWNvdW50JykuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcbiAgICAgICAgc3dpdGNoKGNjLnZ2LmdhbWVOZXRNZ3IuZmVuZ3hpYW5nKSB7XG4gICAgICAgICAgICBjYXNlIDA6IFxuICAgICAgICAgICAgICAgIHRoaXMuX2dhbWVjb3VudC5zdHJpbmcgPSBcIuS4nOmjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOiBcbiAgICAgICAgICAgICAgICB0aGlzLl9nYW1lY291bnQuc3RyaW5nID0gXCLljZfpo47lnIhcIjticmVhaztcbiAgICAgICAgICAgIGNhc2UgMjogXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2FtZWNvdW50LnN0cmluZyA9IFwi6KW/6aOO5ZyIXCI7YnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6IFxuICAgICAgICAgICAgICAgIHRoaXMuX2dhbWVjb3VudC5zdHJpbmcgPSBcIuWMl+mjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLl9nYW1lY291bnQuc3RyaW5nID0gXCJcIjticmVhaztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2dhbWV0eXBlID0gZ2FtZUNoaWxkLmdldENoaWxkQnlOYW1lKCdnYW1ldHlwZScpO1xuICAgICAgICBzd2l0Y2ggKGNjLnZ2LmdhbWVOZXRNZ3IuY29uZi50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwic2ptbWpcIiA6ICB0aGlzLl9nYW1ldHlwZS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwi5rKI5a626Zeo6bq75bCGXCI7YnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZGhtalwiIDogIHRoaXMuX2dhbWV0eXBlLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gXCLlrprmtbfpurvlsIZcIjticmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0ZGhcIiA6ICB0aGlzLl9nYW1ldHlwZS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwi5o6o5Yiw6IOhXCI7YnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgICAgIFxuXG4gICAgICAgIHZhciBteXNlbGZDaGlsZCA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShcIm15c2VsZlwiKTtcbiAgICAgICAgdmFyIG15aG9sZHMgPSBteXNlbGZDaGlsZC5nZXRDaGlsZEJ5TmFtZShcImhvbGRzXCIpO1xuICAgICAgICBcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG15aG9sZHMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG15aG9sZHMuY2hpbGRyZW5baV0uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XG4gICAgICAgICAgICB0aGlzLl9teU1KQXJyLnB1c2goc3ByaXRlKTtcbiAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciByZWFsd2lkdGggPSBjYy5kaXJlY3Rvci5nZXRWaXNpYmxlU2l6ZSgpLndpZHRoO1xuICAgICAgICBteWhvbGRzLnNjYWxlWCAqPSByZWFsd2lkdGgvMTI4MDtcbiAgICAgICAgbXlob2xkcy5zY2FsZVkgKj0gcmVhbHdpZHRoLzEyODA7ICBcbiAgICAgICAgXG4gICAgICAgIHZhciBzaWRlcyA9IFtcIm15c2VsZlwiLFwicmlnaHRcIixcInVwXCIsXCJsZWZ0XCJdO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2lkZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIHNpZGUgPSBzaWRlc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHNpZGVDaGlsZCA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShzaWRlKTtcbiAgICAgICAgICAgIHRoaXMuX2h1cGFpVGlwcy5wdXNoKHNpZGVDaGlsZC5nZXRDaGlsZEJ5TmFtZShcIkh1UGFpXCIpKTtcbiAgICAgICAgICAgIHRoaXMuX2h1cGFpTGlzdHMucHVzaChzaWRlQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJodXBhaWxpc3RcIikpO1xuICAgICAgICAgICAgdGhpcy5fcGxheUVmeHMucHVzaChzaWRlQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJwbGF5X2VmeFwiKS5nZXRDb21wb25lbnQoY2MuQW5pbWF0aW9uKSk7XG4gICAgICAgICAgICB0aGlzLl9jaHVwYWlTcHJpdGUucHVzaChzaWRlQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJDaHVQYWlcIikuY2hpbGRyZW5bMF0uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgb3B0ID0gc2lkZUNoaWxkLmdldENoaWxkQnlOYW1lKFwib3B0XCIpO1xuICAgICAgICAgICAgb3B0LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG9wdC5nZXRDaGlsZEJ5TmFtZShcInBhaVwiKS5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgICAgIG5vZGU6b3B0LFxuICAgICAgICAgICAgICAgIHNwcml0ZTpzcHJpdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9vcHRzLnB1c2goZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBvcHRzID0gZ2FtZUNoaWxkLmdldENoaWxkQnlOYW1lKFwib3BzXCIpO1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0cztcbiAgICAgICAgdGhpcy5oaWRlT3B0aW9ucygpO1xuICAgICAgICB0aGlzLmhpZGVDaHVwYWkoKTtcbiAgICB9LFxuICAgIFxuICAgIGhpZGVDaHVwYWk6ZnVuY3Rpb24oKXtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2NodXBhaVNwcml0ZS5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB0aGlzLl9jaHVwYWlTcHJpdGVbaV0ubm9kZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBpbml0RXZlbnRIYW5kbGVyczpmdW5jdGlvbigpe1xuICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRhdGFFdmVudEhhbmRsZXIgPSB0aGlzLm5vZGU7XG4gICAgICAgIFxuICAgICAgICAvL+WIneWni+WMluS6i+S7tuebkeWQrOWZqFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfaG9sZHMnLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICBzZWxmLmluaXRNYWhqb25ncygpO1xuICAgICAgICAgICBzZWxmLmNoZWNrUXVlWWlNZW4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfYmVnaW4nLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgc2VsZi5wbGF5U2hhemkoKTtcbiAgICAgICAgICAgIHNlbGYub25HYW1lQmVpZ24oZGF0YSk7XG4gICAgICAgICAgICBcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfc3luYycsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLm9uR2FtZUJlaWduKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9jaHVwYWknLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEuZGV0YWlsO1xuICAgICAgICAgICAgc2VsZi5oaWRlQ2h1cGFpKCk7XG4gICAgICAgICAgICBzZWxmLmNoZWNrUXVlWWlNZW4oKTtcbiAgICAgICAgICAgIGlmKGRhdGEubGFzdCAhPSBjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleCl7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0TW9wYWkoZGF0YS5sYXN0LG51bGwpOyAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIWNjLnZ2LnJlcGxheU1nci5pc1JlcGxheSgpICYmIGRhdGEudHVybiAhPSBjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleCl7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0TW9wYWkoZGF0YS50dXJuLC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfbW9wYWknLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgc2VsZi5oaWRlQ2h1cGFpKCk7XG4gICAgICAgICAgICBkYXRhID0gZGF0YS5kZXRhaWw7XG4gICAgICAgICAgICB2YXIgcGFpID0gZGF0YS5wYWk7XG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChkYXRhLnNlYXRJbmRleCk7XG4gICAgICAgICAgICBpZihsb2NhbEluZGV4ID09IDApe1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IDEzO1xuICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSBzZWxmLl9teU1KQXJyW2luZGV4XTtcbiAgICAgICAgICAgICAgICBzZWxmLnNldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixzcHJpdGUscGFpLGluZGV4KTtcbiAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5taklkID0gcGFpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoY2MudnYucmVwbGF5TWdyLmlzUmVwbGF5KCkpe1xuICAgICAgICAgICAgICAgIHNlbGYuaW5pdE1vcGFpKGRhdGEuc2VhdEluZGV4LHBhaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2FjdGlvbicsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLnNob3dBY3Rpb24oZGF0YS5kZXRhaWwpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJnYW1lX2FjdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyB0aGlzLm5vZGUub24oJ2dhbWVfZmVuZycsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIC8vICAgICBzZWxmLl9nYW1lY291bnRcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwiZ2FtZV9mZW5nXCIpO1xuICAgICAgICAvLyB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5vbignaHVwYWknLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcbiAgICAgICAgICAgIC8v5aaC5p6c5LiN5piv546p5a626Ieq5bex77yM5YiZ5bCG546p5a6255qE54mM6YO95pS+5YCSXG4gICAgICAgICAgICB2YXIgc2VhdEluZGV4ID0gZGF0YS5zZWF0aW5kZXg7XG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChzZWF0SW5kZXgpO1xuICAgICAgICAgICAgdmFyIGh1cGFpID0gc2VsZi5faHVwYWlUaXBzW2xvY2FsSW5kZXhdO1xuICAgICAgICAgICAgaHVwYWkuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYobG9jYWxJbmRleCA9PSAwKXtcbiAgICAgICAgICAgICAgICBzZWxmLmhpZGVPcHRpb25zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VhdERhdGEgPSBjYy52di5nYW1lTmV0TWdyLnNlYXRzW3NlYXRJbmRleF07XG4gICAgICAgICAgICBzZWF0RGF0YS5odWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuY29uZi50eXBlID09IFwieGxjaFwiKXtcbiAgICAgICAgICAgICAgICBodXBhaS5nZXRDaGlsZEJ5TmFtZShcInNwckh1XCIpLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaHVwYWkuZ2V0Q2hpbGRCeU5hbWUoXCJzcHJaaW1vXCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNlbGYuaW5pdEh1cGFpKGxvY2FsSW5kZXgsZGF0YS5odXBhaSk7XG4gICAgICAgICAgICAgICAgaWYoZGF0YS5pc3ppbW8pe1xuICAgICAgICAgICAgICAgICAgICBpZihzZWF0RGF0YS5zZWF0aW5kZXggPT0gY2MudnYuZ2FtZU5ldE1nci5zZWF0SW5kZXgpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VhdERhdGEuaG9sZHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmluaXRNYWhqb25ncygpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5pbml0T3RoZXJNYWhqb25ncyhzZWF0RGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBodXBhaS5nZXRDaGlsZEJ5TmFtZShcInNwckh1XCIpLmFjdGl2ZSA9ICFkYXRhLmlzemltbztcbiAgICAgICAgICAgICAgICBodXBhaS5nZXRDaGlsZEJ5TmFtZShcInNwclppbW9cIikuYWN0aXZlID0gZGF0YS5pc3ppbW87XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIShkYXRhLmlzemltbyAmJiBsb2NhbEluZGV4PT0wKSlcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vaWYoY2MudnYucmVwbGF5TWdyLmlzUmVwbGF5KCkgPT0gZmFsc2UgJiYgbG9jYWxJbmRleCAhPSAwKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgc2VsZi5pbml0RW1wdHlTcHJpdGVzKHNlYXRJbmRleCk7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL31cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pbml0TW9wYWkoc2VhdEluZGV4LGRhdGEuaHVwYWkpO1xuICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihjYy52di5yZXBsYXlNZ3IuaXNSZXBsYXkoKSA9PSB0cnVlICYmIGNjLnZ2LmdhbWVOZXRNZ3IuY29uZi50eXBlICE9IFwieGxjaFwiKXtcbiAgICAgICAgICAgICAgICB2YXIgb3B0ID0gc2VsZi5fb3B0c1tsb2NhbEluZGV4XTtcbiAgICAgICAgICAgICAgICBvcHQubm9kZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9wdC5zcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixkYXRhLmh1cGFpKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGRhdGEuaXN6aW1vKXtcbiAgICAgICAgICAgICAgICBzZWxmLnBsYXlFZngobG9jYWxJbmRleCxcInBsYXlfemltb1wiKTsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHNlbGYucGxheUVmeChsb2NhbEluZGV4LFwicGxheV9odVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2MudnYuYXVkaW9NZ3IucGxheVNGWChcIm52L2h1Lm1wM1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ21qX2NvdW50JyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHNlbGYuX21qY291bnQuc3RyaW5nID0gXCLliankvZlcIiArIGNjLnZ2LmdhbWVOZXRNZ3IubnVtT2ZNSiArIFwi5bygXCI7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX251bScsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdnYW1lX251bSEhISEhISEhISEnK2NjLnZ2LmdhbWVOZXRNZ3IuZmVuZ3hpYW5nKTtcbiAgICAgICAgICAgIC8vIHN3aXRjaChjYy52di5nYW1lTmV0TWdyLmZlbmd4aWFuZykge1xuICAgICAgICAgICAgLy8gICAgIGNhc2UgMDogXG4gICAgICAgICAgICAvLyAgICAgICAgIHNlbGYuX2dhbWVjb3VudC5zdHJpbmcgPSBcIuS4nOmjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgLy8gICAgIGNhc2UgMTogXG4gICAgICAgICAgICAvLyAgICAgICAgIHNlbGYuX2dhbWVjb3VudC5zdHJpbmcgPSBcIuWNl+mjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgLy8gICAgIGNhc2UgMjogXG4gICAgICAgICAgICAvLyAgICAgICAgIHNlbGYuX2dhbWVjb3VudC5zdHJpbmcgPSBcIuilv+mjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgLy8gICAgIGNhc2UgMzogXG4gICAgICAgICAgICAvLyAgICAgICAgIHNlbGYuX2dhbWVjb3VudC5zdHJpbmcgPSBcIuWMl+mjjuWciFwiO2JyZWFrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2ZlbmcnLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dhbWVfbnVtISEhISEhISEhIScrY2MudnYuZ2FtZU5ldE1nci5mZW5neGlhbmcpO1xuICAgICAgICAgICAgc3dpdGNoKGNjLnZ2LmdhbWVOZXRNZ3IuZmVuZ3hpYW5nKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZ2FtZWNvdW50LnN0cmluZyA9IFwi5Lic6aOO5ZyIXCI7YnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxOiBcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZ2FtZWNvdW50LnN0cmluZyA9IFwi5Y2X6aOO5ZyIXCI7YnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiBcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZ2FtZWNvdW50LnN0cmluZyA9IFwi6KW/6aOO5ZyIXCI7YnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOiBcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZ2FtZWNvdW50LnN0cmluZyA9IFwi5YyX6aOO5ZyIXCI7YnJlYWs7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfb3ZlcicsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLmdhbWVSb290LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZi5wcmVwYXJlUm9vdC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfY2h1cGFpX25vdGlmeScsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLmhpZGVDaHVwYWkoKTtcbiAgICAgICAgICAgIHZhciBzZWF0RGF0YSA9IGRhdGEuZGV0YWlsLnNlYXREYXRhO1xuICAgICAgICAgICAgLy/lpoLmnpzmmK/oh6rlt7HvvIzliJnliLfmlrDmiYvniYxcbiAgICAgICAgICAgIGlmKHNlYXREYXRhLnNlYXRpbmRleCA9PSBjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleCl7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0TWFoam9uZ3MoKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHNlbGYuaW5pdE90aGVyTWFoam9uZ3Moc2VhdERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5zaG93Q2h1cGFpKCk7XG4gICAgICAgICAgICB2YXIgYXVkaW9VcmwgPSBjYy52di5tYWhqb25nbWdyLmdldEF1ZGlvVVJMQnlNSklEKGRhdGEuZGV0YWlsLnBhaSk7XG4gICAgICAgICAgICBjYy52di5hdWRpb01nci5wbGF5U0ZYKGF1ZGlvVXJsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5vbignZ3VvX25vdGlmeScsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLmhpZGVDaHVwYWkoKTtcbiAgICAgICAgICAgIHNlbGYuaGlkZU9wdGlvbnMoKTtcbiAgICAgICAgICAgIHZhciBzZWF0RGF0YSA9IGRhdGEuZGV0YWlsO1xuICAgICAgICAgICAgLy/lpoLmnpzmmK/oh6rlt7HvvIzliJnliLfmlrDmiYvniYxcbiAgICAgICAgICAgIGlmKHNlYXREYXRhLnNlYXRpbmRleCA9PSBjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleCl7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0TWFoam9uZ3MoKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYy52di5hdWRpb01nci5wbGF5U0ZYKFwiZ2l2ZS5tcDNcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdndW9fcmVzdWx0JyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHNlbGYuaGlkZU9wdGlvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfZGluZ3F1ZV9maW5pc2gnLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgc2VsZi5pbml0TWFoam9uZ3MoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ3Blbmdfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXsgICAgXG4gICAgICAgICAgICBzZWxmLmhpZGVDaHVwYWkoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHNlYXREYXRhID0gZGF0YS5kZXRhaWw7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncGVuZ19ub3RpZnknKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgICAgaWYoc2VhdERhdGEuc2VhdGluZGV4ID09IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4KXtcbiAgICAgICAgICAgICAgICBzZWxmLmluaXRNYWhqb25ncygpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0T3RoZXJNYWhqb25ncyhzZWF0RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IHNlbGYuZ2V0TG9jYWxJbmRleChzZWF0RGF0YS5zZWF0aW5kZXgpO1xuICAgICAgICAgICAgc2VsZi5wbGF5RWZ4KGxvY2FsSW5kZXgsXCJwbGF5X3BlbmdcIik7XG4gICAgICAgICAgICBjYy52di5hdWRpb01nci5wbGF5U0ZYKFwibnYvcGVuZy5tcDNcIik7XG4gICAgICAgICAgICBzZWxmLmhpZGVPcHRpb25zKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdjaGlfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXsgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnY2hpX25vdGlmeScpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICBzZWxmLmhpZGVDaHVwYWkoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHNlYXREYXRhID0gZGF0YS5kZXRhaWw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgICAgaWYoc2VhdERhdGEuc2VhdGluZGV4ID09IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4KXtcbiAgICAgICAgICAgICAgICBzZWxmLmluaXRNYWhqb25ncygpOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0T3RoZXJNYWhqb25ncyhzZWF0RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IHNlbGYuZ2V0TG9jYWxJbmRleChzZWF0RGF0YS5zZWF0aW5kZXgpO1xuICAgICAgICAgICAgc2VsZi5wbGF5RWZ4KGxvY2FsSW5kZXgsXCJwbGF5X2NoaVwiKTtcbiAgICAgICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBsYXlTRlgoXCJudi9jaGkubXAzXCIpO1xuICAgICAgICAgICAgc2VsZi5oaWRlT3B0aW9ucygpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5vbignYnVodWFfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXsgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYnVodWFfbm90aWZ5Jyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhLmRldGFpbC5ob2xkcyk7XG4gICAgICAgICAgICB2YXIgc2VhdERhdGEgPSBkYXRhLmRldGFpbDtcbiAgICAgICAgICAgIGlmKHNlYXREYXRhLnNlYXRpbmRleCA9PSBjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleCl7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0TWFoam9uZ3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0T3RoZXJNYWhqb25ncyhzZWF0RGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW5nX25vdGlmeScsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLmhpZGVDaHVwYWkoKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YS5kZXRhaWw7XG4gICAgICAgICAgICB2YXIgc2VhdERhdGEgPSBkYXRhLnNlYXREYXRhO1xuICAgICAgICAgICAgdmFyIGdhbmd0eXBlID0gZGF0YS5nYW5ndHlwZTtcbiAgICAgICAgICAgIGlmKHNlYXREYXRhLnNlYXRpbmRleCA9PSBjYy52di5nYW1lTmV0TWdyLnNlYXRJbmRleCl7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0TWFoam9uZ3MoKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHNlbGYuaW5pdE90aGVyTWFoam9uZ3Moc2VhdERhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IHNlbGYuZ2V0TG9jYWxJbmRleChzZWF0RGF0YS5zZWF0aW5kZXgpO1xuICAgICAgICAgICAgaWYoZ2FuZ3R5cGUgPT0gXCJ3YW5nYW5nXCIpe1xuICAgICAgICAgICAgICAgIHNlbGYucGxheUVmeChsb2NhbEluZGV4LFwicGxheV9nYW5nXCIpO1xuICAgICAgICAgICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBsYXlTRlgoXCJndWFmZW5nLm1wM1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgc2VsZi5wbGF5RWZ4KGxvY2FsSW5kZXgsXCJwbGF5X2dhbmdcIik7XG4gICAgICAgICAgICAgICAgY2MudnYuYXVkaW9NZ3IucGxheVNGWChcInJhaW4ubXAzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5vbihcImhhbmdhbmdfbm90aWZ5XCIsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGEuZGV0YWlsO1xuICAgICAgICAgICAgdmFyIGxvY2FsSW5kZXggPSBzZWxmLmdldExvY2FsSW5kZXgoZGF0YSk7XG4gICAgICAgICAgICBzZWxmLnBsYXlFZngobG9jYWxJbmRleCxcInBsYXlfZ2FuZ1wiKTtcbiAgICAgICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBsYXlTRlgoXCJudi9nYW5nLm1wM1wiKTtcbiAgICAgICAgICAgIHNlbGYuaGlkZU9wdGlvbnMoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBcbiAgICBzaG93Q2h1cGFpOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBwYWkgPSBjYy52di5nYW1lTmV0TWdyLmNodXBhaTsgXG4gICAgICAgIGlmKCBwYWkgPj0gMCApe1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHZhciBsb2NhbEluZGV4ID0gdGhpcy5nZXRMb2NhbEluZGV4KGNjLnZ2LmdhbWVOZXRNZ3IudHVybik7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5fY2h1cGFpU3ByaXRlW2xvY2FsSW5kZXhdO1xuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIscGFpKTtcbiAgICAgICAgICAgIHNwcml0ZS5ub2RlLmFjdGl2ZSA9IHRydWU7ICAgXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGFkZE9wdGlvbjpmdW5jdGlvbihidG5OYW1lLHBhaSxjaGl0eXBlKXtcbiAgICAgICAgY29uc29sZS5sb2coXCLlvLnlh7rmk43kvZzmoYZcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKGJ0bk5hbWUpO1xuICAgICAgICBjb25zb2xlLmxvZyhwYWkpO1xuICAgICAgICAvL+a3u+WKoOWQg+eJjOeahOS4ieenjeaWueW8j1xuICAgICAgICAvL3ZhciBzdHIgPSBwYWkuc3BsaXQoXCJfXCIpO1xuICAgICAgICAvL3ZhciBwYWluYW1lID0gc3RyWzBdO1xuICAgICAgIC8vdmFyIHBhaW51bSA9IHN0clsxXTtcbiAgICAgICAgaWYoY2hpdHlwZSAmJiBjaGl0eXBlLmxlZnQgPT0gdHJ1ZSl7XG4gICAgICAgICAgICB2YXIgb3AgPSB0aGlzLl9vcHRpb25zLmdldENoaWxkQnlOYW1lKFwiY2hpb3BcIikuZ2V0Q2hpbGRCeU5hbWUoXCJsZWZ0XCIpO1xuICAgICAgICAgICAgb3AuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBvcC5jaGlsZHJlblswXS5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcbiAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQoXCJNX1wiLHBhaSk7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gb3AuY2hpbGRyZW5bMV0uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XG4gICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixwYWkrMSk7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gb3AuY2hpbGRyZW5bMl0uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XG4gICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixwYWkrMik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNoaXR5cGUgJiYgY2hpdHlwZS5taWQgPT0gdHJ1ZSl7XG4gICAgICAgICAgICB2YXIgb3AgPSB0aGlzLl9vcHRpb25zLmdldENoaWxkQnlOYW1lKFwiY2hpb3BcIikuZ2V0Q2hpbGRCeU5hbWUoXCJtaWRcIik7XG4gICAgICAgICAgICBvcC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG9wLmNoaWxkcmVuWzBdLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIscGFpLTEpO1xuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG9wLmNoaWxkcmVuWzFdLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChcIk1fXCIscGFpKTtcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBvcC5jaGlsZHJlblsyXS5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcbiAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQoXCJNX1wiLHBhaSsxKTtcbiAgICAgICAgfVxuICAgICAgICBpZihjaGl0eXBlICYmIGNoaXR5cGUucmlnaHQgPT0gdHJ1ZSl7XG4gICAgICAgICAgICB2YXIgb3AgPSB0aGlzLl9vcHRpb25zLmdldENoaWxkQnlOYW1lKFwiY2hpb3BcIikuZ2V0Q2hpbGRCeU5hbWUoXCJyaWdodFwiKTtcbiAgICAgICAgICAgIG9wLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gb3AuY2hpbGRyZW5bMF0uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XG4gICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixwYWktMik7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gb3AuY2hpbGRyZW5bMV0uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XG4gICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixwYWktMSk7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gb3AuY2hpbGRyZW5bMl0uZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XG4gICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixwYWkpO1xuICAgICAgICB9XG4gICAgICAgIC8v5YW25LuWXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9vcHRpb25zLmNoaWxkcmVuQ291bnQ7ICsraSl7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9vcHRpb25zLmNoaWxkcmVuW2ldOyBcbiAgICAgICAgICAgIGlmKGNoaWxkLm5hbWUgPT0gXCJvcFwiICYmIGNoaWxkLmFjdGl2ZSA9PSBmYWxzZSl7XG4gICAgICAgICAgICAgICAgY2hpbGQuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gY2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJvcFRhcmdldFwiKS5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcbiAgICAgICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixwYWkpO1xuICAgICAgICAgICAgICAgIHZhciBidG4gPSBjaGlsZC5nZXRDaGlsZEJ5TmFtZShidG5OYW1lKTsgXG4gICAgICAgICAgICAgICAgYnRuLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnRuLnBhaSA9IHBhaTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGhpZGVPcHRpb25zOmZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICB0aGlzLl9vcHRpb25zLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3B0aW9ucy5jaGlsZHJlbkNvdW50OyArK2kpe1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5fb3B0aW9ucy5jaGlsZHJlbltpXTsgXG4gICAgICAgICAgICBpZihjaGlsZC5uYW1lID09IFwib3BcIiApe1xuICAgICAgICAgICAgICAgIGNoaWxkLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNoaWxkLmdldENoaWxkQnlOYW1lKFwiYnRuUGVuZ1wiKS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjaGlsZC5nZXRDaGlsZEJ5TmFtZShcImJ0bkdhbmdcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJidG5IdVwiKS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjaGlsZC5nZXRDaGlsZEJ5TmFtZShcImJ0bkNoaVwiKS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGNoaWxkLm5hbWUgPT0gXCJjaGlvcFwiICl7XG4gICAgICAgICAgICAgICAgY2hpbGQuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJsZWZ0XCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNoaWxkLmdldENoaWxkQnlOYW1lKFwibWlkXCIpLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNoaWxkLmdldENoaWxkQnlOYW1lKFwicmlnaHRcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNob3dBY3Rpb246ZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIGNvbnNvbGUubG9nKFwic2hvdyBhY3Rpb25cIik7XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuX29wdGlvbnMuYWN0aXZlKTtcbiAgICAgICAgaWYodGhpcy5fb3B0aW9ucy5hY3RpdmUpe1xuICAgICAgICAgICAgdGhpcy5oaWRlT3B0aW9ucygpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihkYXRhICYmIChkYXRhLmh1IHx8IGRhdGEuZ2FuZyB8fCBkYXRhLnBlbmcgfHwgZGF0YS5jaGkpKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEuY2hpKTtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmKGRhdGEuaHUpe1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkT3B0aW9uKFwiYnRuSHVcIixkYXRhLnBhaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkYXRhLnBlbmcpe1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkT3B0aW9uKFwiYnRuUGVuZ1wiLGRhdGEucGFpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoZGF0YS5nYW5nKXtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZGF0YS5nYW5ncGFpLmxlbmd0aDsrK2kpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ3AgPSBkYXRhLmdhbmdwYWlbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkT3B0aW9uKFwiYnRuR2FuZ1wiLGdwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihkYXRhLmNoaSl7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRPcHRpb24oXCJidG5DaGlcIixkYXRhLnBhaSxkYXRhLmNoaXR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGRhdGEuY2hpKTtcbiAgICB9LFxuICAgIFxuICAgIGluaXRXYW5mYUxhYmVsOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciB3YW5mYSA9IGNjLmZpbmQoXCJDYW52YXMvaW5mb2Jhci93YW5mYVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xuICAgICAgICB3YW5mYS5zdHJpbmcgPSBjYy52di5nYW1lTmV0TWdyLmdldFdhbmZhKCk7XG4gICAgfSxcbiAgICBcbiAgICBpbml0SHVwYWk6ZnVuY3Rpb24obG9jYWxJbmRleCxwYWkpe1xuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLmNvbmYudHlwZSA9PSBcInhsY2hcIil7XG4gICAgICAgICAgICB2YXIgaHVwYWlsaXN0ID0gdGhpcy5faHVwYWlMaXN0c1tsb2NhbEluZGV4XTtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBodXBhaWxpc3QuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgIHZhciBodXBhaW5vZGUgPSBodXBhaWxpc3QuY2hpbGRyZW5baV07IFxuICAgICAgICAgICAgICAgIGlmKGh1cGFpbm9kZS5hY3RpdmUgPT0gZmFsc2Upe1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJlID0gY2MudnYubWFoam9uZ21nci5nZXRGb2xkUHJlKGxvY2FsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBodXBhaW5vZGUuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSkuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKHByZSxwYWkpO1xuICAgICAgICAgICAgICAgICAgICBodXBhaW5vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSAgIFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBwbGF5RWZ4OmZ1bmN0aW9uKGluZGV4LG5hbWUpe1xuICAgICAgICB0aGlzLl9wbGF5RWZ4c1tpbmRleF0ubm9kZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wbGF5RWZ4c1tpbmRleF0ucGxheShuYW1lKTtcbiAgICB9LFxuICAgIFxuICAgIHBsYXlTaGF6aTpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYW5pbTEgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJnYW1lXCIpLmdldENoaWxkQnlOYW1lKFwic2hhaXppXCIpLmdldENoaWxkQnlOYW1lKFwic2hhaXppMVwiKS5nZXRDb21wb25lbnQoY2MuQW5pbWF0aW9uKTtcbiAgICAgICAgYW5pbTEucGxheShcInNoYWl6aVwiKTtcbiAgICAgICAgdmFyIGFuaW0yID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKS5nZXRDaGlsZEJ5TmFtZShcInNoYWl6aVwiKS5nZXRDaGlsZEJ5TmFtZShcInNoYWl6aTJcIikuZ2V0Q29tcG9uZW50KGNjLkFuaW1hdGlvbik7XG4gICAgICAgIGFuaW0yLnBsYXkoXCJzaGFpemkyXCIpO1xuICAgICAgICB0aGlzLm9uZmluaXNoZWQoZmFsc2UpO1xuICAgICAgICBhbmltMi5vbihcImZpbmlzaGVkXCIsdGhpcy5vbmZpbmlzaGVkLHRoaXMpO1xuICAgIH0sXG4gICAgXG4gICAgb25maW5pc2hlZDpmdW5jdGlvbihpc3Nob3cpIHtcbiAgICAgICAgdmFyIHNob3cgPSB0cnVlO1xuICAgICAgICAoaXNzaG93PT1mYWxzZSkgPyBzaG93ID0gZmFsc2U6e307XG4gICAgICAgIHZhciBzaWRlID0gIHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIikuZ2V0Q2hpbGRCeU5hbWUoXCJteXNlbGZcIik7XG4gICAgICAgIHNpZGUuZ2V0Q2hpbGRCeU5hbWUoXCJodWFzXCIpLmFjdGl2ZSA9IHNob3c7XG4gICAgICAgIHNpZGUuZ2V0Q2hpbGRCeU5hbWUoXCJob2xkc1wiKS5hY3RpdmUgPSBzaG93O1xuICAgICAgICB2YXIgc2lkZSA9ICB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJnYW1lXCIpLmdldENoaWxkQnlOYW1lKFwibGVmdFwiKTtcbiAgICAgICAgc2lkZS5nZXRDaGlsZEJ5TmFtZShcImh1YXNcIikuYWN0aXZlID0gc2hvdztcbiAgICAgICAgc2lkZS5nZXRDaGlsZEJ5TmFtZShcImhvbGRzXCIpLmFjdGl2ZSA9IHNob3c7XG4gICAgICAgIHZhciBzaWRlID0gIHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIikuZ2V0Q2hpbGRCeU5hbWUoXCJ1cFwiKTtcbiAgICAgICAgc2lkZS5nZXRDaGlsZEJ5TmFtZShcImh1YXNcIikuYWN0aXZlID0gc2hvdztcbiAgICAgICAgc2lkZS5nZXRDaGlsZEJ5TmFtZShcImhvbGRzXCIpLmFjdGl2ZSA9IHNob3c7XG4gICAgICAgIHZhciBzaWRlID0gIHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIikuZ2V0Q2hpbGRCeU5hbWUoXCJyaWdodFwiKTtcbiAgICAgICAgc2lkZS5nZXRDaGlsZEJ5TmFtZShcImh1YXNcIikuYWN0aXZlID0gc2hvdztcbiAgICAgICAgc2lkZS5nZXRDaGlsZEJ5TmFtZShcImhvbGRzXCIpLmFjdGl2ZSA9IHNob3c7XG4gICAgfSxcbiAgICBcbiAgICBvbkdhbWVCZWlnbjpmdW5jdGlvbigpe1xuICAgICAgICBcbiAgICAgICAgLy/mm7TmjaJnYW1lb3ZlcueVjOmdouWktOWDjyDmh5LlvpflsIHoo4XkuobvvIzlj43mraPku6XlkI7kuZ/nlKjkuI3liLBcbiAgICAgICAgdmFyIHNwckljb24gPSBjYy5maW5kKFwiQ2FudmFzL2dhbWVfb3Zlcl9zam1tai9yZXN1bHRfbGlzdC9zMS90b3V4aWFuZ1wiKS5nZXRDb21wb25lbnQoXCJJbWFnZUxvYWRlclwiKTtcbiAgICAgICAgaWYoc3BySWNvbiAmJiBjYy52di5nYW1lTmV0TWdyLnNlYXRzWzBdLnVzZXJpZClzcHJJY29uLnNldFVzZXJJRChjYy52di5nYW1lTmV0TWdyLnNlYXRzWzBdLnVzZXJpZCk7XG4gICAgICAgIHZhciBzcHJJY29uID0gY2MuZmluZChcIkNhbnZhcy9nYW1lX292ZXJfc2ptbWovcmVzdWx0X2xpc3QvczIvdG91eGlhbmdcIikuZ2V0Q29tcG9uZW50KFwiSW1hZ2VMb2FkZXJcIik7XG4gICAgICAgIGlmKHNwckljb24gJiYgY2MudnYuZ2FtZU5ldE1nci5zZWF0c1sxXS51c2VyaWQpc3BySWNvbi5zZXRVc2VySUQoY2MudnYuZ2FtZU5ldE1nci5zZWF0c1sxXS51c2VyaWQpO1xuICAgICAgICB2YXIgc3BySWNvbiA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZV9vdmVyX3NqbW1qL3Jlc3VsdF9saXN0L3MzL3RvdXhpYW5nXCIpLmdldENvbXBvbmVudChcIkltYWdlTG9hZGVyXCIpO1xuICAgICAgICBpZihzcHJJY29uICYmIGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHNbMl0udXNlcmlkKXNwckljb24uc2V0VXNlcklEKGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHNbMl0udXNlcmlkKTtcbiAgICAgICAgdmFyIHNwckljb24gPSBjYy5maW5kKFwiQ2FudmFzL2dhbWVfb3Zlcl9zam1tai9yZXN1bHRfbGlzdC9zNC90b3V4aWFuZ1wiKS5nZXRDb21wb25lbnQoXCJJbWFnZUxvYWRlclwiKTtcbiAgICAgICAgaWYoc3BySWNvbiAmJiBjYy52di5nYW1lTmV0TWdyLnNlYXRzWzNdLnVzZXJpZClzcHJJY29uLnNldFVzZXJJRChjYy52di5nYW1lTmV0TWdyLnNlYXRzWzNdLnVzZXJpZCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3BySWNvbiA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZV9vdmVyX2RobWovcmVzdWx0X2xpc3QvczEvdG91eGlhbmdcIikuZ2V0Q29tcG9uZW50KFwiSW1hZ2VMb2FkZXJcIik7XG4gICAgICAgIGlmKHNwckljb24gJiYgY2MudnYuZ2FtZU5ldE1nci5zZWF0c1swXS51c2VyaWQpc3BySWNvbi5zZXRVc2VySUQoY2MudnYuZ2FtZU5ldE1nci5zZWF0c1swXS51c2VyaWQpO1xuICAgICAgICB2YXIgc3BySWNvbiA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZV9vdmVyX2RobWovcmVzdWx0X2xpc3QvczIvdG91eGlhbmdcIikuZ2V0Q29tcG9uZW50KFwiSW1hZ2VMb2FkZXJcIik7XG4gICAgICAgIGlmKHNwckljb24gJiYgY2MudnYuZ2FtZU5ldE1nci5zZWF0c1sxXS51c2VyaWQpc3BySWNvbi5zZXRVc2VySUQoY2MudnYuZ2FtZU5ldE1nci5zZWF0c1sxXS51c2VyaWQpO1xuICAgICAgICB2YXIgc3BySWNvbiA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZV9vdmVyX2RobWovcmVzdWx0X2xpc3QvczMvdG91eGlhbmdcIikuZ2V0Q29tcG9uZW50KFwiSW1hZ2VMb2FkZXJcIik7XG4gICAgICAgIGlmKHNwckljb24gJiYgY2MudnYuZ2FtZU5ldE1nci5zZWF0c1syXS51c2VyaWQpc3BySWNvbi5zZXRVc2VySUQoY2MudnYuZ2FtZU5ldE1nci5zZWF0c1syXS51c2VyaWQpO1xuICAgICAgICB2YXIgc3BySWNvbiA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZV9vdmVyX2RobWovcmVzdWx0X2xpc3QvczQvdG91eGlhbmdcIikuZ2V0Q29tcG9uZW50KFwiSW1hZ2VMb2FkZXJcIik7XG4gICAgICAgIGlmKHNwckljb24gJiYgY2MudnYuZ2FtZU5ldE1nci5zZWF0c1szXS51c2VyaWQpc3BySWNvbi5zZXRVc2VySUQoY2MudnYuZ2FtZU5ldE1nci5zZWF0c1szXS51c2VyaWQpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHNwckljb24gPSBjYy5maW5kKFwiQ2FudmFzL2dhbWVfb3Zlcl90ZGgvcmVzdWx0X2xpc3QvczEvdG91eGlhbmdcIikuZ2V0Q29tcG9uZW50KFwiSW1hZ2VMb2FkZXJcIik7XG4gICAgICAgIGlmKHNwckljb24gJiYgY2MudnYuZ2FtZU5ldE1nci5zZWF0c1swXS51c2VyaWQpc3BySWNvbi5zZXRVc2VySUQoY2MudnYuZ2FtZU5ldE1nci5zZWF0c1swXS51c2VyaWQpO1xuICAgICAgICB2YXIgc3BySWNvbiA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZV9vdmVyX3RkaC9yZXN1bHRfbGlzdC9zMi90b3V4aWFuZ1wiKS5nZXRDb21wb25lbnQoXCJJbWFnZUxvYWRlclwiKTtcbiAgICAgICAgaWYoc3BySWNvbiAmJiBjYy52di5nYW1lTmV0TWdyLnNlYXRzWzFdLnVzZXJpZClzcHJJY29uLnNldFVzZXJJRChjYy52di5nYW1lTmV0TWdyLnNlYXRzWzFdLnVzZXJpZCk7XG4gICAgICAgIHZhciBzcHJJY29uID0gY2MuZmluZChcIkNhbnZhcy9nYW1lX292ZXJfdGRoL3Jlc3VsdF9saXN0L3MzL3RvdXhpYW5nXCIpLmdldENvbXBvbmVudChcIkltYWdlTG9hZGVyXCIpO1xuICAgICAgICBpZihzcHJJY29uICYmIGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHNbMl0udXNlcmlkKXNwckljb24uc2V0VXNlcklEKGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHNbMl0udXNlcmlkKTtcbiAgICAgICAgdmFyIHNwckljb24gPSBjYy5maW5kKFwiQ2FudmFzL2dhbWVfb3Zlcl90ZGgvcmVzdWx0X2xpc3QvczQvdG91eGlhbmdcIikuZ2V0Q29tcG9uZW50KFwiSW1hZ2VMb2FkZXJcIik7XG4gICAgICAgIGlmKHNwckljb24gJiYgY2MudnYuZ2FtZU5ldE1nci5zZWF0c1szXS51c2VyaWQpc3BySWNvbi5zZXRVc2VySUQoY2MudnYuZ2FtZU5ldE1nci5zZWF0c1szXS51c2VyaWQpO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9wbGF5RWZ4cy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB0aGlzLl9wbGF5RWZ4c1tpXS5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5faHVwYWlMaXN0cy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgdGhpcy5faHVwYWlMaXN0c1tpXS5jaGlsZHJlbkNvdW50OyArK2ope1xuICAgICAgICAgICAgICAgIHRoaXMuX2h1cGFpTGlzdHNbaV0uY2hpbGRyZW5bal0uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjYy52di5nYW1lTmV0TWdyLnNlYXRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBzZWF0RGF0YSA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHNbaV07XG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChpKTsgICAgICAgIFxuICAgICAgICAgICAgdmFyIGh1cGFpID0gdGhpcy5faHVwYWlUaXBzW2xvY2FsSW5kZXhdO1xuICAgICAgICAgICAgaHVwYWkuYWN0aXZlID0gc2VhdERhdGEuaHVlZDtcbiAgICAgICAgICAgIGlmKHNlYXREYXRhLmh1ZWQpe1xuICAgICAgICAgICAgICAgIGh1cGFpLmdldENoaWxkQnlOYW1lKFwic3BySHVcIikuYWN0aXZlID0gIXNlYXREYXRhLmlzemltbztcbiAgICAgICAgICAgICAgICBodXBhaS5nZXRDaGlsZEJ5TmFtZShcInNwclppbW9cIikuYWN0aXZlID0gc2VhdERhdGEuaXN6aW1vO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihzZWF0RGF0YS5odWluZm8pe1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBzZWF0RGF0YS5odWluZm8ubGVuZ3RoOyArK2ope1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5mbyA9IHNlYXREYXRhLmh1aW5mb1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYoaW5mby5pc2h1cGFpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdEh1cGFpKGxvY2FsSW5kZXgsaW5mby5wYWkpOyAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5oaWRlQ2h1cGFpKCk7XG4gICAgICAgIHRoaXMuaGlkZU9wdGlvbnMoKTtcbiAgICAgICAgdmFyIHNpZGVzID0gW1wicmlnaHRcIixcInVwXCIsXCJsZWZ0XCJdOyAgICAgICAgXG4gICAgICAgIHZhciBnYW1lQ2hpbGQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJnYW1lXCIpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2lkZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIHNpZGVDaGlsZCA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShzaWRlc1tpXSk7XG4gICAgICAgICAgICB2YXIgaG9sZHMgPSBzaWRlQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJob2xkc1wiKTtcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBob2xkcy5jaGlsZHJlbkNvdW50OyArK2ope1xuICAgICAgICAgICAgICAgIHZhciBuYyA9IGhvbGRzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgIG5jLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmMuc2NhbGVYID0gMS4wO1xuICAgICAgICAgICAgICAgIG5jLnNjYWxlWSA9IDEuMDtcbiAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gbmMuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7IFxuICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuaG9sZHNFbXB0eVtpKzFdO1xuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICBcbiAgICAgICAgaWYoY2MudnYuZ2FtZU5ldE1nci5nYW1lc3RhdGUgPT0gXCJcIiAmJiBjYy52di5yZXBsYXlNZ3IuaXNSZXBsYXkoKSA9PSBmYWxzZSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdhbWVSb290LmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMucHJlcGFyZVJvb3QuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5pdE1haGpvbmdzKCk7XG4gICAgICAgIHZhciBzZWF0cyA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHM7XG4gICAgICAgIGZvcih2YXIgaSBpbiBzZWF0cyl7XG4gICAgICAgICAgICB2YXIgc2VhdERhdGEgPSBzZWF0c1tpXTtcbiAgICAgICAgICAgIHZhciBsb2NhbEluZGV4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KGkpO1xuICAgICAgICAgICAgaWYobG9jYWxJbmRleCAhPSAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRPdGhlck1haGpvbmdzKHNlYXREYXRhKTtcbiAgICAgICAgICAgICAgICBpZihpID09IGNjLnZ2LmdhbWVOZXRNZ3IudHVybil7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5pdE1vcGFpKGksLTEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluaXRNb3BhaShpLG51bGwpOyAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaG93Q2h1cGFpKCk7XG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuY3VyYWN0aW9uICE9IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5zaG93QWN0aW9uKGNjLnZ2LmdhbWVOZXRNZ3IuY3VyYWN0aW9uKTtcbiAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuY3VyYWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5jaGVja1F1ZVlpTWVuKCk7XG4gICAgfSxcbiAgICBcbiAgICBvbk1KQ2xpY2tlZDpmdW5jdGlvbihldmVudCl7XG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuaXNIdWFuU2FuWmhhbmcpe1xuICAgICAgICAgICAgdGhpcy5ub2RlLmVtaXQoXCJtal9jbGlja2VkXCIsZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy/lpoLmnpzkuI3mmK/oh6rlt7HnmoTova7lrZDvvIzliJnlv73nlaVcbiAgICAgICAgaWYoY2MudnYuZ2FtZU5ldE1nci50dXJuICE9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4KXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibm90IHlvdXIgdHVybi5cIiArIGNjLnZ2LmdhbWVOZXRNZ3IudHVybik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9teU1KQXJyLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIGlmKGV2ZW50LnRhcmdldCA9PSB0aGlzLl9teU1KQXJyW2ldLm5vZGUpe1xuICAgICAgICAgICAgICAgIC8v5aaC5p6c5piv5YaN5qyh54K55Ye777yM5YiZ5Ye654mMXG4gICAgICAgICAgICAgICAgaWYoZXZlbnQudGFyZ2V0ID09IHRoaXMuX3NlbGVjdGVkTUope1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob290KHRoaXMuX3NlbGVjdGVkTUoubWpJZCk7IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZE1KLnkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZE1KID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy/lj5bmtojmmL7npLrmoYzpnaLkuIrnm7jlkIznmoTniYxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlU2FtZVR5cGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL+WmguaenOS4jeaYr+WImeaYvuekuuahjOmdouS4iuebuOWQjOeahOeJjFxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1NhbWVUeXBlKGV2ZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX3NlbGVjdGVkTUogIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkTUoueSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC55ID0gMTU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRNSiA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIC8v5pi+56S65qGM6Z2i5LiK55u45ZCM54mM55qE5Yqf6IO9XG4gICAgc2hvd1NhbWVUeXBlOmZ1bmN0aW9uKG1qKXtcbiAgICAgICAgdmFyIHNwcml0ZSA9IG1qLmdldENvbXBvbmVudChjYy5TcHJpdGUpOyBcbiAgICAgICAgLy/mj5Dlj5Zf5LmL5YmN55qE5YaF5a65XG4gICAgICAgIGZ1bmN0aW9uIGdldEVuZChtYWluU3RyLHNlYXJjaFN0cil7ICBcbiAgICAgICAgICAgIHZhciBmb3VuZE9mZnNldD1tYWluU3RyLmluZGV4T2Yoc2VhcmNoU3RyKTsgIFxuICAgICAgICAgICAgaWYoZm91bmRPZmZzZXQ9PS0xKXsgIFxuICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7ICBcbiAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgcmV0dXJuIG1haW5TdHIuc3Vic3RyaW5nKGZvdW5kT2Zmc2V0K3NlYXJjaFN0ci5sZW5ndGgsbWFpblN0ci5sZW5ndGgpOyAgXG4gICAgICAgIH0gXG4gICAgICAgIHZhciBtam5hbWUgPSBnZXRFbmQoc3ByaXRlLnNwcml0ZUZyYW1lLl9uYW1lLFwiX1wiKTtcbiAgICAgICAgLy/miYDmnIlmb2xkc1xuICAgICAgICB2YXIgYWxsZm9sZHMgPSBbXTtcbiAgICAgICAgYWxsZm9sZHMgPSBhbGxmb2xkcy5jb25jYXQoY2MuZmluZChcIkNhbnZhcy9nYW1lL3JpZ2h0L2ZvbGRzXCIpLmNoaWxkcmVuKTtcbiAgICAgICAgYWxsZm9sZHMgPSBhbGxmb2xkcy5jb25jYXQoY2MuZmluZChcIkNhbnZhcy9nYW1lL3VwL2ZvbGRzXCIpLmNoaWxkcmVuKTtcbiAgICAgICAgYWxsZm9sZHMgPSBhbGxmb2xkcy5jb25jYXQoY2MuZmluZChcIkNhbnZhcy9nYW1lL2xlZnQvZm9sZHNcIikuY2hpbGRyZW4pO1xuICAgICAgICBhbGxmb2xkcyA9IGFsbGZvbGRzLmNvbmNhdChjYy5maW5kKFwiQ2FudmFzL2dhbWUvbXlzZWxmL2ZvbGRzXCIpLmNoaWxkcmVuKTtcbiAgICAgICAgXG4gICAgICAgIC8vdmFyIGFhYSA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZS9teXNlbGYvcGVuZ2dhbmdzXCIpLmNoaWxkcmVuO1xuICAgICAgICBcbiAgICAgICAgLy92YXIgc3ByaXRlcyA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZS9teXNlbGYvcGVuZ2dhbmdzXCIpLmNoaWxkcmVuWzBdLmNoaWxkcmVuO1xuICAgICAgICB2YXIgcGdzID0gY2MuZmluZChcIkNhbnZhcy9nYW1lL215c2VsZi9wZW5nZ2FuZ3NcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHBncy5jaGlsZHJlbkNvdW50IDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm93cGcgPSBwZ3MuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBhbGxmb2xkcyA9IGFsbGZvbGRzLmNvbmNhdChub3dwZy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBncyA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZS9yaWdodC9wZW5nZ2FuZ3NcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHBncy5jaGlsZHJlbkNvdW50IDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm93cGcgPSBwZ3MuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBhbGxmb2xkcyA9IGFsbGZvbGRzLmNvbmNhdChub3dwZy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBncyA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZS91cC9wZW5nZ2FuZ3NcIik7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHBncy5jaGlsZHJlbkNvdW50IDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm93cGcgPSBwZ3MuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBhbGxmb2xkcyA9IGFsbGZvbGRzLmNvbmNhdChub3dwZy5jaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBncyA9IGNjLmZpbmQoXCJDYW52YXMvZ2FtZS9sZWZ0L3BlbmdnYW5nc1wiKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgcGdzLmNoaWxkcmVuQ291bnQgOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBub3dwZyA9IHBncy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGFsbGZvbGRzID0gYWxsZm9sZHMuY29uY2F0KG5vd3BnLmNoaWxkcmVuKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAgOyBpIDwgYWxsZm9sZHMubGVuZ3RoIDsgaSsrICkge1xuICAgICAgICAgICAgdmFyIG5vd3Nwcml0ZSA9IGFsbGZvbGRzW2ldLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xuICAgICAgICAgICAgaWYobm93c3ByaXRlLnNwcml0ZUZyYW1lKXtcbiAgICAgICAgICAgICAgICB2YXIgbm93bmFtZSA9IGdldEVuZChub3dzcHJpdGUuc3ByaXRlRnJhbWUuX25hbWUsXCJfXCIpO1xuICAgICAgICAgICAgICAgIGlmKG5vd25hbWUgPT0gbWpuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbGZvbGRzW2ldLmNvbG9yID0gbmV3IGNjLkNvbG9yKDE1NSwgMjI4LCAyMjgpO1xuICAgICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsZm9sZHNbaV0uY29sb3IgPSBuZXcgY2MuQ29sb3IoMjU1LCAyNTUsIDI1NSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICAvL+WPlua2iOaYvuekuuahjOmdouS4iuebuOWQjOeJjOeahOWKn+iDvVxuICAgIGhpZGVTYW1lVHlwZTpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYWxsZm9sZHMgPSBbXTtcbiAgICAgICAgYWxsZm9sZHMgPSBhbGxmb2xkcy5jb25jYXQoY2MuZmluZChcIkNhbnZhcy9nYW1lL3JpZ2h0L2ZvbGRzXCIpLmNoaWxkcmVuKTtcbiAgICAgICAgYWxsZm9sZHMgPSBhbGxmb2xkcy5jb25jYXQoY2MuZmluZChcIkNhbnZhcy9nYW1lL3VwL2ZvbGRzXCIpLmNoaWxkcmVuKTtcbiAgICAgICAgYWxsZm9sZHMgPSBhbGxmb2xkcy5jb25jYXQoY2MuZmluZChcIkNhbnZhcy9nYW1lL2xlZnQvZm9sZHNcIikuY2hpbGRyZW4pO1xuICAgICAgICBhbGxmb2xkcyA9IGFsbGZvbGRzLmNvbmNhdChjYy5maW5kKFwiQ2FudmFzL2dhbWUvbXlzZWxmL2ZvbGRzXCIpLmNoaWxkcmVuKTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwIDsgaSA8IGFsbGZvbGRzLmxlbmd0aCA7IGkrKyApIHtcbiAgICAgICAgICAgIHZhciBub3dzcHJpdGUgPSBhbGxmb2xkc1tpXS5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcbiAgICAgICAgICAgIGlmKG5vd3Nwcml0ZS5zcHJpdGVGcmFtZSl7XG4gICAgICAgICAgICAgICAgYWxsZm9sZHNbaV0uY29sb3IgPSBuZXcgY2MuQ29sb3IoMjU1LCAyNTUsIDI1NSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIC8v5aaC5p6c5pG45Yiw55qE54mM5piv6Iqx77yM5YiZ5Lya6LCD55So6L+Z5Liq5Ye95pWwXG4gICAgY2h1aHVhOmZ1bmN0aW9uKG1qaWQpe1xuICAgICAgICBjb25zb2xlLmxvZyhjaHVodWEpO1xuICAgIH0sXG4gICAgXG4gICAgLy/lh7rniYxcbiAgICBzaG9vdDpmdW5jdGlvbihtaklkKXtcbiAgICAgICAgaWYobWpJZCA9PSBudWxsKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYy52di5uZXQuc2VuZCgnY2h1cGFpJyxtaklkKTtcbiAgICB9LFxuICAgIFxuICAgIGdldE1KSW5kZXg6ZnVuY3Rpb24oc2lkZSxpbmRleCl7XG4gICAgICAgIGlmKHNpZGUgPT0gXCJyaWdodFwiIHx8IHNpZGUgPT0gXCJ1cFwiKXtcbiAgICAgICAgICAgIHJldHVybiAxMyAtIGluZGV4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuICAgIFxuICAgIGluaXRNb3BhaTpmdW5jdGlvbihzZWF0SW5kZXgscGFpKXtcbiAgICAgICAgdmFyIGxvY2FsSW5kZXggPSBjYy52di5nYW1lTmV0TWdyLmdldExvY2FsSW5kZXgoc2VhdEluZGV4KTtcbiAgICAgICAgdmFyIHNpZGUgPSBjYy52di5tYWhqb25nbWdyLmdldFNpZGUobG9jYWxJbmRleCk7XG4gICAgICAgIHZhciBwcmUgPSBjYy52di5tYWhqb25nbWdyLmdldEZvbGRQcmUobG9jYWxJbmRleCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgZ2FtZUNoaWxkID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKTtcbiAgICAgICAgdmFyIHNpZGVDaGlsZCA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShzaWRlKTtcbiAgICAgICAgdmFyIGhvbGRzID0gc2lkZUNoaWxkLmdldENoaWxkQnlOYW1lKFwiaG9sZHNcIik7XG5cbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuZ2V0TUpJbmRleChzaWRlLDEzKTtcbiAgICAgICAgdmFyIG5jID0gaG9sZHMuY2hpbGRyZW5bbGFzdEluZGV4XTtcblxuICAgICAgICBuYy5zY2FsZVggPSAxLjA7XG4gICAgICAgIG5jLnNjYWxlWSA9IDEuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICBpZihwYWkgPT0gbnVsbCl7XG4gICAgICAgICAgICBuYy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHBhaSA+PSAwKXtcbiAgICAgICAgICAgIG5jLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBpZihzaWRlID09IFwidXBcIil7XG4gICAgICAgICAgICAgICAgbmMuc2NhbGVYID0gMC43MztcbiAgICAgICAgICAgICAgICBuYy5zY2FsZVkgPSAwLjczOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gbmMuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7IFxuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChwcmUscGFpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHBhaSAhPSBudWxsKXtcbiAgICAgICAgICAgIG5jLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBpZihzaWRlID09IFwidXBcIil7XG4gICAgICAgICAgICAgICAgbmMuc2NhbGVYID0gMS4wO1xuICAgICAgICAgICAgICAgIG5jLnNjYWxlWSA9IDEuMDsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG5jLmdldENvbXBvbmVudChjYy5TcHJpdGUpOyBcbiAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0SG9sZHNFbXB0eVNwcml0ZUZyYW1lKHNpZGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBpbml0RW1wdHlTcHJpdGVzOmZ1bmN0aW9uKHNlYXRJbmRleCl7XG4gICAgICAgIHZhciBsb2NhbEluZGV4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KHNlYXRJbmRleCk7XG4gICAgICAgIHZhciBzaWRlID0gY2MudnYubWFoam9uZ21nci5nZXRTaWRlKGxvY2FsSW5kZXgpO1xuICAgICAgICB2YXIgcHJlID0gY2MudnYubWFoam9uZ21nci5nZXRGb2xkUHJlKGxvY2FsSW5kZXgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGdhbWVDaGlsZCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIik7XG4gICAgICAgIHZhciBzaWRlQ2hpbGQgPSBnYW1lQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoc2lkZSk7XG4gICAgICAgIHZhciBob2xkcyA9IHNpZGVDaGlsZC5nZXRDaGlsZEJ5TmFtZShcImhvbGRzXCIpO1xuICAgICAgICB2YXIgc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldEVtcHR5U3ByaXRlRnJhbWUoc2lkZSk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBob2xkcy5jaGlsZHJlbkNvdW50OyArK2kpe1xuICAgICAgICAgICAgdmFyIG5jID0gaG9sZHMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBuYy5zY2FsZVggPSAxLjA7XG4gICAgICAgICAgICBuYy5zY2FsZVkgPSAxLjA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBuYy5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTsgXG4gICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBzcHJpdGVGcmFtZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgaW5pdE90aGVyTWFoam9uZ3M6ZnVuY3Rpb24oc2VhdERhdGEpe1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwic2VhdDpcIiArIHNlYXREYXRhLnNlYXRpbmRleCk7XG4gICAgICAgIHZhciBsb2NhbEluZGV4ID0gdGhpcy5nZXRMb2NhbEluZGV4KHNlYXREYXRhLnNlYXRpbmRleCk7XG4gICAgICAgIGlmKGxvY2FsSW5kZXggPT0gMCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpZGUgPSBjYy52di5tYWhqb25nbWdyLmdldFNpZGUobG9jYWxJbmRleCk7XG4gICAgICAgIHZhciBnYW1lID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKTtcbiAgICAgICAgdmFyIHNpZGVSb290ID0gZ2FtZS5nZXRDaGlsZEJ5TmFtZShzaWRlKTtcbiAgICAgICAgdmFyIHNpZGVIb2xkcyA9IHNpZGVSb290LmdldENoaWxkQnlOYW1lKFwiaG9sZHNcIik7XG4gICAgICAgIHZhciBudW0gPSBzZWF0RGF0YS5wZW5ncy5sZW5ndGggKyBzZWF0RGF0YS5hbmdhbmdzLmxlbmd0aCArIHNlYXREYXRhLmRpYW5nYW5ncy5sZW5ndGggKyBzZWF0RGF0YS53YW5nYW5ncy5sZW5ndGggKyBzZWF0RGF0YS5jaGlzLmxlbmd0aDtcbiAgICAgICAgbnVtICo9IDM7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBudW07ICsraSl7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5nZXRNSkluZGV4KHNpZGUsaSk7XG4gICAgICAgICAgICBzaWRlSG9sZHMuY2hpbGRyZW5baWR4XS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHByZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0Rm9sZFByZShsb2NhbEluZGV4KTtcbiAgICAgICAgdmFyIGhvbGRzID0gdGhpcy5zb3J0SG9sZHMoc2VhdERhdGEpO1xuICAgICAgICBpZihob2xkcyAhPSBudWxsICYmIGhvbGRzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGhvbGRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5nZXRNSkluZGV4KHNpZGUsaSArIG51bSk7XG4gICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHNpZGVIb2xkcy5jaGlsZHJlbltpZHhdLmdldENvbXBvbmVudChjYy5TcHJpdGUpOyBcbiAgICAgICAgICAgICAgICBpZihzaWRlID09IFwidXBcIil7XG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5ub2RlLnNjYWxlWCA9IDAuNzM7XG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5ub2RlLnNjYWxlWSA9IDAuNzM7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ByaXRlLm5vZGUuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKHByZSxob2xkc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGhvbGRzLmxlbmd0aCArIG51bSA9PSAxMyl7XG4gICAgICAgICAgICAgICAgdmFyIGxhc2V0SWR4ID0gdGhpcy5nZXRNSkluZGV4KHNpZGUsMTMpO1xuICAgICAgICAgICAgICAgIHNpZGVIb2xkcy5jaGlsZHJlbltsYXNldElkeF0uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNvcnRIb2xkczpmdW5jdGlvbihzZWF0RGF0YSl7XG4gICAgICAgIHZhciBob2xkcyA9IHNlYXREYXRhLmhvbGRzO1xuICAgICAgICBpZihob2xkcyA9PSBudWxsKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8v5aaC5p6c5omL5LiK55qE54mM55qE5pWw55uu5pivMiw1LDgsMTEsMTTvvIzooajnpLrmnIDlkI7kuIDlvKDniYzmmK/liJrmkbjliLDnmoTniYxcbiAgICAgICAgdmFyIG1vcGFpID0gbnVsbDtcbiAgICAgICAgdmFyIGwgPSBob2xkcy5sZW5ndGggXG4gICAgICAgIGlmKCBsID09IDIgfHwgbCA9PSA1IHx8IGwgPT0gOCB8fCBsID09IDExIHx8IGwgPT0gMTQpe1xuICAgICAgICAgICAgbW9wYWkgPSBob2xkcy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGRpbmdxdWUgPSBzZWF0RGF0YS5kaW5ncXVlO1xuICAgICAgICBjYy52di5tYWhqb25nbWdyLnNvcnRNSihob2xkcyxkaW5ncXVlKTtcbiAgICAgICAgXG4gICAgICAgIC8v5bCG5pG454mM5re75Yqg5Yiw5pyA5ZCOXG4gICAgICAgIGlmKG1vcGFpICE9IG51bGwpe1xuICAgICAgICAgICAgaG9sZHMucHVzaChtb3BhaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvbGRzO1xuICAgIH0sXG4gICAgXG4gICAgaW5pdE1haGpvbmdzOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzZWF0cyA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHM7XG4gICAgICAgIHZhciBzZWF0RGF0YSA9IHNlYXRzW2NjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4XTtcbiAgICAgICAgdmFyIGhvbGRzID0gdGhpcy5zb3J0SG9sZHMoc2VhdERhdGEpO1xuICAgICAgICBpZihob2xkcyA9PSBudWxsKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhzZWF0cyk7XG4gICAgICAgIC8v5Yid5aeL5YyW5omL54mMXG4gICAgICAgIHZhciBsYWNraW5nTnVtID0gKHNlYXREYXRhLmNoaXMubGVuZ3RoICsgc2VhdERhdGEucGVuZ3MubGVuZ3RoICsgc2VhdERhdGEuYW5nYW5ncy5sZW5ndGggKyBzZWF0RGF0YS5kaWFuZ2FuZ3MubGVuZ3RoICsgc2VhdERhdGEud2FuZ2FuZ3MubGVuZ3RoKSozO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgaG9sZHMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIG1qaWQgPSBob2xkc1tpXTtcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLl9teU1KQXJyW2kgKyBsYWNraW5nTnVtXTtcbiAgICAgICAgICAgIHNwcml0ZS5ub2RlLm1qSWQgPSBtamlkO1xuICAgICAgICAgICAgc3ByaXRlLm5vZGUueSA9IDA7XG4gICAgICAgICAgICB0aGlzLnNldFNwcml0ZUZyYW1lQnlNSklEKFwiTV9cIixzcHJpdGUsbWppZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxhY2tpbmdOdW07ICsraSl7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5fbXlNSkFycltpXTsgXG4gICAgICAgICAgICBzcHJpdGUubm9kZS5taklkID0gbnVsbDtcbiAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IG51bGw7XG4gICAgICAgICAgICBzcHJpdGUubm9kZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIGkgPSBsYWNraW5nTnVtICsgaG9sZHMubGVuZ3RoOyBpIDwgdGhpcy5fbXlNSkFyci5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5fbXlNSkFycltpXTsgXG4gICAgICAgICAgICBzcHJpdGUubm9kZS5taklkID0gbnVsbDtcbiAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IG51bGw7XG4gICAgICAgICAgICBzcHJpdGUubm9kZS5hY3RpdmUgPSBmYWxzZTsgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc2V0U3ByaXRlRnJhbWVCeU1KSUQ6ZnVuY3Rpb24ocHJlLHNwcml0ZSxtamlkKXtcbiAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChwcmUsbWppZCk7XG4gICAgICAgIHNwcml0ZS5ub2RlLmFjdGl2ZSA9IHRydWU7XG4gICAgfSxcbiAgICBcbiAgICAvL+WmguaenOeOqeWutuaJi+S4iui/mOaciee8uueahOeJjOayoeacieaJk++8jOWImeWPquiDveaJk+e8uueJjFxuICAgIGNoZWNrUXVlWWlNZW46ZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoY2MudnYuZ2FtZU5ldE1nci5jb25mPT1udWxsIHx8IGNjLnZ2LmdhbWVOZXRNZ3IuY29uZi50eXBlICE9IFwieGxjaFwiIHx8ICFjYy52di5nYW1lTmV0TWdyLmdldFNlbGZEYXRhKCkuaHVlZCl7XG4gICAgICAgICAgICAvL+mBjeWOhuajgOafpeeci+aYr+WQpuacieacquaJk+e8uueahOeJjCDlpoLmnpzmnInvvIzliJnpnIDopoHlsIbkuI3mmK/lrprnvLrnmoTniYzorr7nva7kuLrkuI3lj6/nlKhcbiAgICAgICAgICAgIHZhciBkaW5ncXVlID0gY2MudnYuZ2FtZU5ldE1nci5kaW5ncXVlO1xuICAgIC8vICAgICAgICBjb25zb2xlLmxvZyhkaW5ncXVlKVxuICAgICAgICAgICAgdmFyIGhhc1F1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoY2MudnYuZ2FtZU5ldE1nci5zZWF0SW5kZXggPT0gY2MudnYuZ2FtZU5ldE1nci50dXJuKXtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbXlNSkFyci5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcHJpdGUgPSB0aGlzLl9teU1KQXJyW2ldO1xuICAgIC8vICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3ByaXRlLm5vZGUubWpJZDpcIiArIHNwcml0ZS5ub2RlLm1qSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZihzcHJpdGUubm9kZS5taklkICE9IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBjYy52di5tYWhqb25nbWdyLmdldE1haGpvbmdUeXBlKHNwcml0ZS5ub2RlLm1qSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYodHlwZSA9PSBkaW5ncXVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNRdWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuXG4gICAgLy8gICAgICAgIGNvbnNvbGUubG9nKFwiaGFzUXVlOlwiICsgaGFzUXVlKTtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9teU1KQXJyLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5fbXlNSkFycltpXTtcbiAgICAgICAgICAgICAgICBpZihzcHJpdGUubm9kZS5taklkICE9IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0TWFoam9uZ1R5cGUoc3ByaXRlLm5vZGUubWpJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc1F1ZSAmJiB0eXBlICE9IGRpbmdxdWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLm5vZGUuZ2V0Q29tcG9uZW50KGNjLkJ1dHRvbikuaW50ZXJhY3RhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5ub2RlLmdldENvbXBvbmVudChjYy5CdXR0b24pLmludGVyYWN0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ICAgXG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4ID09IGNjLnZ2LmdhbWVOZXRNZ3IudHVybil7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IDE0OyArK2kpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ByaXRlID0gdGhpcy5fbXlNSkFycltpXTsgXG4gICAgICAgICAgICAgICAgICAgIGlmKHNwcml0ZS5ub2RlLmFjdGl2ZSA9PSB0cnVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwcml0ZS5ub2RlLmdldENvbXBvbmVudChjYy5CdXR0b24pLmludGVyYWN0YWJsZSA9IGkgPT0gMTM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxNDsgKytpKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwcml0ZSA9IHRoaXMuX215TUpBcnJbaV07IFxuICAgICAgICAgICAgICAgICAgICBpZihzcHJpdGUubm9kZS5hY3RpdmUgPT0gdHJ1ZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5nZXRDb21wb25lbnQoY2MuQnV0dG9uKS5pbnRlcmFjdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBnZXRMb2NhbEluZGV4OmZ1bmN0aW9uKGluZGV4KXtcbiAgICAgICAgdmFyIHJldCA9IChpbmRleCAtIGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4ICsgNCkgJSA0O1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwib2xkOlwiICsgaW5kZXggKyBcIixiYXNlOlwiICsgY2MudnYuZ2FtZU5ldE1nci5zZWF0SW5kZXggKyBcIixuZXc6XCIgKyByZXQpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG4gICAgXG4gICAgb25PcHRpb25DbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgY29uc29sZS5sb2coZXZlbnQudGFyZ2V0Lm5hbWUpO1xuICAgICAgICBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImJ0blBlbmdcIil7XG4gICAgICAgICAgICBjYy52di5uZXQuc2VuZChcInBlbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImJ0bkdhbmdcIil7XG4gICAgICAgICAgICBjYy52di5uZXQuc2VuZChcImdhbmdcIixldmVudC50YXJnZXQucGFpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuSHVcIil7XG4gICAgICAgICAgICBjYy52di5uZXQuc2VuZChcImh1XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8v5omT5byA5ZCD6I+c5Y2VXG4gICAgICAgIGVsc2UgaWYoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJidG5DaGlcIil7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmdldENoaWxkQnlOYW1lKFwiY2hpb3BcIikuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX29wdGlvbnMuY2hpbGRyZW5Db3VudDsgKytpKXtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLl9vcHRpb25zLmNoaWxkcmVuW2ldOyBcbiAgICAgICAgICAgICAgICBpZihjaGlsZC5uYW1lID09IFwib3BcIiApe1xuICAgICAgICAgICAgICAgICAgICBjaGlsZC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy/lt6blkINcbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImxlZnRcIil7XG4gICAgICAgICAgICBjYy52di5uZXQuc2VuZChcImNoaVwiLFwibGVmdFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvL+S4reWQg1xuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwibWlkXCIpe1xuICAgICAgICAgICAgY2MudnYubmV0LnNlbmQoXCJjaGlcIixcIm1pZFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvL+WPs+WQg1xuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwicmlnaHRcIil7XG4gICAgICAgICAgICBjYy52di5uZXQuc2VuZChcImNoaVwiLFwicmlnaHRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImJ0bkd1b1wiKXtcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiZ3VvXCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG4gICAgfSxcbiAgICBcbiAgICBvbkRlc3Ryb3k6ZnVuY3Rpb24oKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJvbkRlc3Ryb3lcIik7XG4gICAgICAgIGlmKGNjLnZ2KXtcbiAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuY2xlYXIoKTsgICBcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgbGJsUm9vbU5vOntcbiAgICAgICAgICAgIGRlZmF1bHQ6bnVsbCxcbiAgICAgICAgICAgIHR5cGU6Y2MuTGFiZWxcbiAgICAgICAgfSxcbiAgICAgICAgX3NlYXRzOltdLFxuICAgICAgICBfc2VhdHMyOltdLFxuICAgICAgICBfdGltZUxhYmVsOm51bGwsXG4gICAgICAgIF92b2ljZU1zZ1F1ZXVlOltdLFxuICAgICAgICBfbGFzdFBsYXlpbmdTZWF0Om51bGwsXG4gICAgICAgIF9wbGF5aW5nU2VhdDpudWxsLFxuICAgICAgICBfbGFzdFBsYXlUaW1lOm51bGwsXG4gICAgICAgIF9pZnNob3dpcHdhcm5pbmc6dHJ1ZSxcbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmKGNjLnZ2ID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmluaXRWaWV3KCk7XG4gICAgICAgIHRoaXMuaW5pdFNlYXRzKCk7XG4gICAgICAgIHRoaXMuaW5pdEV2ZW50SGFuZGxlcnMoKTtcbiAgICAgICAgXG4gICAgICAgIHZhciB5b3VrZW9yd2VpeGluID0gY2Muc3lzLmxvY2FsU3RvcmFnZS5nZXRJdGVtKFwieW91a2VvcndlaXhpblwiKTtcbiAgICAgICAgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1MgJiYgeW91a2VvcndlaXhpbiA9PSBcIjBcIil7XG4gICAgICAgICAgICAvL+makOiXj+aYvuekuuS4i+i+ueaMiemSrlxuICAgICAgICAgICAgY2MuZmluZChcIkNhbnZhcy9wcmVwYXJlL2J0bldlaWNoYXRcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy90aGlzLmFkZENvbXBvbmVudChcIkFsZXJ0XCIpO1xuICAgIH0sXG4gICAgXG4gICAgaW5pdFZpZXc6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHByZXBhcmUgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJwcmVwYXJlXCIpO1xuICAgICAgICB2YXIgc2VhdHMgPSBwcmVwYXJlLmdldENoaWxkQnlOYW1lKFwic2VhdHNcIik7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZWF0cy5jaGlsZHJlbi5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB0aGlzLl9zZWF0cy5wdXNoKHNlYXRzLmNoaWxkcmVuW2ldLmdldENvbXBvbmVudChcIlNlYXRcIikpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnJlZnJlc2hCdG5zKCk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmxibFJvb21ObyA9IGNjLmZpbmQoXCJDYW52YXMvaW5mb2Jhci9zaGlqaWFuL1pfcm9vbV90eHQvTmV3IExhYmVsXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCk7XG4gICAgICAgIHRoaXMuX3RpbWVMYWJlbCA9IGNjLmZpbmQoXCJDYW52YXMvaW5mb2Jhci9zaGlqaWFuL3RpbWVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcbiAgICAgICAgXG4gICAgICAgIC8v5pi+56S6546p5rOVXG4gICAgICAgIGNjLmZpbmQoXCJDYW52YXMvaW5mb2Jhci93YW5mYVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9ICBjYy52di5nYW1lTmV0TWdyLmdldFdhbmZhKCk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdGhpcy5sYmxSb29tTm8uc3RyaW5nID0gY2MudnYuZ2FtZU5ldE1nci5yb29tSWQ7XG4gICAgICAgIHZhciBnYW1lQ2hpbGQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJnYW1lXCIpO1xuICAgICAgICB2YXIgc2lkZXMgPSBbXCJteXNlbGZcIixcInJpZ2h0XCIsXCJ1cFwiLFwibGVmdFwiXTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNpZGVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBzaWRlTm9kZSA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShzaWRlc1tpXSk7XG4gICAgICAgICAgICB2YXIgc2VhdCA9IHNpZGVOb2RlLmdldENoaWxkQnlOYW1lKFwic2VhdFwiKTtcbiAgICAgICAgICAgIHRoaXMuX3NlYXRzMi5wdXNoKHNlYXQuZ2V0Q29tcG9uZW50KFwiU2VhdFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBidG5XZWNoYXQgPSBjYy5maW5kKFwiQ2FudmFzL3ByZXBhcmUvYnRuV2VpY2hhdFwiKTtcbiAgICAgICAgaWYoYnRuV2VjaGF0KXtcbiAgICAgICAgICAgIGNjLnZ2LnV0aWxzLmFkZENsaWNrRXZlbnQoYnRuV2VjaGF0LHRoaXMubm9kZSxcIk1KUm9vbVwiLFwib25CdG5XZWljaGF0Q2xpY2tlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGJ0bkNvcHkgPSBjYy5maW5kKFwiQ2FudmFzL3ByZXBhcmUvYnRuQ29weVwiKTtcbiAgICAgICAgaWYoYnRuQ29weSl7XG4gICAgICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KGJ0bkNvcHksdGhpcy5ub2RlLFwiTUpSb29tXCIsXCJvbkJ0bkNvcHlDbGlja2VkXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdmFyIHRpdGxlcyA9IGNjLmZpbmQoXCJDYW52YXMvdHlwZVRpdGxlXCIpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGl0bGVzLmNoaWxkcmVuLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHRpdGxlcy5jaGlsZHJlbltpXS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY2MudnYuZ2FtZU5ldE1nci5jb25mKXtcbiAgICAgICAgICAgIC8vIHZhciB0eXBlID0gY2MudnYuZ2FtZU5ldE1nci5jb25mLnR5cGU7XG4gICAgICAgICAgICAvLyBpZih0eXBlID09IG51bGwgfHwgdHlwZSA9PSBcIlwiKXtcbiAgICAgICAgICAgIC8vICAgICB0eXBlID0gXCJ4emRkXCI7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyB0aXRsZXMuZ2V0Q2hpbGRCeU5hbWUodHlwZSkuYWN0aXZlID0gdHJ1ZTsgICBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgcmVmcmVzaEJ0bnM6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHByZXBhcmUgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJwcmVwYXJlXCIpO1xuICAgICAgICB2YXIgYnRuRXhpdCA9IHByZXBhcmUuZ2V0Q2hpbGRCeU5hbWUoXCJidG5FeGl0XCIpO1xuICAgICAgICB2YXIgYnRuRGlzcHJlc3MgPSBwcmVwYXJlLmdldENoaWxkQnlOYW1lKFwiYnRuRGlzc29sdmVcIik7XG4gICAgICAgIHZhciBidG5XZWljaGF0ID0gcHJlcGFyZS5nZXRDaGlsZEJ5TmFtZShcImJ0bldlaWNoYXRcIik7XG4gICAgICAgIHZhciBidG5CYWNrID0gcHJlcGFyZS5nZXRDaGlsZEJ5TmFtZShcImJ0bkJhY2tcIik7XG4gICAgICAgIHZhciBpc0lkbGUgPSBjYy52di5nYW1lTmV0TWdyLm51bU9mR2FtZXMgPT0gMDtcbiAgICAgICAgY29uc29sZS5sb2coJ2lzSWRsZScraXNJZGxlKTtcbiAgICAgICAgY29uc29sZS5sb2coY2MudnYuZ2FtZU5ldE1nci5udW1PZkdhbWVzKTtcbiAgICAgICAgYnRuRXhpdC5hY3RpdmUgPSAhY2MudnYuZ2FtZU5ldE1nci5pc093bmVyKCkgJiYgaXNJZGxlO1xuICAgICAgICBidG5EaXNwcmVzcy5hY3RpdmUgPSBjYy52di5nYW1lTmV0TWdyLmlzT3duZXIoKSAmJiBpc0lkbGU7XG4gICAgICAgIFxuICAgICAgICBidG5XZWljaGF0LmFjdGl2ZSA9IGlzSWRsZTtcbiAgICAgICAgYnRuQmFjay5hY3RpdmUgPSBpc0lkbGU7XG4gICAgfSxcbiAgICBcbiAgICBpcFdhcm5pbmc6ZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgICAgIGlmKCF0aGlzLl9pZnNob3dpcHdhcm5pbmcpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIHZhciBzZWF0cyA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHM7XG4gICAgICAgIHZhciBub3dzZWF0ID0gY2MudnYuZ2FtZU5ldE1nci5zZWF0SW5kZXg7XG4gICAgICAgIGlmKCFub3dzZWF0KSByZXR1cm47XG4gICAgICAgIHZhciBvdGhlcnMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBpID0gMCA7IGkgPCA0IDsgaSArKykge1xuICAgICAgICAgICAgaWYobm93c2VhdCAmJiBpIT1ub3dzZWF0KSB7XG4gICAgICAgICAgICAgICAgb3RoZXJzLnB1c2goW3NlYXRzW2ldLm5hbWUsc2VhdHNbaV0uaXBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgd2FybmFtZXMgPSBbXTtcbiAgICAgICAgaWYgKCAob3RoZXJzWzBdWzFdID09IG90aGVycyBbMV1bMV0gfHwgb3RoZXJzWzBdWzFdID09IG90aGVycyBbMl1bMV0pICYmIG90aGVyc1swXVsxXSE9bnVsbCkge1xuICAgICAgICAgICAgd2FybmFtZXMucHVzaChvdGhlcnNbMF1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICggKG90aGVyc1sxXVsxXSA9PSBvdGhlcnMgWzBdWzFdIHx8IG90aGVyc1sxXVsxXSA9PSBvdGhlcnMgWzJdWzFdKSAmJiBvdGhlcnNbMV1bMV0hPW51bGwpIHtcbiAgICAgICAgICAgIHdhcm5hbWVzLnB1c2gob3RoZXJzWzFdWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIChvdGhlcnNbMl1bMV0gPT0gb3RoZXJzIFsxXVsxXSB8fCBvdGhlcnNbMl1bMV0gPT0gb3RoZXJzIFswXVsxXSkgJiYgb3RoZXJzWzFdWzFdIT1udWxsKSB7XG4gICAgICAgICAgICB3YXJuYW1lcy5wdXNoKG90aGVyc1syXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0ciA9IHdhcm5hbWVzLmpvaW4oXCLjgIFcIik7XG4gICAgICAgIGlmKHdhcm5hbWVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIGNjLnZ2LmFsZXJ0LnNob3coXCJJUOitpuWRilwiLFwi546p5a62XCIgKyBzdHIgKyBcIuadpeiHquebuOWQjElQ77yM6K+36LCo6Ziy5YW25LuW546p5a625omT5Yu+5omL5LiK5b2T5Y+X6aqXXCIsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiZGlzc29sdmVfY2F1c2VfaXBcIik7XG4gICAgICAgICAgICB9LHRydWUsXCLop6PmlaNcIixcIue7p+e7rVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2lmc2hvd2lwd2FybmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgaW5pdEV2ZW50SGFuZGxlcnM6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm5vZGUub24oJ25ld191c2VyJyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHNlbGYuaW5pdFNpbmdsZVNlYXQoZGF0YS5kZXRhaWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5vbigndXNlcl9zdGF0ZV9jaGFuZ2VkJyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHNlbGYuaW5pdFNpbmdsZVNlYXQoZGF0YS5kZXRhaWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9iZWdpbicsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNlbGYucmVmcmVzaEJ0bnMoKTtcbiAgICAgICAgICAgIHNlbGYuaW5pdFNlYXRzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX251bScsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNlbGYucmVmcmVzaEJ0bnMoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2h1YW5wYWknLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgZm9yKHZhciBpIGluIHNlbGYuX3NlYXRzMil7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2VhdHMyW2ldLnJlZnJlc2hYdWFuUGFpU3RhdGUoKTsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2h1YW5wYWlfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHZhciBpZHggPSBkYXRhLmRldGFpbC5zZWF0aW5kZXg7XG4gICAgICAgICAgICB2YXIgbG9jYWxJZHggPSBjYy52di5nYW1lTmV0TWdyLmdldExvY2FsSW5kZXgoaWR4KTtcbiAgICAgICAgICAgIHNlbGYuX3NlYXRzMltsb2NhbElkeF0ucmVmcmVzaFh1YW5QYWlTdGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5vbignZ2FtZV9odWFucGFpX292ZXInLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgZm9yKHZhciBpIGluIHNlbGYuX3NlYXRzMil7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2VhdHMyW2ldLnJlZnJlc2hYdWFuUGFpU3RhdGUoKTsgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCd2b2ljZV9tc2cnLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcbiAgICAgICAgICAgIHNlbGYuX3ZvaWNlTXNnUXVldWUucHVzaChkYXRhKTtcbiAgICAgICAgICAgIHNlbGYucGxheVZvaWNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdjaGF0X3B1c2gnLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcbiAgICAgICAgICAgIHZhciBpZHggPSBjYy52di5nYW1lTmV0TWdyLmdldFNlYXRJbmRleEJ5SUQoZGF0YS5zZW5kZXIpO1xuICAgICAgICAgICAgdmFyIGxvY2FsSWR4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KGlkeCk7XG4gICAgICAgICAgICBzZWxmLl9zZWF0c1tsb2NhbElkeF0uY2hhdChkYXRhLmNvbnRlbnQpO1xuICAgICAgICAgICAgc2VsZi5fc2VhdHMyW2xvY2FsSWR4XS5jaGF0KGRhdGEuY29udGVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdxdWlja19jaGF0X3B1c2gnLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcbiAgICAgICAgICAgIHZhciBpZHggPSBjYy52di5nYW1lTmV0TWdyLmdldFNlYXRJbmRleEJ5SUQoZGF0YS5zZW5kZXIpO1xuICAgICAgICAgICAgdmFyIGxvY2FsSWR4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KGlkeCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGRhdGEuY29udGVudDtcbiAgICAgICAgICAgIHZhciBpbmZvID0gY2MudnYuY2hhdC5nZXRRdWlja0NoYXRJbmZvKGluZGV4KTtcbiAgICAgICAgICAgIHNlbGYuX3NlYXRzW2xvY2FsSWR4XS5jaGF0KGluZm8uY29udGVudCk7XG4gICAgICAgICAgICBzZWxmLl9zZWF0czJbbG9jYWxJZHhdLmNoYXQoaW5mby5jb250ZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2MudnYuYXVkaW9NZ3IucGxheVNGWChpbmZvLnNvdW5kKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2Vtb2ppX3B1c2gnLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcbiAgICAgICAgICAgIHZhciBpZHggPSBjYy52di5nYW1lTmV0TWdyLmdldFNlYXRJbmRleEJ5SUQoZGF0YS5zZW5kZXIpO1xuICAgICAgICAgICAgdmFyIGxvY2FsSWR4ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRMb2NhbEluZGV4KGlkeCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHNlbGYuX3NlYXRzW2xvY2FsSWR4XS5lbW9qaShkYXRhLmNvbnRlbnQpO1xuICAgICAgICAgICAgc2VsZi5fc2VhdHMyW2xvY2FsSWR4XS5lbW9qaShkYXRhLmNvbnRlbnQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIGluaXRTZWF0czpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgc2VhdHMgPSBjYy52di5nYW1lTmV0TWdyLnNlYXRzO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VhdHMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdGhpcy5pbml0U2luZ2xlU2VhdChzZWF0c1tpXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGluaXRTaW5nbGVTZWF0OmZ1bmN0aW9uKHNlYXQpe1xuICAgICAgICB2YXIgaW5kZXggPSBjYy52di5nYW1lTmV0TWdyLmdldExvY2FsSW5kZXgoc2VhdC5zZWF0aW5kZXgpO1xuICAgICAgICB2YXIgaXNPZmZsaW5lID0gIXNlYXQub25saW5lO1xuICAgICAgICB2YXIgaXNaaHVhbmcgPSBzZWF0LnNlYXRpbmRleCA9PSBjYy52di5nYW1lTmV0TWdyLmJ1dHRvbjtcbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKFwiaXNPZmZsaW5lOlwiICsgaXNPZmZsaW5lKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3NlYXRzW2luZGV4XS5zZXRJbmZvKHNlYXQubmFtZSxzZWF0LnNjb3JlKTtcbiAgICAgICAgdGhpcy5fc2VhdHNbaW5kZXhdLnNldFJlYWR5KHNlYXQucmVhZHkpO1xuICAgICAgICB0aGlzLl9zZWF0c1tpbmRleF0uc2V0T2ZmbGluZShpc09mZmxpbmUpO1xuICAgICAgICB0aGlzLl9zZWF0c1tpbmRleF0uc2V0SUQoc2VhdC51c2VyaWQpO1xuICAgICAgICB0aGlzLl9zZWF0c1tpbmRleF0udm9pY2VNc2coZmFsc2UpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fc2VhdHMyW2luZGV4XS5zZXRJbmZvKHNlYXQubmFtZSxzZWF0LnNjb3JlKTtcbiAgICAgICAgdGhpcy5fc2VhdHMyW2luZGV4XS5zZXRaaHVhbmcoaXNaaHVhbmcpO1xuICAgICAgICB0aGlzLl9zZWF0czJbaW5kZXhdLnNldE9mZmxpbmUoaXNPZmZsaW5lKTtcbiAgICAgICAgdGhpcy5fc2VhdHMyW2luZGV4XS5zZXRJRChzZWF0LnVzZXJpZCk7XG4gICAgICAgIHRoaXMuX3NlYXRzMltpbmRleF0udm9pY2VNc2coZmFsc2UpO1xuICAgICAgICB0aGlzLl9zZWF0czJbaW5kZXhdLnJlZnJlc2hYdWFuUGFpU3RhdGUoKTtcbiAgICB9LFxuICAgIFxuICAgIG9uQnRuU2V0dGluZ3NDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIGNjLnZ2LnBvcHVwTWdyLnNob3dTZXR0aW5ncygpOyAgIFxuICAgIH0sXG5cbiAgICBvbkJ0bkJhY2tDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIGNjLnZ2LmFsZXJ0LnNob3coXCLov5Tlm57lpKfljoVcIixcIui/lOWbnuWkp+WOheaIv+mXtOS7jeS8muS/neeVme+8jOW/q+WOu+mCgOivt+Wkp+S8meadpeeOqeWQp++8gVwiLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJoYWxsXCIpOyAgICBcbiAgICAgICAgfSx0cnVlKTtcbiAgICB9LFxuICAgIFxuICAgIG9uQnRuQ2hhdENsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBvbkJ0bldlaWNoYXRDbGlja2VkOmZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuY29uZi50eXBlID09IFwic2ptbWpcIil7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBcIjzmsojlrrbpl6jpurvlsIY+XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihjYy52di5nYW1lTmV0TWdyLmNvbmYudHlwZSA9PSBcImRobWpcIil7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBcIjzlrprmtbfpurvlsIY+XCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihjYy52di5nYW1lTmV0TWdyLmNvbmYudHlwZSA9PSBcInRkaFwiKXtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IFwiPOaOqOWAkuiDoT5cIjtcbiAgICAgICAgfVxuICAgICAgICBjYy52di5hbnlzZGtNZ3Iuc2hhcmUoXCLlpYflpYfoiJ/lsbHpurvlsIZcIiArIHRpdGxlLFwi5oi/5Y+3OlwiICsgY2MudnYuZ2FtZU5ldE1nci5yb29tSWQgKyBcIiDnjqnms5U6XCIgKyBjYy52di5nYW1lTmV0TWdyLmdldFdhbmZhKCkpO1xuICAgIH0sXG4gICAgXG4gICAgLy/lpI3liLbmiL/pl7Tkv6Hmga9cbiAgICBvbkJ0bkNvcHlDbGlja2VkOmZ1bmN0aW9uKCkge1xuICAgICAgICBpZihjYy52di5nYW1lTmV0TWdyLmNvbmYudHlwZSA9PSBcInNqbW1qXCIpe1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gXCI85rKI5a626Zeo6bq75bCGPlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoY2MudnYuZ2FtZU5ldE1nci5jb25mLnR5cGUgPT0gXCJkaG1qXCIpe1xuICAgICAgICAgICAgdmFyIHRpdGxlID0gXCI85a6a5rW36bq75bCGPlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoY2MudnYuZ2FtZU5ldE1nci5jb25mLnR5cGUgPT0gXCJ0ZGhcIil7XG4gICAgICAgICAgICB2YXIgdGl0bGUgPSBcIjzmjqjlgJLog6E+XCI7XG4gICAgICAgIH1cbiAgICAgICAgY2MudnYuYW55c2RrTWdyLmNvcHkoXCLlpYflpYfoiJ/lsbHpurvlsIZcIiArIHRpdGxlICsgXCIg5oi/5Y+3OuOAkFwiICsgY2MudnYuZ2FtZU5ldE1nci5yb29tSWQrXCLjgJEg546p5rOVOlwiICsgY2MudnYuZ2FtZU5ldE1nci5nZXRXYW5mYSgpKTtcbiAgICAgICAgY2MuZmluZChcIkNhbnZhcy9jb3B5c3VjY2Vzc1wiKS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge2NjLmZpbmQoXCJDYW52YXMvY29weXN1Y2Nlc3NcIikuYWN0aXZlID0gZmFsc2U7fSwgMTAwMCk7XG4gICAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgb25CdG5EaXNzb2x2ZUNsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHlvdWtlb3J3ZWl4aW4gPSBjYy5zeXMubG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ5b3VrZW9yd2VpeGluXCIpO1xuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0lPUyAmJiB5b3VrZW9yd2VpeGluID09IFwiMFwiKXtcbiAgICAgICAgICAgIGNjLnZ2LmFsZXJ0LnNob3coXCLop6PmlaPmiL/pl7RcIixcIuaYr+WQpuehruWumuino+aVo++8n1wiLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgY2MudnYubmV0LnNlbmQoXCJkaXNwcmVzc1wiKTsgICAgXG4gICAgICAgICAgICB9LHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgY2MudnYuYWxlcnQuc2hvdyhcIuino+aVo+aIv+mXtFwiLFwi6Kej5pWj5oi/6Ze05LiN5omj5oi/5Y2h77yM5piv5ZCm56Gu5a6a6Kej5pWj77yfXCIsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiZGlzcHJlc3NcIik7ICAgIFxuICAgICAgICB9LHRydWUpO1xuICAgIH0sXG4gICAgXG4gICAgb25CdG5FeGl0OmZ1bmN0aW9uKCl7XG4gICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwiZXhpdFwiKTtcbiAgICB9LFxuICAgIFxuICAgIHBsYXlWb2ljZTpmdW5jdGlvbigpe1xuICAgICAgICBpZih0aGlzLl9wbGF5aW5nU2VhdCA9PSBudWxsICYmIHRoaXMuX3ZvaWNlTXNnUXVldWUubGVuZ3RoKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicGxheVZvaWNlMlwiKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fdm9pY2VNc2dRdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIGlkeCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0U2VhdEluZGV4QnlJRChkYXRhLnNlbmRlcik7XG4gICAgICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleChpZHgpO1xuICAgICAgICAgICAgdGhpcy5fcGxheWluZ1NlYXQgPSBsb2NhbEluZGV4O1xuICAgICAgICAgICAgdGhpcy5fc2VhdHNbbG9jYWxJbmRleF0udm9pY2VNc2codHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl9zZWF0czJbbG9jYWxJbmRleF0udm9pY2VNc2codHJ1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBtc2dJbmZvID0gSlNPTi5wYXJzZShkYXRhLmNvbnRlbnQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbXNnZmlsZSA9IFwidm9pY2Vtc2cuYW1yXCI7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhtc2dJbmZvLm1zZy5sZW5ndGgpO1xuICAgICAgICAgICAgY2MudnYudm9pY2VNZ3Iud3JpdGVWb2ljZShtc2dmaWxlLG1zZ0luZm8ubXNnKTtcbiAgICAgICAgICAgIGNjLnZ2LnZvaWNlTWdyLnBsYXkobXNnZmlsZSk7XG4gICAgICAgICAgICB0aGlzLl9sYXN0UGxheVRpbWUgPSBEYXRlLm5vdygpICsgbXNnSW5mby50aW1lO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG4gICAgICAgIHZhciBtaW51dGVzID0gTWF0aC5mbG9vcihEYXRlLm5vdygpLzEwMDAvNjApO1xuICAgICAgICBpZih0aGlzLl9sYXN0TWludXRlICE9IG1pbnV0ZXMpe1xuICAgICAgICAgICAgdGhpcy5fbGFzdE1pbnV0ZSA9IG1pbnV0ZXM7XG4gICAgICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICB2YXIgaCA9IGRhdGUuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgIGggPSBoIDwgMTA/IFwiMFwiK2g6aDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG0gPSBkYXRlLmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgIG0gPSBtIDwgMTA/IFwiMFwiK206bTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVMYWJlbC5zdHJpbmcgPSBcIlwiICsgaCArIFwiOlwiICsgbTsgICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLl9sYXN0UGxheVRpbWUgIT0gbnVsbCl7XG4gICAgICAgICAgICBpZihEYXRlLm5vdygpID4gdGhpcy5fbGFzdFBsYXlUaW1lICsgMjAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUGxheWVyT3ZlcigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQbGF5VGltZSA9IG51bGw7ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB0aGlzLnBsYXlWb2ljZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXBXYXJuaW5nKCk7XG4gICAgfSxcbiAgICBcbiAgICAgICAgXG4gICAgb25QbGF5ZXJPdmVyOmZ1bmN0aW9uKCl7XG4gICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnJlc3VtZUFsbCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcIm9uUGxheUNhbGxiYWNrOlwiICsgdGhpcy5fcGxheWluZ1NlYXQpO1xuICAgICAgICB2YXIgbG9jYWxJbmRleCA9IHRoaXMuX3BsYXlpbmdTZWF0O1xuICAgICAgICB0aGlzLl9wbGF5aW5nU2VhdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3NlYXRzW2xvY2FsSW5kZXhdLnZvaWNlTXNnKGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc2VhdHMyW2xvY2FsSW5kZXhdLnZvaWNlTXNnKGZhbHNlKTtcbiAgICB9LFxuICAgIFxuICAgIG9uRGVzdHJveTpmdW5jdGlvbigpe1xuICAgICAgICBjYy52di52b2ljZU1nci5zdG9wKCk7XG4vLyAgICAgICAgY2MudnYudm9pY2VNZ3Iub25QbGF5Q2FsbGJhY2sgPSBudWxsO1xuICAgIH1cbn0pO1xuIiwidmFyIG1haGpvbmdTcHJpdGVzID0gW107XG5cbmNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGxlZnRBdGxhczp7XG4gICAgICAgICAgICBkZWZhdWx0Om51bGwsXG4gICAgICAgICAgICB0eXBlOmNjLlNwcml0ZUF0bGFzXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICByaWdodEF0bGFzOntcbiAgICAgICAgICAgIGRlZmF1bHQ6bnVsbCxcbiAgICAgICAgICAgIHR5cGU6Y2MuU3ByaXRlQXRsYXNcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGJvdHRvbUF0bGFzOntcbiAgICAgICAgICAgIGRlZmF1bHQ6bnVsbCxcbiAgICAgICAgICAgIHR5cGU6Y2MuU3ByaXRlQXRsYXNcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGJvdHRvbUZvbGRBdGxhczp7XG4gICAgICAgICAgICBkZWZhdWx0Om51bGwsXG4gICAgICAgICAgICB0eXBlOmNjLlNwcml0ZUF0bGFzXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBwZW5nUHJlZmFiU2VsZjp7XG4gICAgICAgICAgICBkZWZhdWx0Om51bGwsXG4gICAgICAgICAgICB0eXBlOmNjLlByZWZhYlxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgcGVuZ1ByZWZhYkxlZnQ6e1xuICAgICAgICAgICAgZGVmYXVsdDpudWxsLFxuICAgICAgICAgICAgdHlwZTpjYy5QcmVmYWJcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGVtcHR5QXRsYXM6e1xuICAgICAgICAgICAgZGVmYXVsdDpudWxsLFxuICAgICAgICAgICAgdHlwZTpjYy5TcHJpdGVBdGxhc1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgaG9sZHNFbXB0eTp7XG4gICAgICAgICAgICBkZWZhdWx0OltdLFxuICAgICAgICAgICAgdHlwZTpbY2MuU3ByaXRlRnJhbWVdXG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBfc2lkZXM6bnVsbCxcbiAgICAgICAgX3ByZXM6bnVsbCxcbiAgICAgICAgX2ZvbGRQcmVzOm51bGwsXG4gICAgfSxcbiAgICBcbiAgICBvbkxvYWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2lkZXMgPSBbXCJteXNlbGZcIixcInJpZ2h0XCIsXCJ1cFwiLFwibGVmdFwiXTtcbiAgICAgICAgdGhpcy5fcHJlcyA9IFtcIk1fXCIsXCJSX1wiLFwiQl9cIixcIkxfXCJdO1xuICAgICAgICB0aGlzLl9mb2xkUHJlcyA9IFtcIkJfXCIsXCJSX1wiLFwiQl9cIixcIkxfXCJdO1xuICAgICAgICBjYy52di5tYWhqb25nbWdyID0gdGhpczsgXG4gICAgICAgIC8v562SXG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCAxMDsgKytpKXtcbiAgICAgICAgICAgIG1haGpvbmdTcHJpdGVzLnB1c2goXCJkb3RfXCIgKyBpKTsgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL+adoVxuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgMTA7ICsraSl7XG4gICAgICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwiYmFtYm9vX1wiICsgaSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8v5LiHXG4gICAgICAgIGZvcih2YXIgaSA9IDE7IGkgPCAxMDsgKytpKXtcbiAgICAgICAgICAgIG1haGpvbmdTcHJpdGVzLnB1c2goXCJjaGFyYWN0ZXJfXCIgKyBpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy/kuK3jgIHlj5HjgIHnmb1cbiAgICAgICAgbWFoam9uZ1Nwcml0ZXMucHVzaChcInJlZFwiKTtcbiAgICAgICAgbWFoam9uZ1Nwcml0ZXMucHVzaChcImdyZWVuXCIpO1xuICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwid2hpdGVcIik7XG4gICAgICAgIFxuICAgICAgICAvL+S4nOilv+WNl+WMl+mjjlxuICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwid2luZF9lYXN0XCIpO1xuICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwid2luZF93ZXN0XCIpO1xuICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwid2luZF9zb3V0aFwiKTtcbiAgICAgICAgbWFoam9uZ1Nwcml0ZXMucHVzaChcIndpbmRfbm9ydGhcIik7XG4gICAgICAgIFxuICAgICAgICAvL+aYpeWkj+eni+WGrFxuICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwic3ByaW5nXCIpO1xuICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwic3VtbWVyXCIpO1xuICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwiYXV0dW1uXCIpO1xuICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwid2ludGVyXCIpO1xuICAgICAgICAgXG4gICAgICAgIC8v5qKF5YWw56u56I+KIFxuICAgICAgICBtYWhqb25nU3ByaXRlcy5wdXNoKFwicGx1bVwiKTtcbiAgICAgICAgbWFoam9uZ1Nwcml0ZXMucHVzaChcIm9yY2hpZFwiKTtcbiAgICAgICAgbWFoam9uZ1Nwcml0ZXMucHVzaChcImJhbWJvb1wiKTtcbiAgICAgICAgbWFoam9uZ1Nwcml0ZXMucHVzaChcImNocnlzYW50aGVtdW1cIik7XG4gICAgfSxcbiAgICBcbiAgICBnZXRNYWhqb25nU3ByaXRlQnlJRDpmdW5jdGlvbihpZCl7XG4gICAgICAgIHJldHVybiBtYWhqb25nU3ByaXRlc1tpZF07XG4gICAgfSxcbiAgICBcbiAgICBnZXRNYWhqb25nVHlwZTpmdW5jdGlvbihpZCl7XG4gICAgICBpZihpZCA+PSAwICYmIGlkIDwgOSl7XG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKGlkID49IDkgJiYgaWQgPCAxOCl7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmKGlkID49IDE4ICYmIGlkIDwgMjcpe1xuICAgICAgICAgIHJldHVybiAyO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZ2V0U3ByaXRlRnJhbWVCeU1KSUQ6ZnVuY3Rpb24ocHJlLG1qaWQpe1xuICAgICAgICB2YXIgc3ByaXRlRnJhbWVOYW1lID0gdGhpcy5nZXRNYWhqb25nU3ByaXRlQnlJRChtamlkKTtcbiAgICAgICAgc3ByaXRlRnJhbWVOYW1lID0gcHJlICsgc3ByaXRlRnJhbWVOYW1lO1xuICAgICAgICBpZihwcmUgPT0gXCJNX1wiKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbUF0bGFzLmdldFNwcml0ZUZyYW1lKHNwcml0ZUZyYW1lTmFtZSk7ICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihwcmUgPT0gXCJCX1wiKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbUZvbGRBdGxhcy5nZXRTcHJpdGVGcmFtZShzcHJpdGVGcmFtZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYocHJlID09IFwiTF9cIil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0QXRsYXMuZ2V0U3ByaXRlRnJhbWUoc3ByaXRlRnJhbWVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHByZSA9PSBcIlJfXCIpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRBdGxhcy5nZXRTcHJpdGVGcmFtZShzcHJpdGVGcmFtZU5hbWUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBnZXRBdWRpb1VSTEJ5TUpJRDpmdW5jdGlvbihpZCl7XG4gICAgICAgIHZhciByZWFsSWQgPSAwO1xuICAgICAgICBpZihpZCA+PSAwICYmIGlkIDwgOSl7XG4gICAgICAgICAgICByZWFsSWQgPSBpZCArIDIxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoaWQgPj0gOSAmJiBpZCA8IDE4KXtcbiAgICAgICAgICAgIHJlYWxJZCA9IGlkIC0gODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGlkID49IDE4ICYmIGlkIDwgMjcpe1xuICAgICAgICAgICAgcmVhbElkID0gaWQgLSA3O1xuICAgICAgICB9XG4gICAgICAgICBpZihpZCA9PSAzMCl7XG4gICAgICAgICAgICByZWFsSWQgPSAzMTtcbiAgICAgICAgfSAgICBcblxuICAgICAgICBpZihpZCA9PSAzMSl7XG4gICAgICAgICAgICByZWFsSWQgPSA0MTtcbiAgICAgICAgfSAgICBcblxuICAgICAgICBpZihpZCA9PSAzMil7XG4gICAgICAgICAgICByZWFsSWQgPSA1MTtcbiAgICAgICAgfSAgICBcblxuICAgICAgICBpZihpZCA9PSAzMyl7XG4gICAgICAgICAgICByZWFsSWQgPSA2MTtcbiAgICAgICAgfSAgICBcblxuICAgICAgICBpZihpZCA9PSAyNyl7XG4gICAgICAgICAgICByZWFsSWQgPSA3MTtcbiAgICAgICAgfSAgICBcblxuICAgICAgICBpZihpZCA9PSAyOCl7XG4gICAgICAgICAgICByZWFsSWQgPSA4MTtcbiAgICAgICAgfSAgICBcblxuICAgICAgICBpZihpZCA9PSAyOSl7XG4gICAgICAgICAgICByZWFsSWQgPSA5MTtcbiAgICAgICAgfSAgICBcblxuXG4gICAgICAgIHJldHVybiBcIm52L1wiICsgcmVhbElkICsgXCIubXAzXCI7XG4gICAgfSxcbiAgICBcbiAgICBnZXRFbXB0eVNwcml0ZUZyYW1lOmZ1bmN0aW9uKHNpZGUpe1xuICAgICAgICBpZihzaWRlID09IFwidXBcIil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUF0bGFzLmdldFNwcml0ZUZyYW1lKFwiZV9tal9iX3VwXCIpO1xuICAgICAgICB9ICAgXG4gICAgICAgIGVsc2UgaWYoc2lkZSA9PSBcIm15c2VsZlwiKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5QXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJlX21qX2JfYm90dG9tXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoc2lkZSA9PSBcImxlZnRcIil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUF0bGFzLmdldFNwcml0ZUZyYW1lKFwiZV9tal9iX2xlZnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihzaWRlID09IFwicmlnaHRcIil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUF0bGFzLmdldFNwcml0ZUZyYW1lKFwiZV9tal9iX3JpZ2h0XCIpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBnZXRIb2xkc0VtcHR5U3ByaXRlRnJhbWU6ZnVuY3Rpb24oc2lkZSl7XG4gICAgICAgIGlmKHNpZGUgPT0gXCJ1cFwiKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtcHR5QXRsYXMuZ2V0U3ByaXRlRnJhbWUoXCJlX21qX3VwXCIpO1xuICAgICAgICB9ICAgXG4gICAgICAgIGVsc2UgaWYoc2lkZSA9PSBcIm15c2VsZlwiKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoc2lkZSA9PSBcImxlZnRcIil7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUF0bGFzLmdldFNwcml0ZUZyYW1lKFwiZV9tal9sZWZ0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoc2lkZSA9PSBcInJpZ2h0XCIpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1wdHlBdGxhcy5nZXRTcHJpdGVGcmFtZShcImVfbWpfcmlnaHRcIik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNvcnRNSjpmdW5jdGlvbihtYWhqb25ncyxkaW5ncXVlKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBtYWhqb25ncy5zb3J0KGZ1bmN0aW9uKGEsYil7XG4gICAgICAgICAgICBpZihkaW5ncXVlID49IDApe1xuICAgICAgICAgICAgICAgIHZhciB0MSA9IHNlbGYuZ2V0TWFoam9uZ1R5cGUoYSk7XG4gICAgICAgICAgICAgICAgdmFyIHQyID0gc2VsZi5nZXRNYWhqb25nVHlwZShiKTtcbiAgICAgICAgICAgICAgICBpZih0MSAhPSB0Mil7XG4gICAgICAgICAgICAgICAgICAgIGlmKGRpbmdxdWUgPT0gdDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZihkaW5ncXVlID09IHQyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBcbiAgICBnZXRTaWRlOmZ1bmN0aW9uKGxvY2FsSW5kZXgpe1xuICAgICAgICByZXR1cm4gdGhpcy5fc2lkZXNbbG9jYWxJbmRleF07XG4gICAgfSxcbiAgICBcbiAgICBnZXRQcmU6ZnVuY3Rpb24obG9jYWxJbmRleCl7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcmVzW2xvY2FsSW5kZXhdO1xuICAgIH0sXG4gICAgXG4gICAgZ2V0Rm9sZFByZTpmdW5jdGlvbihsb2NhbEluZGV4KXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbGRQcmVzW2xvY2FsSW5kZXhdO1xuICAgIH1cbn0pO1xuIiwiaWYod2luZG93LmlvID09IG51bGwpe1xuICAgIHdpbmRvdy5pbyA9IHJlcXVpcmUoXCJzb2NrZXQtaW9cIik7XG59XG4gXG52YXIgR2xvYmFsID0gY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcbiAgICBzdGF0aWNzOiB7XG4gICAgICAgIGlwOlwiXCIsXG4gICAgICAgIHNpbzpudWxsLFxuICAgICAgICBpc1Bpbmdpbmc6ZmFsc2UsXG4gICAgICAgIGZuRGlzY29ubmVjdDpudWxsLFxuICAgICAgICBoYW5kbGVyczp7fSxcbiAgICAgICAgYWRkSGFuZGxlcjpmdW5jdGlvbihldmVudCxmbil7XG4gICAgICAgICAgICBpZih0aGlzLmhhbmRsZXJzW2V2ZW50XSl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJldmVudDpcIiArIGV2ZW50ICsgXCInIGhhbmRsZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZC5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZXZlbnQgKyBcIihcIiArIHR5cGVvZihkYXRhKSArIFwiKTpcIiArIChkYXRhPyBkYXRhLnRvU3RyaW5nKCk6XCJudWxsXCIpKTtcbiAgICAgICAgICAgICAgICBpZihldmVudCAhPSBcImRpc2Nvbm5lY3RcIiAmJiB0eXBlb2YoZGF0YSkgPT0gXCJzdHJpbmdcIil7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmbihkYXRhKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcjsgXG4gICAgICAgICAgICBpZih0aGlzLnNpbyl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJyZWdpc3RlcjpmdW5jdGlvbiBcIiArIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpby5vbihldmVudCxoYW5kbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdDpmdW5jdGlvbihmbkNvbm5lY3QsZm5FcnJvcikge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgICAgICAncmVjb25uZWN0aW9uJzpmYWxzZSxcbiAgICAgICAgICAgICAgICAnZm9yY2UgbmV3IGNvbm5lY3Rpb24nOiB0cnVlLFxuICAgICAgICAgICAgICAgICd0cmFuc3BvcnRzJzpbJ3dlYnNvY2tldCcsICdwb2xsaW5nJ11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2lvID0gd2luZG93LmlvLmNvbm5lY3QodGhpcy5pcCxvcHRzKTtcbiAgICAgICAgICAgIHRoaXMuc2lvLm9uKCdyZWNvbm5lY3QnLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNpby5vbignY29ubmVjdCcsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICAgICAgc2VsZi5zaW8uY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmbkNvbm5lY3QoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zaW8ub24oJ2Rpc2Nvbm5lY3QnLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZGlzY29ubmVjdFwiKTtcbiAgICAgICAgICAgICAgICBzZWxmLnNpby5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zaW8ub24oJ2Nvbm5lY3RfZmFpbGVkJyxmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnY29ubmVjdF9mYWlsZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IodmFyIGtleSBpbiB0aGlzLmhhbmRsZXJzKXtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmhhbmRsZXJzW2tleV07XG4gICAgICAgICAgICAgICAgaWYodHlwZW9mKHZhbHVlKSA9PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgICAgICAgICAgICAgICBpZihrZXkgPT0gJ2Rpc2Nvbm5lY3QnKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZm5EaXNjb25uZWN0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVnaXN0ZXI6ZnVuY3Rpb24gXCIgKyBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaW8ub24oa2V5LHZhbHVlKTsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zdGFydEhlYXJiZWF0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBzdGFydEhlYXJiZWF0OmZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLnNpby5vbignZ2FtZV9wb25nJyxmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnYW1lX3BvbmcnKTtcbiAgICAgICAgICAgICAgICBzZWxmLmxhc3RSZWNpZXZlVGltZSA9IERhdGUubm93KCk7IFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmxhc3RSZWNpZXZlVGltZSA9IERhdGUubm93KCk7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygxKTtcbiAgICAgICAgICAgIGlmKCFzZWxmLmlzUGluZ2luZyl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coMSk7XG4gICAgICAgICAgICAgICAgc2VsZi5pc1BpbmdpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNldEludGVydmFsKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKDMpO1xuICAgICAgICAgICAgICAgICAgICBpZihzZWxmLnNpbyl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKERhdGUubm93KCkgLSBzZWxmLmxhc3RSZWNpZXZlVGltZSA+IDEwMDAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSw1MDAwKTtcbiAgICAgICAgICAgIH0gICBcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZDpmdW5jdGlvbihldmVudCxkYXRhKXtcbiAgICAgICAgICAgIGlmKHRoaXMuc2lvLmNvbm5lY3RlZCl7XG4gICAgICAgICAgICAgICAgaWYoZGF0YSAhPSBudWxsICYmICh0eXBlb2YoZGF0YSkgPT0gXCJvYmplY3RcIikpe1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGF0YSk7ICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zaW8uZW1pdChldmVudCxkYXRhKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBwaW5nOmZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB0aGlzLnNlbmQoJ2dhbWVfcGluZycpO1xuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgY2xvc2U6ZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjbG9zZScpO1xuICAgICAgICAgICAgaWYodGhpcy5zaW8gJiYgdGhpcy5zaW8uY29ubmVjdGVkKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNpby5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNpby5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaW8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYodGhpcy5mbkRpc2Nvbm5lY3Qpe1xuICAgICAgICAgICAgICAgIHRoaXMuZm5EaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbkRpc2Nvbm5lY3QgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgdGVzdDpmdW5jdGlvbihmblJlc3VsdCl7XG4gICAgICAgICAgICB2YXIgeGhyID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBmbiA9IGZ1bmN0aW9uKHJldCl7XG4gICAgICAgICAgICAgICAgZm5SZXN1bHQocmV0Lmlzb25saW5lKTtcbiAgICAgICAgICAgICAgICB4aHIgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgYXJyID0gdGhpcy5pcC5zcGxpdCgnOicpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudDpjYy52di51c2VyTWdyLmFjY291bnQsXG4gICAgICAgICAgICAgICAgc2lnbjpjYy52di51c2VyTWdyLnNpZ24sXG4gICAgICAgICAgICAgICAgaXA6YXJyWzBdLFxuICAgICAgICAgICAgICAgIHBvcnQ6YXJyWzFdLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeGhyID0gY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9pc19zZXJ2ZXJfb25saW5lXCIsZGF0YSxmbik7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgaWYoeGhyKXtcbiAgICAgICAgICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuUmVzdWx0KGZhbHNlKTsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sMTUwMCk7XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgICAgICAgICAgJ3JlY29ubmVjdGlvbic6ZmFsc2UsXG4gICAgICAgICAgICAgICAgJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndHJhbnNwb3J0cyc6Wyd3ZWJzb2NrZXQnLCAncG9sbGluZyddXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnRlc3RzaW8gPSB3aW5kb3cuaW8uY29ubmVjdCh0aGlzLmlwLG9wdHMpO1xuICAgICAgICAgICAgdGhpcy50ZXN0c2lvLm9uKCdjb25uZWN0JyxmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0Jyk7XG4gICAgICAgICAgICAgICAgc2VsZi50ZXN0c2lvLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgc2VsZi50ZXN0c2lvID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmblJlc3VsdCh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50ZXN0c2lvLm9uKCdjb25uZWN0X2Vycm9yJyxmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb25uZWN0X2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgIHNlbGYudGVzdHNpbyA9IG51bGw7XG4gICAgICAgICAgICAgICAgZm5SZXN1bHQoZmFsc2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAqL1xuICAgICAgICB9XG4gICAgfSxcbn0pOyIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLCAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBhdHRhY2hpbmdcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgICAgIF9ndW9odTpudWxsLFxuICAgICAgICBfaW5mbzpudWxsLFxuICAgICAgICBfZ3VvaHVUaW1lOi0xLFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ3VvaHUgPSBjYy5maW5kKFwiQ2FudmFzL3RpcF9ub3RpY2VcIik7XG4gICAgICAgIHRoaXMuX2d1b2h1LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5faW5mbyA9IGNjLmZpbmQoXCJDYW52YXMvdGlwX25vdGljZS9pbmZvXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMubm9kZS5vbigncHVzaF9ub3RpY2UnLGZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcbiAgICAgICAgICAgIHNlbGYuX2d1b2h1LmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBzZWxmLl9ndW9odVRpbWUgPSBkYXRhLnRpbWU7XG4gICAgICAgICAgICBzZWxmLl9pbmZvLnN0cmluZyA9IGRhdGEuaW5mbztcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcbiAgICAgICBpZih0aGlzLl9ndW9odVRpbWUgPiAwKXtcbiAgICAgICAgICAgdGhpcy5fZ3VvaHVUaW1lIC09IGR0O1xuICAgICAgICAgICBpZih0aGlzLl9ndW9odVRpbWUgPCAwKXtcbiAgICAgICAgICAgICAgIHRoaXMuX2d1b2h1LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICB9XG4gICAgICAgfVxuICAgIH0sXG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLCAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBhdHRhY2hpbmdcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnRuID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiYnRuX2JhY2tcIik7XG4gICAgICAgIGNjLnZ2LnV0aWxzLmFkZENsaWNrRXZlbnQoYnRuLHRoaXMubm9kZSxcIk9uQmFja1wiLFwib25CdG5DbGlja2VkXCIpOyAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBvbkJ0bkNsaWNrZWQ6ZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImJ0bl9iYWNrXCIpe1xuICAgICAgICAgICAgdGhpcy5ub2RlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZighY2MudnYpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdGhpcy5oaWRlaHVhcygpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGdhbWVDaGlsZCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIik7XG4gICAgICAgIHZhciBteXNlbGYgPSBnYW1lQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoXCJteXNlbGZcIik7XG4gICAgICAgIHZhciBwZW5nYW5ncm9vdCA9IG15c2VsZi5nZXRDaGlsZEJ5TmFtZShcInBlbmdnYW5nc1wiKTtcbiAgICAgICAgdmFyIHJlYWx3aWR0aCA9IGNjLmRpcmVjdG9yLmdldFZpc2libGVTaXplKCkud2lkdGg7XG4gICAgICAgIHZhciBzY2FsZSA9IHJlYWx3aWR0aCAvIDEyODA7XG4gICAgICAgIHBlbmdhbmdyb290LnNjYWxlWCAqPSBzY2FsZTtcbiAgICAgICAgcGVuZ2FuZ3Jvb3Quc2NhbGVZICo9IHNjYWxlO1xuICAgICAgICBcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLm5vZGUub24oJ3Blbmdfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIC8v5Yi35paw5omA5pyJ55qE54mMXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInBlbmdnYW5nIHBsYXRcIik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhLmRldGFpbCk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGRhdGEuZGV0YWlsO1xuICAgICAgICAgICAgc2VsZi5vblBlbmdHYW5nQ2hhbmdlZChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbmdfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIC8v5Yi35paw5omA5pyJ55qE54mMXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGRhdGEuZGV0YWlsKTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZGF0YS5kZXRhaWw7XG4gICAgICAgICAgICBzZWxmLm9uUGVuZ0dhbmdDaGFuZ2VkKGRhdGEuc2VhdERhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5vbignY2hpX25vdGlmeScsZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICAvL+WIt+aWsOaJgOacieeahOeJjFxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJwZW5nZ2FuZyBwbGF0XCIpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YS5kZXRhaWwpO1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcbiAgICAgICAgICAgIHNlbGYub25QZW5nR2FuZ0NoYW5nZWQoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnZXRodWFfbm90aWZ5JyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiZ2V0aHVhX25vdGlmeSBhY2NlcHRcIik7XG4gICAgICAgICAgICAvL+WIt+aWsOaJgOacieeahOeJjFxuICAgICAgICAgICAgdmFyIGRhdGEgPSBkYXRhLmRldGFpbDtcbiAgICAgICAgICAgIHNlbGYub25IdWFDaGFuZ2VkKGRhdGEpO1xuICAgICAgICAgICAgXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2JlZ2luJyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHNlbGYub25HYW1lQmVpbigpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzZWF0cyA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHM7XG4gICAgICAgIGZvcih2YXIgaSBpbiBzZWF0cyl7XG4gICAgICAgICAgICB0aGlzLm9uUGVuZ0dhbmdDaGFuZ2VkKHNlYXRzW2ldKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgLy/pmpDol4/miYDmnInoirHniYxcbiAgICBoaWRlaHVhczpmdW5jdGlvbigpe1xuICAgICAgICAvL+makOiXj+aJgOacieiKseeJjFxuICAgICAgICB2YXIgZ2FtZUNoaWxkID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKTtcbiAgICAgICAgdmFyIHNpZGVzID0gbmV3IEFycmF5KFxuICAgICAgICAgICAgXCJyaWdodFwiLFxuICAgICAgICAgICAgXCJsZWZ0XCIsXG4gICAgICAgICAgICBcInVwXCIsXG4gICAgICAgICAgICBcIm15c2VsZlwiKTtcbiAgICAgICAgZm9yKHZhciBqPSAwOyBqIDwgNCA7IGorKyl7XG4gICAgICAgICAgICB2YXIgc2lkZSA9IGdhbWVDaGlsZC5nZXRDaGlsZEJ5TmFtZShzaWRlc1tqXSk7XG4gICAgICAgICAgICB2YXIgaHVhc3Jvb3QgPSBzaWRlLmdldENoaWxkQnlOYW1lKFwiaHVhc1wiKTtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDAgOyBpIDwgaHVhc3Jvb3QuY2hpbGRyZW5Db3VudCA7IGkrKyl7XG4gICAgICAgICAgICAgICAgaHVhc3Jvb3QuY2hpbGRyZW5baV0uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICBvbkdhbWVCZWluOmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuaGlkZVNpZGUoXCJteXNlbGZcIik7XG4gICAgICAgIHRoaXMuaGlkZVNpZGUoXCJyaWdodFwiKTtcbiAgICAgICAgdGhpcy5oaWRlU2lkZShcInVwXCIpO1xuICAgICAgICB0aGlzLmhpZGVTaWRlKFwibGVmdFwiKTtcbiAgICAgICAgdGhpcy5oaWRlaHVhcygpO1xuICAgIH0sXG4gICAgXG4gICAgaGlkZVNpZGU6ZnVuY3Rpb24oc2lkZSl7XG4gICAgICAgIHZhciBnYW1lQ2hpbGQgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJnYW1lXCIpO1xuICAgICAgICB2YXIgbXlzZWxmID0gZ2FtZUNoaWxkLmdldENoaWxkQnlOYW1lKHNpZGUpO1xuICAgICAgICB2YXIgcGVuZ2FuZ3Jvb3QgPSBteXNlbGYuZ2V0Q2hpbGRCeU5hbWUoXCJwZW5nZ2FuZ3NcIik7XG4gICAgICAgIGlmKHBlbmdhbmdyb290KXtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwZW5nYW5ncm9vdC5jaGlsZHJlbkNvdW50OyArK2kpe1xuICAgICAgICAgICAgICAgIHBlbmdhbmdyb290LmNoaWxkcmVuW2ldLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBvblBlbmdHYW5nQ2hhbmdlZDpmdW5jdGlvbihzZWF0RGF0YSl7XG4gICAgICAgIFxuICAgICAgICBpZihzZWF0RGF0YS5hbmdhbmdzID09IG51bGwgJiYgc2VhdERhdGEuZGlhbmdhbmdzID09IG51bGwgJiYgc2VhdERhdGEud2FuZ2FuZ3MgPT0gbnVsbCAmJiBzZWF0RGF0YS5wZW5ncyA9PSBudWxsICYmIHNlYXREYXRhLmNoaXMgPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvY2FsSW5kZXggPSBjYy52di5nYW1lTmV0TWdyLmdldExvY2FsSW5kZXgoc2VhdERhdGEuc2VhdGluZGV4KTtcbiAgICAgICAgdmFyIHNpZGUgPSBjYy52di5tYWhqb25nbWdyLmdldFNpZGUobG9jYWxJbmRleCk7XG4gICAgICAgIHZhciBwcmUgPSBjYy52di5tYWhqb25nbWdyLmdldEZvbGRQcmUobG9jYWxJbmRleCk7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhcImxvY2FsSW5kZXggPSBcIiArIGxvY2FsSW5kZXgpO1xuICAgICAgICBjb25zb2xlLmxvZyhcInNpZGUgPSBcIiArIHNpZGUpO1xuICAgICAgICBjb25zb2xlLmxvZyhcInByZSA9IFwiICsgcHJlKTtcbiAgICAgICAgY29uc29sZS5sb2coXCJvblBlbmdHYW5nQ2hhbmdlZFwiICsgbG9jYWxJbmRleCk7XG4gICAgICAgICAgICBcbiAgICAgICAgdmFyIGdhbWVDaGlsZCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIik7XG4gICAgICAgIHZhciBteXNlbGYgPSBnYW1lQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoc2lkZSk7XG4gICAgICAgIHZhciBwZW5nYW5ncm9vdCA9IG15c2VsZi5nZXRDaGlsZEJ5TmFtZShcInBlbmdnYW5nc1wiKTtcbiAgICAgICAgXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwZW5nYW5ncm9vdC5jaGlsZHJlbkNvdW50OyArK2kpe1xuICAgICAgICAgICAgcGVuZ2FuZ3Jvb3QuY2hpbGRyZW5baV0uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy/liJ3lp4vljJbmnaDniYxcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgXG4gICAgICAgIHZhciBnYW5ncyA9IHNlYXREYXRhLmFuZ2FuZ3NcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGdhbmdzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBtamlkID0gZ2FuZ3NbaV07XG4gICAgICAgICAgICB0aGlzLmluaXRQZW5nQW5kR2FuZ3MocGVuZ2FuZ3Jvb3Qsc2lkZSxwcmUsaW5kZXgsbWppZCxcImFuZ2FuZ1wiKTtcbiAgICAgICAgICAgIGluZGV4Kys7ICAgIFxuICAgICAgICB9IFxuICAgICAgICB2YXIgZ2FuZ3MgPSBzZWF0RGF0YS5kaWFuZ2FuZ3NcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGdhbmdzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBtamlkID0gZ2FuZ3NbaV07XG4gICAgICAgICAgICB0aGlzLmluaXRQZW5nQW5kR2FuZ3MocGVuZ2FuZ3Jvb3Qsc2lkZSxwcmUsaW5kZXgsbWppZCxcImRpYW5nYW5nXCIpO1xuICAgICAgICAgICAgaW5kZXgrKzsgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhciBnYW5ncyA9IHNlYXREYXRhLndhbmdhbmdzXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBnYW5ncy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgbWppZCA9IGdhbmdzW2ldO1xuICAgICAgICAgICAgdGhpcy5pbml0UGVuZ0FuZEdhbmdzKHBlbmdhbmdyb290LHNpZGUscHJlLGluZGV4LG1qaWQsXCJ3YW5nYW5nXCIpO1xuICAgICAgICAgICAgaW5kZXgrKzsgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8v5Yid5aeL5YyW56Kw54mMXG4gICAgICAgIHZhciBwZW5ncyA9IHNlYXREYXRhLnBlbmdzXG4gICAgICAgIGlmKHBlbmdzKXtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBwZW5ncy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgdmFyIG1qaWQgPSBwZW5nc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRQZW5nQW5kR2FuZ3MocGVuZ2FuZ3Jvb3Qsc2lkZSxwcmUsaW5kZXgsbWppZCxcInBlbmdcIik7XG4gICAgICAgICAgICAgICAgaW5kZXgrKzsgICAgXG4gICAgICAgICAgICB9ICAgIFxuICAgICAgICB9ICBcbiAgICAgICAgXG4gICAgICAgIC8v5Yid5aeL5YyW5ZCD54mMXG4gICAgICAgIGNvbnNvbGUubG9nKFwi5Yid5aeL5YyW5ZCD54mMXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhzZWF0RGF0YSk7XG4gICAgICAgIHZhciBjaGlzID0gc2VhdERhdGEuY2hpcztcbiAgICAgICAgaWYoY2hpcyl7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2hpcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgdmFyIG1qaWQgPSBjaGlzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFBlbmdBbmRHYW5ncyhwZW5nYW5ncm9vdCxzaWRlLHByZSxpbmRleCxtamlkLFwiY2hpXCIpO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7ICAgIFxuICAgICAgICAgICAgfSAgICBcbiAgICAgICAgfSAgXG4gICAgICAgIFxuICAgICAgICAvL+WIneWni+WMluiKseeJjFxuICAgICAgICBjb25zb2xlLmxvZyhcIuWIneWni+WMluiKseeJjFwiKTtcbiAgICAgICAgY29uc29sZS5sb2coc2VhdERhdGEpO1xuICAgICAgICB2YXIgaHVhcyA9IHNlYXREYXRhLmh1YXM7XG4gICAgICAgIGlmKGh1YXMpe1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGh1YXMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgIHZhciBtamlkID0gaHVhc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uSHVhQ2hhbmdlZChzZWF0RGF0YSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGluZGV4Kys7ICAgIFxuICAgICAgICAgICAgfSAgICBcbiAgICAgICAgfSAgXG4gICAgfSxcbiAgICBcbiAgICBcbiAgICBcbiAgICBpbml0UGVuZ0FuZEdhbmdzOmZ1bmN0aW9uKHBlbmdhbmdyb290LHNpZGUscHJlLGluZGV4LG1qaWQsZmxhZyl7XG4gICAgICAgIHZhciBwZ3Jvb3QgPSBudWxsO1xuICAgICAgICBpZihwZW5nYW5ncm9vdC5jaGlsZHJlbkNvdW50IDw9IGluZGV4KXtcbiAgICAgICAgICAgIGlmKHNpZGUgPT0gXCJsZWZ0XCIgfHwgc2lkZSA9PSBcInJpZ2h0XCIpe1xuICAgICAgICAgICAgICAgIHBncm9vdCA9IGNjLmluc3RhbnRpYXRlKGNjLnZ2Lm1haGpvbmdtZ3IucGVuZ1ByZWZhYkxlZnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBwZ3Jvb3QgPSBjYy5pbnN0YW50aWF0ZShjYy52di5tYWhqb25nbWdyLnBlbmdQcmVmYWJTZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGVuZ2FuZ3Jvb3QuYWRkQ2hpbGQocGdyb290KTsgICAgXG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHBncm9vdCA9IHBlbmdhbmdyb290LmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIHBncm9vdC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihzaWRlID09IFwibGVmdFwiKXtcbiAgICAgICAgICAgIHBncm9vdC55ID0gLShpbmRleCAqIDI1ICogMyk7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHNpZGUgPT0gXCJyaWdodFwiKXtcbiAgICAgICAgICAgIHBncm9vdC55ID0gKGluZGV4ICogMjUgKiAzKTtcbiAgICAgICAgICAgIHBncm9vdC5zZXRMb2NhbFpPcmRlcigtaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoc2lkZSA9PSBcIm15c2VsZlwiKXtcbiAgICAgICAgICAgIHBncm9vdC54ID0gaW5kZXggKiA1NSAqIDMgKyBpbmRleCAqIDEwOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHBncm9vdC54ID0gLShpbmRleCAqIDU1KjMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwcml0ZXMgPSBwZ3Jvb3QuZ2V0Q29tcG9uZW50c0luQ2hpbGRyZW4oY2MuU3ByaXRlKTtcbiAgICAgICAgLy8gaWYoZmxhZyA9PSBcImNoaVwiKXtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKFwi5o6S5YiX5ZCD77yBXCIpO1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2cobWppZCk7XG4gICAgICAgIC8vICAgICBmb3IodmFyIHMgPSAwOyBzIDwgMzsgcysrKXtcbiAgICAgICAgLy8gICAgICAgICB2YXIgc3ByaXRlID0gc3ByaXRlc1tzXTtcbiAgICAgICAgLy8gICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKHByZSxtamlkW3NdKTtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIHJldHVybjtcbiAgICAgICAgLy8gfVxuICAgICAgICBpZihmbGFnID09IFwiY2hpXCIpe1xuICAgICAgICAgICAgdmFyIG1qaWQxID0gW10uY29uY2F0KG1qaWQpO1xuICAgICAgICAgICAgdmFyIHBhaSA9IG1qaWQxLnBvcCgpO1xuICAgICAgICAgICAgbWppZDEuc29ydChmdW5jdGlvbihhLGIpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGEpLSBwYXJzZUludChiKX0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBtamlkMVsyXSA9IG1qaWQxWzFdO1xuICAgICAgICAgICAgbWppZDFbMV0gPSBtamlkMVswXTtcbiAgICAgICAgICAgIG1qaWQxWzBdID0gcGFpO1xuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgcyA9IDA7IHMgPCBzcHJpdGVzLmxlbmd0aDsgKytzKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW4geHVuaHVhblwiKTtcbiAgICAgICAgICAgIHZhciBzcHJpdGUgPSBzcHJpdGVzW3NdO1xuICAgICAgICAgICAgaWYoc3ByaXRlLm5vZGUubmFtZSA9PSBcImdhbmdcIil7XG4gICAgICAgICAgICAgICAgdmFyIGlzR2FuZyA9IGZsYWcgIT0gXCJwZW5nXCI7XG4gICAgICAgICAgICAgICAgc3ByaXRlLm5vZGUuYWN0aXZlID0gaXNHYW5nO1xuICAgICAgICAgICAgICAgIHNwcml0ZS5ub2RlLnNjYWxlWCA9IDEuMDtcbiAgICAgICAgICAgICAgICBzcHJpdGUubm9kZS5zY2FsZVkgPSAxLjA7XG4gICAgICAgICAgICAgICAgaWYoZmxhZyA9PSBcImFuZ2FuZ1wiKXtcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRFbXB0eVNwcml0ZUZyYW1lKHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZihzaWRlID09IFwibXlzZWxmXCIgfHwgc2lkZSA9PSBcInVwXCIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLm5vZGUuc2NhbGVYID0gMS40O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ByaXRlLm5vZGUuc2NhbGVZID0gMS40OyAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQocHJlLG1qaWQpOyAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgXG4gICAgICAgICAgICAgICAgaWYgKCBmbGFnID09IFwicGVuZ1wiICkge1xuICAgICAgICAgICAgICAgICAgICBzcHJpdGUuc3ByaXRlRnJhbWUgPSBjYy52di5tYWhqb25nbWdyLmdldFNwcml0ZUZyYW1lQnlNSklEKHByZSxtamlkKTtcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZiAoZmxhZyA9PSBcImNoaVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZS5zcHJpdGVGcmFtZSA9IGNjLnZ2Lm1haGpvbmdtZ3IuZ2V0U3ByaXRlRnJhbWVCeU1KSUQocHJlLG1qaWQxW3NdKTtcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChwcmUsbWppZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgb25IdWFDaGFuZ2VkOmZ1bmN0aW9uKHNlYXREYXRhKXtcbiAgICAgICAgY29uc29sZS5sb2coXCJvbkh1YUNoYW5nZWQhISFcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKHNlYXREYXRhKTtcbiAgICAgICAgdmFyIGxvY2FsSW5kZXggPSBjYy52di5nYW1lTmV0TWdyLmdldExvY2FsSW5kZXgoc2VhdERhdGEuc2VhdGluZGV4KTtcbiAgICAgICAgdmFyIHNpZGUgPSBjYy52di5tYWhqb25nbWdyLmdldFNpZGUobG9jYWxJbmRleCk7XG4gICAgICAgIHZhciBwcmUgPSBjYy52di5tYWhqb25nbWdyLmdldEZvbGRQcmUobG9jYWxJbmRleCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgZ2FtZUNoaWxkID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZ2FtZVwiKTtcbiAgICAgICAgdmFyIHNpZGUgPSBnYW1lQ2hpbGQuZ2V0Q2hpbGRCeU5hbWUoc2lkZSk7XG4gICAgICAgIHZhciBodWFzID0gc2lkZS5nZXRDaGlsZEJ5TmFtZShcImh1YXNcIik7XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhzaWRlKTtcbiAgICAgICAgY29uc29sZS5sb2coaHVhcyk7XG4gICAgICAgIFxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2VhdERhdGEuaHVhcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInNob3cgaHVhIVwiK3NlYXREYXRhLmh1YXNbaV0pO1xuICAgICAgICAgICAgdmFyIG5vd2NoaWxkID0gaHVhcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIG5vd2NoaWxkLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhub3djaGlsZC5hY3RpdmUpO1xuICAgICAgICAgICAgdmFyIHNwcml0ZSA9IG5vd2NoaWxkLmdldENvbXBvbmVudChjYy5TcHJpdGUpO1xuICAgICAgICAgICAgc3ByaXRlLnNwcml0ZUZyYW1lID0gY2MudnYubWFoam9uZ21nci5nZXRTcHJpdGVGcmFtZUJ5TUpJRChwcmUsc2VhdERhdGEuaHVhc1tpXSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGluaXRIdWFzOmZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgIH1cblxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcblxuICAgIC8vIH0sXG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgICAgICBfcG9wdXByb290Om51bGwsXG4gICAgICAgIF9zZXR0aW5nczpudWxsLFxuICAgICAgICBfZGlzc29sdmVOb3RpY2U6bnVsbCxcbiAgICAgICAgXG4gICAgICAgIF9lbmRUaW1lOi0xLFxuICAgICAgICBfZXh0cmFJbmZvOm51bGwsXG4gICAgICAgIF9ub3RpY2VMYWJlbDpudWxsLFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNjLnZ2LnBvcHVwTWdyID0gdGhpcztcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3BvcHVwcm9vdCA9IGNjLmZpbmQoXCJDYW52YXMvcG9wdXBzXCIpO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncyA9IGNjLmZpbmQoXCJDYW52YXMvcG9wdXBzL3NldHRpbmdzXCIpO1xuICAgICAgICB0aGlzLl9kaXNzb2x2ZU5vdGljZSA9IGNjLmZpbmQoXCJDYW52YXMvcG9wdXBzL2Rpc3NvbHZlX25vdGljZVwiKTtcbiAgICAgICAgdGhpcy5fbm90aWNlTGFiZWwgPSB0aGlzLl9kaXNzb2x2ZU5vdGljZS5nZXRDaGlsZEJ5TmFtZShcImluZm9cIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY2xvc2VBbGwoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuYWRkQnRuSGFuZGxlcihcInNldHRpbmdzL2J0bl9jbG9zZVwiKTtcbiAgICAgICAgdGhpcy5hZGRCdG5IYW5kbGVyKFwic2V0dGluZ3MvYnRuX3NxanNmalwiKTtcbiAgICAgICAgdGhpcy5hZGRCdG5IYW5kbGVyKFwiZGlzc29sdmVfbm90aWNlL2J0bl9hZ3JlZVwiKTtcbiAgICAgICAgdGhpcy5hZGRCdG5IYW5kbGVyKFwiZGlzc29sdmVfbm90aWNlL2J0bl9yZWplY3RcIik7XG4gICAgICAgIHRoaXMuYWRkQnRuSGFuZGxlcihcImRpc3NvbHZlX25vdGljZS9idG5fb2tcIik7XG4gICAgICAgIFxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMubm9kZS5vbihcImRpc3NvbHZlX25vdGljZVwiLGZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgc2VsZi5zaG93RGlzc29sdmVOb3RpY2UoZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKFwiZGlzc29sdmVfY2FuY2VsXCIsZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICAgICAgc2VsZi5jbG9zZUFsbCgpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIFxuICAgIHN0YXJ0OmZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuZGlzc292ZURhdGEpe1xuICAgICAgICAgICAgdGhpcy5zaG93RGlzc29sdmVOb3RpY2UoY2MudnYuZ2FtZU5ldE1nci5kaXNzb3ZlRGF0YSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGFkZEJ0bkhhbmRsZXI6ZnVuY3Rpb24oYnRuTmFtZSl7XG4gICAgICAgIHZhciBidG4gPSBjYy5maW5kKFwiQ2FudmFzL3BvcHVwcy9cIiArIGJ0bk5hbWUpO1xuICAgICAgICB0aGlzLmFkZENsaWNrRXZlbnQoYnRuLHRoaXMubm9kZSxcIlBvcHVwTWdyXCIsXCJvbkJ0bkNsaWNrZWRcIik7XG4gICAgfSxcbiAgICBcbiAgICBhZGRDbGlja0V2ZW50OmZ1bmN0aW9uKG5vZGUsdGFyZ2V0LGNvbXBvbmVudCxoYW5kbGVyKXtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IG5ldyBjYy5Db21wb25lbnQuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgIGV2ZW50SGFuZGxlci50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGV2ZW50SGFuZGxlci5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIGV2ZW50SGFuZGxlci5oYW5kbGVyID0gaGFuZGxlcjtcblxuICAgICAgICB2YXIgY2xpY2tFdmVudHMgPSBub2RlLmdldENvbXBvbmVudChjYy5CdXR0b24pLmNsaWNrRXZlbnRzO1xuICAgICAgICBjbGlja0V2ZW50cy5wdXNoKGV2ZW50SGFuZGxlcik7XG4gICAgfSxcbiAgICBcbiAgICBvbkJ0bkNsaWNrZWQ6ZnVuY3Rpb24oZXZlbnQpe1xuICAgICAgICB0aGlzLmNsb3NlQWxsKCk7XG4gICAgICAgIHZhciBidG5OYW1lID0gZXZlbnQudGFyZ2V0Lm5hbWU7XG4gICAgICAgIGlmKGJ0bk5hbWUgPT0gXCJidG5fYWdyZWVcIil7XG4gICAgICAgICAgICBjYy52di5uZXQuc2VuZChcImRpc3NvbHZlX2FncmVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoYnRuTmFtZSA9PSBcImJ0bl9yZWplY3RcIil7XG4gICAgICAgICAgICBjYy52di5uZXQuc2VuZChcImRpc3NvbHZlX3JlamVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGJ0bk5hbWUgPT0gXCJidG5fc3Fqc2ZqXCIpe1xuICAgICAgICAgICAgY2MudnYubmV0LnNlbmQoXCJkaXNzb2x2ZV9yZXF1ZXN0XCIpOyBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgY2xvc2VBbGw6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5fcG9wdXByb290LmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zZXR0aW5ncy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGlzc29sdmVOb3RpY2UuYWN0aXZlID0gZmFsc2U7XG4gICAgfSxcbiAgICBcbiAgICBzaG93U2V0dGluZ3M6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5jbG9zZUFsbCgpO1xuICAgICAgICB0aGlzLl9wb3B1cHJvb3QuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MuYWN0aXZlID0gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIHNob3dEaXNzb2x2ZVJlcXVlc3Q6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5jbG9zZUFsbCgpO1xuICAgICAgICB0aGlzLl9wb3B1cHJvb3QuYWN0aXZlID0gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIHNob3dEaXNzb2x2ZU5vdGljZTpmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgdGhpcy5fZW5kVGltZSA9IERhdGUubm93KCkvMTAwMCArIGRhdGEudGltZTtcbiAgICAgICAgdGhpcy5fZXh0cmFJbmZvID0gXCJcIjtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGEuc3RhdGVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHZhciBiID0gZGF0YS5zdGF0ZXNbaV07XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdHNbaV0ubmFtZTtcbiAgICAgICAgICAgIGlmKGIpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJhSW5mbyArPSBcIlxcblvlt7LlkIzmhI9dIFwiKyBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHRyYUluZm8gKz0gXCJcXG5b5b6F56Gu6K6kXSBcIisgbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlQWxsKCk7XG4gICAgICAgIHRoaXMuX3BvcHVwcm9vdC5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kaXNzb2x2ZU5vdGljZS5hY3RpdmUgPSB0cnVlOztcbiAgICB9LFxuICAgIFxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgaWYodGhpcy5fZW5kVGltZSA+IDApe1xuICAgICAgICAgICAgdmFyIGxhc3RUaW1lID0gdGhpcy5fZW5kVGltZSAtIERhdGUubm93KCkgLyAxMDAwO1xuICAgICAgICAgICAgaWYobGFzdFRpbWUgPCAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmRUaW1lID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBtID0gTWF0aC5mbG9vcihsYXN0VGltZSAvIDYwKTtcbiAgICAgICAgICAgIHZhciBzID0gTWF0aC5jZWlsKGxhc3RUaW1lIC0gbSo2MCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIlwiO1xuICAgICAgICAgICAgaWYobSA+IDApe1xuICAgICAgICAgICAgICAgIHN0ciArPSBtICsgXCLliIZcIjsgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuX25vdGljZUxhYmVsLnN0cmluZyA9IHN0ciArIHMgKyBcIuenkuWQjuaIv+mXtOWwhuiHquWKqOino+aVo1wiICsgdGhpcy5fZXh0cmFJbmZvO1xuICAgICAgICB9XG4gICAgfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgICAgIHRhcmdldDpjYy5Ob2RlLFxuICAgICAgICBzcHJpdGU6Y2MuU3ByaXRlRnJhbWUsXG4gICAgICAgIGNoZWNrZWRTcHJpdGU6Y2MuU3ByaXRlRnJhbWUsXG4gICAgICAgIGNoZWNrZWQ6ZmFsc2UsXG4gICAgICAgIGdyb3VwSWQ6LTEsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZihjYy52di5yYWRpb2dyb3VwbWdyID09IG51bGwpe1xuICAgICAgICAgICAgdmFyIFJhZGlvR3JvdXBNZ3IgPSByZXF1aXJlKFwiUmFkaW9Hcm91cE1nclwiKTtcbiAgICAgICAgICAgIGNjLnZ2LnJhZGlvZ3JvdXBtZ3IgPSBuZXcgUmFkaW9Hcm91cE1ncigpO1xuICAgICAgICAgICAgY2MudnYucmFkaW9ncm91cG1nci5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2codHlwZW9mKGNjLnZ2LnJhZGlvZ3JvdXBtZ3IuYWRkKSk7XG4gICAgICAgIGNjLnZ2LnJhZGlvZ3JvdXBtZ3IuYWRkKHRoaXMpO1xuXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH0sXG4gICAgXG4gICAgcmVmcmVzaDpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgdGFyZ2V0U3ByaXRlID0gdGhpcy50YXJnZXQuZ2V0Q29tcG9uZW50KGNjLlNwcml0ZSk7XG4gICAgICAgIGlmKHRoaXMuY2hlY2tlZCl7XG4gICAgICAgICAgICB0YXJnZXRTcHJpdGUuc3ByaXRlRnJhbWUgPSB0aGlzLmNoZWNrZWRTcHJpdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHRhcmdldFNwcml0ZS5zcHJpdGVGcmFtZSA9IHRoaXMuc3ByaXRlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBjaGVjazpmdW5jdGlvbih2YWx1ZSl7XG4gICAgICAgIHRoaXMuY2hlY2tlZCA9IHZhbHVlO1xuICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9LFxuICAgIFxuICAgIG9uQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICBjYy52di5yYWRpb2dyb3VwbWdyLmNoZWNrKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIC8vIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG5cbiAgICAvLyB9LFxuICAgIFxuICAgIG9uRGVzdHJveTpmdW5jdGlvbigpe1xuICAgICAgICBpZihjYy52diAmJiBjYy52di5yYWRpb2dyb3VwbWdyKXtcbiAgICAgICAgICAgIGNjLnZ2LnJhZGlvZ3JvdXBtZ3IuZGVsKHRoaXMpOyAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCJjYy5DbGFzcyh7XG4gICAgZXh0ZW5kczogY2MuQ29tcG9uZW50LFxuXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICAvLyBmb286IHtcbiAgICAgICAgLy8gICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICAgICAgX2dyb3VwczpudWxsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBzID0ge307XG4gICAgfSxcbiAgICBcbiAgICBhZGQ6ZnVuY3Rpb24ocmFkaW9CdXR0b24pe1xuICAgICAgICB2YXIgZ3JvdXBJZCA9IHJhZGlvQnV0dG9uLmdyb3VwSWQ7IFxuICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMuX2dyb3Vwc1tncm91cElkXTtcbiAgICAgICAgaWYoYnV0dG9ucyA9PSBudWxsKXtcbiAgICAgICAgICAgIGJ1dHRvbnMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2dyb3Vwc1tncm91cElkXSA9IGJ1dHRvbnM7IFxuICAgICAgICB9XG4gICAgICAgIGJ1dHRvbnMucHVzaChyYWRpb0J1dHRvbik7XG4gICAgfSxcbiAgICBcbiAgICBkZWw6ZnVuY3Rpb24ocmFkaW9CdXR0b24pe1xuICAgICAgICB2YXIgZ3JvdXBJZCA9IHJhZGlvQnV0dG9uLmdyb3VwSWQ7XG4gICAgICAgIHZhciBidXR0b25zID0gdGhpcy5fZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgICBpZihidXR0b25zID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWR4ID0gYnV0dG9ucy5pbmRleE9mKHJhZGlvQnV0dG9uKTtcbiAgICAgICAgaWYoaWR4ICE9IC0xKXtcbiAgICAgICAgICAgIGJ1dHRvbnMuc3BsaWNlKGlkeCwxKTsgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBpZihidXR0b25zLmxlbmd0aCA9PSAwKXtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ncm91cHNbZ3JvdXBJZF0gICBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgY2hlY2s6ZnVuY3Rpb24ocmFkaW9CdXR0b24pe1xuICAgICAgICB2YXIgZ3JvdXBJZCA9IHJhZGlvQnV0dG9uLmdyb3VwSWQ7XG4gICAgICAgIHZhciBidXR0b25zID0gdGhpcy5fZ3JvdXBzW2dyb3VwSWRdO1xuICAgICAgICBpZihidXR0b25zID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuOyBcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYnV0dG9ucy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgYnRuID0gYnV0dG9uc1tpXTtcbiAgICAgICAgICAgIGlmKGJ0biA9PSByYWRpb0J1dHRvbil7XG4gICAgICAgICAgICAgICAgYnRuLmNoZWNrKHRydWUpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgYnRuLmNoZWNrKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAgICAgICAgXG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICAgICAgX3JlY29ubmVjdDpudWxsLFxuICAgICAgICBfbGJsVGlwOm51bGwsXG4gICAgICAgIF9sYXN0UGluZzowLFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVjb25uZWN0ID0gY2MuZmluZChcIkNhbnZhcy9yZWNvbm5lY3RcIik7XG4gICAgICAgIHRoaXMuX2xibFRpcCA9IGNjLmZpbmQoXCJDYW52YXMvcmVjb25uZWN0L3RpcFwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIFxuICAgICAgICB2YXIgZm5UZXN0U2VydmVyT24gPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgY2MudnYubmV0LnRlc3QoZnVuY3Rpb24ocmV0KXtcbiAgICAgICAgICAgICAgIGlmKHJldCl7XG4gICAgICAgICAgICAgICAgICAgdmFyIHJvb21JZCA9IGNjLnZ2LnVzZXJNZ3Iub2xkUm9vbUlkIFxuICAgICAgICAgICAgICAgICAgICBpZiggcm9vbUlkICE9IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2MudnYudXNlck1nci5vbGRSb29tSWQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2MudnYudXNlck1nci5lbnRlclJvb20ocm9vbUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoJ2hhbGwnKTsgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9jYy5kaXJlY3Rvci5sb2FkU2NlbmUoJ2hhbGwnKTsgIFxuICAgICAgICAgICAgICAgICAgICAvL2NjLmRpcmVjdG9yLmxvYWRTY2VuZSgnbWpnYW1lJyk7ICBcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmblRlc3RTZXJ2ZXJPbiwxMDAwMCk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICBzZWxmLm5vZGUub2ZmKCdkaXNjb25uZWN0Jyxmbik7XG4gICAgICAgICAgICBzZWxmLl9yZWNvbm5lY3QuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuVGVzdFNlcnZlck9uKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnNvbGUubG9nKFwiYWRhc2ZkYXNkZnNkZlwiKTtcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdkaXNjb25uZWN0Jyxmbik7XG4gICAgfSxcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG4gICAgICAgIGlmKHRoaXMuX3JlY29ubmVjdC5hY3RpdmUpe1xuICAgICAgICAgICAgdmFyIHQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSAlIDQ7XG4gICAgICAgICAgICB0aGlzLl9sYmxUaXAuc3RyaW5nID0gXCLkuI7mnI3liqHlmajmlq3lvIDov57mjqXvvIzmraPlnKjlsJ3or5Xph43ov55cIjtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0OyArKyBpKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYmxUaXAuc3RyaW5nICs9ICcuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgICAgICBfbmV4dFBsYXlUaW1lOjEsXG4gICAgICAgIF9yZXBsYXk6bnVsbCxcbiAgICAgICAgX2lzUGxheWluZzp0cnVlLFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3JlcGxheSA9IGNjLmZpbmQoXCJDYW52YXMvcmVwbGF5XCIpO1xuICAgICAgICB0aGlzLl9yZXBsYXkuYWN0aXZlID0gY2MudnYucmVwbGF5TWdyLmlzUmVwbGF5KCk7XG4gICAgfSxcbiAgICBcbiAgICBvbkJ0blBhdXNlQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgIFxuICAgIG9uQnRuUGxheUNsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIG9uQnRuQmFja0NsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgY2MudnYucmVwbGF5TWdyLmNsZWFyKCk7XG4gICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IucmVzZXQoKTtcbiAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5yb29tSWQgPSBudWxsO1xuICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJoYWxsXCIpO1xuICAgIH0sXG5cbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG4gICAgICAgIGlmKGNjLnZ2KXtcbiAgICAgICAgICAgIGlmKHRoaXMuX2lzUGxheWluZyAmJiBjYy52di5yZXBsYXlNZ3IuaXNSZXBsYXkoKSA9PSB0cnVlICYmIHRoaXMuX25leHRQbGF5VGltZSA+IDApe1xuICAgICAgICAgICAgICAgIHRoaXMuX25leHRQbGF5VGltZSAtPSBkdDtcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9uZXh0UGxheVRpbWUgPCAwKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV4dFBsYXlUaW1lID0gY2MudnYucmVwbGF5TWdyLnRha2VBY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxufSk7XG4iLCJ2YXIgQUNUSU9OX0NIVVBBSSA9IDE7XG52YXIgQUNUSU9OX01PUEFJID0gMjtcbnZhciBBQ1RJT05fUEVORyA9IDM7XG52YXIgQUNUSU9OX0dBTkcgPSA0O1xudmFyIEFDVElPTl9IVSA9IDU7XG52YXIgQUNUSU9OX0NISSA9NztcbnZhciBBQ1RJT05fQlVIVUEgPTg7XG5cblxuY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgICAgIF9sYXN0QWN0aW9uOm51bGwsXG4gICAgICAgIF9hY3Rpb25SZWNvcmRzOm51bGwsXG4gICAgICAgIF9jdXJyZW50SW5kZXg6MCxcbiAgICB9LFxuXG4gICAgLy8gdXNlIHRoaXMgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgb25Mb2FkOiBmdW5jdGlvbiAoKSB7XG5cbiAgICB9LFxuICAgIFxuICAgIGNsZWFyOmZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLl9hY3Rpb25SZWNvcmRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY3VycmVudEluZGV4ID0gMDtcbiAgICB9LFxuICAgIFxuICAgIGluaXQ6ZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIHRoaXMuX2FjdGlvblJlY29yZHMgPSBkYXRhLmFjdGlvbl9yZWNvcmRzO1xuICAgICAgICBpZih0aGlzLl9hY3Rpb25SZWNvcmRzID09IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5fYWN0aW9uUmVjb3JkcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2N1cnJlbnRJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuX2xhc3RBY3Rpb24gPSBudWxsO1xuICAgIH0sXG4gICAgXG4gICAgaXNSZXBsYXk6ZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvblJlY29yZHMgIT0gbnVsbDsgICAgXG4gICAgfSxcbiAgICBcbiAgICBnZXROZXh0QWN0aW9uOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBhY3Rpb25zID0gW10uY29uY2F0KHRoaXMuX2FjdGlvblJlY29yZHMpO1xuICAgICAgICBhY3Rpb25zLnNwbGljZSgwLHRoaXMuX2N1cnJlbnRJbmRleCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGFjdGlvbnMpO1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5fY3VycmVudEluZGV4ID49IHRoaXMuX2FjdGlvblJlY29yZHMubGVuZ3RoKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpID0gdGhpcy5fYWN0aW9uUmVjb3Jkc1t0aGlzLl9jdXJyZW50SW5kZXgrK107XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLl9hY3Rpb25SZWNvcmRzW3RoaXMuX2N1cnJlbnRJbmRleCsrXTtcbiAgICAgICAgaWYoYWN0aW9uICE9IEFDVElPTl9DSEkgJiYgYWN0aW9uICE9IEFDVElPTl9CVUhVQSl7XG4gICAgICAgICAgICB2YXIgcGFpID0gdGhpcy5fYWN0aW9uUmVjb3Jkc1t0aGlzLl9jdXJyZW50SW5kZXgrK107XG4gICAgICAgICAgICByZXR1cm4ge3NpOnNpLHR5cGU6YWN0aW9uLHBhaTpwYWl9O1xuICAgICAgICB9ZWxzZSBpZiAoYWN0aW9uPT1BQ1RJT05fQ0hJKXtcbiAgICAgICAgICAgIHZhciBwYWkgPSB0aGlzLl9hY3Rpb25SZWNvcmRzW3RoaXMuX2N1cnJlbnRJbmRleCsrXTtcbiAgICAgICAgICAgIHZhciBjaGlncm91cCA9IHRoaXMuX2FjdGlvblJlY29yZHNbdGhpcy5fY3VycmVudEluZGV4KytdO1xuICAgICAgICAgICAgcmV0dXJuIHtzaTpzaSx0eXBlOmFjdGlvbixwYWk6cGFpLGNoaWdyb3VwOmNoaWdyb3VwfTtcbiAgICAgICAgfWVsc2UgaWYgKGFjdGlvbj09QUNUSU9OX0JVSFVBKXtcbiAgICAgICAgICAgIHZhciBidWh1YXMgPSB0aGlzLl9hY3Rpb25SZWNvcmRzW3RoaXMuX2N1cnJlbnRJbmRleCsrXTtcbiAgICAgICAgICAgIHZhciBob2xkcyA9IHRoaXMuX2FjdGlvblJlY29yZHNbdGhpcy5fY3VycmVudEluZGV4KytdO1xuICAgICAgICAgICAgcmV0dXJuIHtzaTpzaSx0eXBlOmFjdGlvbixidWh1YXM6YnVodWFzLGhvbGRzOmhvbGRzfTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgfSxcbiAgICBcbiAgICB0YWtlQWN0aW9uOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBhY3Rpb24gPSB0aGlzLmdldE5leHRBY3Rpb24oKTtcbiAgICAgICAgaWYodGhpcy5fbGFzdEFjdGlvbiAhPSBudWxsICYmIHRoaXMuX2xhc3RBY3Rpb24udHlwZSA9PSBBQ1RJT05fQ0hVUEFJKXtcbiAgICAgICAgICAgIGlmKGFjdGlvbiAhPSBudWxsICYmIGFjdGlvbi50eXBlICE9IEFDVElPTl9QRU5HICYmIGFjdGlvbi50eXBlICE9IEFDVElPTl9HQU5HICYmIGFjdGlvbi50eXBlICE9IEFDVElPTl9IVSl7XG4gICAgICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5kb0d1byh0aGlzLl9sYXN0QWN0aW9uLnNpLHRoaXMuX2xhc3RBY3Rpb24ucGFpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0QWN0aW9uID0gYWN0aW9uO1xuICAgICAgICBpZihhY3Rpb24gPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRBY3Rpb25EZWxheSA9IDEuMDtcbiAgICAgICAgaWYoYWN0aW9uLnR5cGUgPT0gQUNUSU9OX0NIVVBBSSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImNodXBhaVwiK2FjdGlvbi5wYWkpO1xuICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5kb0NodXBhaShhY3Rpb24uc2ksYWN0aW9uLnBhaSk7XG4gICAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoYWN0aW9uLnR5cGUgPT0gQUNUSU9OX01PUEFJKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwibW9wYWlcIithY3Rpb24ucGFpKTtcbiAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuZG9Nb3BhaShhY3Rpb24uc2ksYWN0aW9uLnBhaSk7XG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRvVHVybkNoYW5nZShhY3Rpb24uc2kpO1xuICAgICAgICAgICAgcmV0dXJuIDAuNTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGFjdGlvbi50eXBlID09IEFDVElPTl9QRU5HKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicGVuZ1wiK2FjdGlvbi5wYWkpO1xuICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5kb1BlbmcoYWN0aW9uLnNpLGFjdGlvbi5wYWkpO1xuICAgICAgICAgICAgY2MudnYuZ2FtZU5ldE1nci5kb1R1cm5DaGFuZ2UoYWN0aW9uLnNpKTtcbiAgICAgICAgICAgIHJldHVybiAxLjA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihhY3Rpb24udHlwZSA9PSBBQ1RJT05fR0FORyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImdhbmdcIithY3Rpb24ucGFpKTtcbiAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuZGlzcGF0Y2hFdmVudCgnaGFuZ2FuZ19ub3RpZnknLGFjdGlvbi5zaSk7XG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRvR2FuZyhhY3Rpb24uc2ksYWN0aW9uLnBhaSk7XG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRvVHVybkNoYW5nZShhY3Rpb24uc2kpO1xuICAgICAgICAgICAgcmV0dXJuIDEuMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGFjdGlvbi50eXBlID09IEFDVElPTl9IVSl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImh1XCIrYWN0aW9uLnBhaSk7XG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRvSHUoe3NlYXRpbmRleDphY3Rpb24uc2ksaHVwYWk6YWN0aW9uLnBhaSxpc3ppbW86ZmFsc2V9KTtcbiAgICAgICAgICAgIHJldHVybiAxLjU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihhY3Rpb24udHlwZSA9PSBBQ1RJT05fQ0hJKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2hpXCIrYWN0aW9uLnBhaSk7XG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRvQ2hpKGFjdGlvbi5zaSxhY3Rpb24ucGFpLGFjdGlvbi5jaGlncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gMS41O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoYWN0aW9uLnR5cGUgPT0gQUNUSU9OX0JVSFVBKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiY2hpXCIrYWN0aW9uLnBhaSk7XG4gICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmRvQnVodWFmb3JtZShhY3Rpb24uc2ksYWN0aW9uLmhvbGRzLGFjdGlvbi5idWh1YXMpO1xuICAgICAgICAgICAgIGNjLnZ2LmdhbWVOZXRNZ3IuZG9CdWh1YShhY3Rpb24uc2ksYWN0aW9uLmJ1aHVhcyk7XG4gICAgICAgICAgICByZXR1cm4gMS41O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgX3Nwckljb246bnVsbCxcbiAgICAgICAgX3podWFuZzpudWxsLFxuICAgICAgICBfcmVhZHk6bnVsbCxcbiAgICAgICAgX29mZmxpbmU6bnVsbCxcbiAgICAgICAgX2xibE5hbWU6bnVsbCxcbiAgICAgICAgX2xibFNjb3JlOm51bGwsXG4gICAgICAgIF9zY29yZUJnOm51bGwsXG4gICAgICAgIF9uZGRheWluZ2ppYTpudWxsLFxuICAgICAgICBfdm9pY2Vtc2c6bnVsbCxcbiAgICAgICAgXG4gICAgICAgIF9jaGF0QnViYmxlOm51bGwsXG4gICAgICAgIF9lbW9qaTpudWxsLFxuICAgICAgICBfbGFzdENoYXRUaW1lOi0xLFxuICAgICAgICBcbiAgICAgICAgX3VzZXJOYW1lOlwiXCIsXG4gICAgICAgIF9zY29yZTowLFxuICAgICAgICBfZGF5aW5namlhOmZhbHNlLFxuICAgICAgICBfaXNPZmZsaW5lOmZhbHNlLFxuICAgICAgICBfaXNSZWFkeTpmYWxzZSxcbiAgICAgICAgX2lzWmh1YW5nOmZhbHNlLFxuICAgICAgICBfdXNlcklkOm51bGwsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5fc3BySWNvbiA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImljb25cIikuZ2V0Q29tcG9uZW50KFwiSW1hZ2VMb2FkZXJcIik7XG4gICAgICAgIHRoaXMuX2xibE5hbWUgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJuYW1lXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCk7XG4gICAgICAgIHRoaXMuX2xibFNjb3JlID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwic2NvcmVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKTtcbiAgICAgICAgdGhpcy5fdm9pY2Vtc2cgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJ2b2ljZW1zZ1wiKTtcbiAgICAgICAgdGhpcy5feHVhbnBhaSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInh1YW5wYWlcIik7XG4gICAgICAgIHRoaXMucmVmcmVzaFh1YW5QYWlTdGF0ZSgpO1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5fdm9pY2Vtc2cpe1xuICAgICAgICAgICAgdGhpcy5fdm9pY2Vtc2cuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuX3Nwckljb24gJiYgdGhpcy5fc3BySWNvbi5nZXRDb21wb25lbnQoY2MuQnV0dG9uKSl7XG4gICAgICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KHRoaXMuX3Nwckljb24sdGhpcy5ub2RlLFwiU2VhdFwiLFwib25JY29uQ2xpY2tlZFwiKTsgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB0aGlzLl9vZmZsaW5lID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwib2ZmbGluZVwiKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3JlYWR5ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwicmVhZHlcIik7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl96aHVhbmcgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJ6aHVhbmdcIik7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9zY29yZUJnID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiWl9tb25leV9mcmFtZVwiKTtcbiAgICAgICAgdGhpcy5fbmRkYXlpbmdqaWEgPSB0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJkYXlpbmdqaWFcIik7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl9jaGF0QnViYmxlID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiQ2hhdEJ1YmJsZVwiKTtcbiAgICAgICAgaWYodGhpcy5fY2hhdEJ1YmJsZSAhPSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuX2NoYXRCdWJibGUuYWN0aXZlID0gZmFsc2U7ICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2Vtb2ppID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwiZW1vamlcIik7XG4gICAgICAgIGlmKHRoaXMuX2Vtb2ppICE9IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5fZW1vamkuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5fc3BySWNvbiAmJiB0aGlzLl91c2VySWQpe1xuICAgICAgICAgICAgdGhpcy5fc3BySWNvbi5zZXRVc2VySUQodGhpcy5fdXNlcklkKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgb25JY29uQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgaWNvblNwcml0ZSA9IHRoaXMuX3Nwckljb24ubm9kZS5nZXRDb21wb25lbnQoY2MuU3ByaXRlKTtcbiAgICAgICAgaWYodGhpcy5fdXNlcklkICE9IG51bGwgJiYgdGhpcy5fdXNlcklkID4gMCl7XG4gICAgICAgICAgIHZhciBzZWF0ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRTZWF0QnlJRCh0aGlzLl91c2VySWQpO1xuICAgICAgICAgICAgdmFyIHNleCA9IDA7XG4gICAgICAgICAgICBpZihjYy52di5iYXNlSW5mb01hcCl7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBjYy52di5iYXNlSW5mb01hcFt0aGlzLl91c2VySWRdO1xuICAgICAgICAgICAgICAgIGlmKGluZm8pe1xuICAgICAgICAgICAgICAgICAgICBzZXggPSBpbmZvLnNleDtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2MudnYudXNlcmluZm9TaG93LnNob3coc2VhdC5uYW1lLHNlYXQudXNlcmlkLGljb25TcHJpdGUsc2V4LHNlYXQuaXApOyAgICAgICAgIFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICByZWZyZXNoOmZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKHRoaXMuX2xibE5hbWUgIT0gbnVsbCl7XG4gICAgICAgICAgICB0aGlzLl9sYmxOYW1lLnN0cmluZyA9IHRoaXMuX3VzZXJOYW1lOyAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5fbGJsU2NvcmUgIT0gbnVsbCl7XG4gICAgICAgICAgICB0aGlzLl9sYmxTY29yZS5zdHJpbmcgPSB0aGlzLl9zY29yZTsgICAgICAgICAgICBcbiAgICAgICAgfSAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLl9uZGRheWluZ2ppYSAhPSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuX25kZGF5aW5namlhLmFjdGl2ZSA9IHRoaXMuX2RheWluZ2ppYSA9PSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLl9vZmZsaW5lKXtcbiAgICAgICAgICAgIHRoaXMuX29mZmxpbmUuYWN0aXZlID0gdGhpcy5faXNPZmZsaW5lICYmIHRoaXMuX3VzZXJOYW1lICE9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKHRoaXMuX3JlYWR5KXtcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5LmFjdGl2ZSA9IHRoaXMuX2lzUmVhZHkgJiYgKGNjLnZ2LmdhbWVOZXRNZ3IubnVtT2ZHYW1lcyA+IDApOyBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5femh1YW5nKXtcbiAgICAgICAgICAgIHRoaXMuX3podWFuZy5hY3RpdmUgPSB0aGlzLl9pc1podWFuZzsgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSB0aGlzLl91c2VyTmFtZSAhPSBudWxsICYmIHRoaXMuX3VzZXJOYW1lICE9IFwiXCI7IFxuICAgIH0sXG4gICAgXG4gICAgc2V0SW5mbyhuYW1lLHNjb3JlLGRheWluZ2ppYSl7XG4gICAgICAgIHRoaXMuX3VzZXJOYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5fc2NvcmUgPSBzY29yZTtcbiAgICAgICAgaWYodGhpcy5fc2NvcmUgPT0gbnVsbCl7XG4gICAgICAgICAgICB0aGlzLl9zY29yZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF5aW5namlhID0gZGF5aW5namlhO1xuICAgICAgICBcbiAgICAgICAgaWYodGhpcy5fc2NvcmVCZyAhPSBudWxsKXtcbiAgICAgICAgICAgIHRoaXMuX3Njb3JlQmcuYWN0aXZlID0gdGhpcy5fc2NvcmUgIT0gbnVsbDsgICAgICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHRoaXMuX2xibFNjb3JlICE9IG51bGwpe1xuICAgICAgICAgICAgdGhpcy5fbGJsU2NvcmUubm9kZS5hY3RpdmUgPSB0aGlzLl9zY29yZSAhPSBudWxsOyAgICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7ICAgIFxuICAgIH0sXG4gICAgXG4gICAgc2V0Wmh1YW5nOmZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgaWYodGhpcy5femh1YW5nKXtcbiAgICAgICAgICAgIHRoaXMuX3podWFuZy5hY3RpdmUgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc2V0UmVhZHk6ZnVuY3Rpb24oaXNSZWFkeSl7XG4gICAgICAgIHRoaXMuX2lzUmVhZHkgPSBpc1JlYWR5O1xuICAgICAgICBpZih0aGlzLl9yZWFkeSl7XG4gICAgICAgICAgICB0aGlzLl9yZWFkeS5hY3RpdmUgPSB0aGlzLl9pc1JlYWR5ICYmIChjYy52di5nYW1lTmV0TWdyLm51bU9mR2FtZXMgPiAwKTsgXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNldElEOmZ1bmN0aW9uKGlkKXtcbiAgICAgICAgdmFyIGlkTm9kZSA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImlkXCIpO1xuICAgICAgICBpZihpZE5vZGUpe1xuICAgICAgICAgICAgdmFyIGxibCA9IGlkTm9kZS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xuICAgICAgICAgICAgbGJsLnN0cmluZyA9IFwiSUQ6XCIgKyBpZDsgICAgICAgICAgICBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5fdXNlcklkID0gaWQ7XG4gICAgICAgIGlmKHRoaXMuX3Nwckljb24pe1xuICAgICAgICAgICAgdGhpcy5fc3BySWNvbi5zZXRVc2VySUQoaWQpOyBcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc2V0T2ZmbGluZTpmdW5jdGlvbihpc09mZmxpbmUpe1xuICAgICAgICB0aGlzLl9pc09mZmxpbmUgPSBpc09mZmxpbmU7XG4gICAgICAgIGlmKHRoaXMuX29mZmxpbmUpe1xuICAgICAgICAgICAgdGhpcy5fb2ZmbGluZS5hY3RpdmUgPSB0aGlzLl9pc09mZmxpbmUgJiYgdGhpcy5fdXNlck5hbWUgIT0gXCJcIjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgY2hhdDpmdW5jdGlvbihjb250ZW50KXtcbiAgICAgICAgaWYodGhpcy5fY2hhdEJ1YmJsZSA9PSBudWxsIHx8IHRoaXMuX2Vtb2ppID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Vtb2ppLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9jaGF0QnViYmxlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NoYXRCdWJibGUuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBjb250ZW50O1xuICAgICAgICB0aGlzLl9jaGF0QnViYmxlLmdldENoaWxkQnlOYW1lKFwiTmV3IExhYmVsXCIpLmdldENvbXBvbmVudChjYy5MYWJlbCkuc3RyaW5nID0gY29udGVudDtcbiAgICAgICAgdGhpcy5fbGFzdENoYXRUaW1lID0gMztcbiAgICB9LFxuICAgIFxuICAgIGVtb2ppOmZ1bmN0aW9uKGVtb2ppKXtcbiAgICAgICAgLy9lbW9qaSA9IEpTT04ucGFyc2UoZW1vamkpO1xuICAgICAgICBpZih0aGlzLl9lbW9qaSA9PSBudWxsIHx8IHRoaXMuX2Vtb2ppID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGVtb2ppKTtcbiAgICAgICAgdGhpcy5fY2hhdEJ1YmJsZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZW1vamkuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZW1vamkuZ2V0Q29tcG9uZW50KGNjLkFuaW1hdGlvbikucGxheShlbW9qaSk7XG4gICAgICAgIHRoaXMuX2xhc3RDaGF0VGltZSA9IDM7XG4gICAgfSxcbiAgICBcbiAgICB2b2ljZU1zZzpmdW5jdGlvbihzaG93KXtcbiAgICAgICAgaWYodGhpcy5fdm9pY2Vtc2cpe1xuICAgICAgICAgICAgdGhpcy5fdm9pY2Vtc2cuYWN0aXZlID0gc2hvdztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgcmVmcmVzaFh1YW5QYWlTdGF0ZTpmdW5jdGlvbigpe1xuICAgICAgICBpZih0aGlzLl94dWFucGFpID09IG51bGwpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLl94dWFucGFpLmFjdGl2ZSA9IGNjLnZ2LmdhbWVOZXRNZ3IuaXNIdWFuU2FuWmhhbmc7XG4gICAgICAgIGlmKGNjLnZ2LmdhbWVOZXRNZ3IuaXNIdWFuU2FuWmhhbmcgPT0gZmFsc2UpeyBcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgIFxuICAgICAgICB0aGlzLl94dWFucGFpLmdldENoaWxkQnlOYW1lKFwieHpcIikuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3h1YW5wYWkuZ2V0Q2hpbGRCeU5hbWUoXCJ4ZFwiKS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBzZWF0ID0gY2MudnYuZ2FtZU5ldE1nci5nZXRTZWF0QnlJRCh0aGlzLl91c2VySWQpO1xuICAgICAgICBpZihzZWF0KXtcbiAgICAgICAgICAgIGlmKHNlYXQuaHVhbnBhaXMgPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgdGhpcy5feHVhbnBhaS5nZXRDaGlsZEJ5TmFtZShcInh6XCIpLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHRoaXMuX3h1YW5wYWkuZ2V0Q2hpbGRCeU5hbWUoXCJ4ZFwiKS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgIFxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgaWYodGhpcy5fbGFzdENoYXRUaW1lID4gMCl7XG4gICAgICAgICAgICB0aGlzLl9sYXN0Q2hhdFRpbWUgLT0gZHQ7XG4gICAgICAgICAgICBpZih0aGlzLl9sYXN0Q2hhdFRpbWUgPCAwKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGF0QnViYmxlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vtb2ppLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vtb2ppLmdldENvbXBvbmVudChjYy5BbmltYXRpb24pLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLCAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBhdHRhY2hpbmdcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgICAgIF9idG5ZWE9wZW46bnVsbCxcbiAgICAgICAgX2J0bllYQ2xvc2U6bnVsbCxcbiAgICAgICAgX2J0bllZT3BlbjpudWxsLFxuICAgICAgICBfYnRuWVlDbG9zZTpudWxsLFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgdGhpcy5fYnRuWVhPcGVuID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwieWlueGlhb1wiKS5nZXRDaGlsZEJ5TmFtZShcImJ0bl95eF9vcGVuXCIpO1xuICAgICAgICB0aGlzLl9idG5ZWENsb3NlID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwieWlueGlhb1wiKS5nZXRDaGlsZEJ5TmFtZShcImJ0bl95eF9jbG9zZVwiKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2J0bllZT3BlbiA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInlpbnl1ZVwiKS5nZXRDaGlsZEJ5TmFtZShcImJ0bl95eV9vcGVuXCIpO1xuICAgICAgICB0aGlzLl9idG5ZWUNsb3NlID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwieWlueXVlXCIpLmdldENoaWxkQnlOYW1lKFwiYnRuX3l5X2Nsb3NlXCIpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5pbml0QnV0dG9uSGFuZGxlcih0aGlzLm5vZGUuZ2V0Q2hpbGRCeU5hbWUoXCJidG5fY2xvc2VcIikpO1xuICAgICAgICB0aGlzLmluaXRCdXR0b25IYW5kbGVyKHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImJ0bl9leGl0XCIpKTtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICB0aGlzLmluaXRCdXR0b25IYW5kbGVyKHRoaXMuX2J0bllYT3Blbik7XG4gICAgICAgIHRoaXMuaW5pdEJ1dHRvbkhhbmRsZXIodGhpcy5fYnRuWVhDbG9zZSk7XG4gICAgICAgIHRoaXMuaW5pdEJ1dHRvbkhhbmRsZXIodGhpcy5fYnRuWVlPcGVuKTtcbiAgICAgICAgdGhpcy5pbml0QnV0dG9uSGFuZGxlcih0aGlzLl9idG5ZWUNsb3NlKTtcbiAgICAgICAgXG5cbiAgICAgICAgdmFyIHNsaWRlciA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInlpbnhpYW9cIikuZ2V0Q2hpbGRCeU5hbWUoXCJwcm9ncmVzc1wiKTtcbiAgICAgICAgY2MudnYudXRpbHMuYWRkU2xpZGVFdmVudChzbGlkZXIsdGhpcy5ub2RlLFwiU2V0dGluZ3NcIixcIm9uU2xpZGVkXCIpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHNsaWRlciA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcInlpbnl1ZVwiKS5nZXRDaGlsZEJ5TmFtZShcInByb2dyZXNzXCIpO1xuICAgICAgICBjYy52di51dGlscy5hZGRTbGlkZUV2ZW50KHNsaWRlcix0aGlzLm5vZGUsXCJTZXR0aW5nc1wiLFwib25TbGlkZWRcIik7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnJlZnJlc2hWb2x1bWUoKTtcbiAgICB9LFxuICAgIFxuICAgIG9uU2xpZGVkOmZ1bmN0aW9uKHNsaWRlcil7XG4gICAgICAgIGlmKHNsaWRlci5ub2RlLnBhcmVudC5uYW1lID09IFwieWlueGlhb1wiKXtcbiAgICAgICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnNldFNGWFZvbHVtZShzbGlkZXIucHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoc2xpZGVyLm5vZGUucGFyZW50Lm5hbWUgPT0gXCJ5aW55dWVcIil7XG4gICAgICAgICAgICBjYy52di5hdWRpb01nci5zZXRCR01Wb2x1bWUoc2xpZGVyLnByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZnJlc2hWb2x1bWUoKTtcbiAgICB9LFxuICAgIFxuICAgIGluaXRCdXR0b25IYW5kbGVyOmZ1bmN0aW9uKGJ0bil7XG4gICAgICAgIGNjLnZ2LnV0aWxzLmFkZENsaWNrRXZlbnQoYnRuLHRoaXMubm9kZSxcIlNldHRpbmdzXCIsXCJvbkJ0bkNsaWNrZWRcIik7ICAgIFxuICAgIH0sXG4gICAgXG4gICAgcmVmcmVzaFZvbHVtZTpmdW5jdGlvbigpe1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fYnRuWVhDbG9zZS5hY3RpdmUgPSBjYy52di5hdWRpb01nci5zZnhWb2x1bWUgPiAwO1xuICAgICAgICB0aGlzLl9idG5ZWE9wZW4uYWN0aXZlID0gIXRoaXMuX2J0bllYQ2xvc2UuYWN0aXZlO1xuICAgICAgICBcbiAgICAgICAgdmFyIHl4ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwieWlueGlhb1wiKTtcbiAgICAgICAgdmFyIHdpZHRoID0gMzY4ICogY2MudnYuYXVkaW9NZ3Iuc2Z4Vm9sdW1lO1xuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB5eC5nZXRDaGlsZEJ5TmFtZShcInByb2dyZXNzXCIpXG4gICAgICAgIHByb2dyZXNzLmdldENvbXBvbmVudChjYy5TbGlkZXIpLnByb2dyZXNzID0gY2MudnYuYXVkaW9NZ3Iuc2Z4Vm9sdW1lO1xuICAgICAgICBwcm9ncmVzcy5nZXRDaGlsZEJ5TmFtZShcInByb2dyZXNzXCIpLndpZHRoID0gd2lkdGg7ICBcbiAgICAgICAgLy95eC5nZXRDaGlsZEJ5TmFtZShcImJ0bl9wcm9ncmVzc1wiKS54ID0gcHJvZ3Jlc3MueCArIHdpZHRoO1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2J0bllZQ2xvc2UuYWN0aXZlID0gY2MudnYuYXVkaW9NZ3IuYmdtVm9sdW1lID4gMDtcbiAgICAgICAgdGhpcy5fYnRuWVlPcGVuLmFjdGl2ZSA9ICF0aGlzLl9idG5ZWUNsb3NlLmFjdGl2ZTtcbiAgICAgICAgdmFyIHl5ID0gdGhpcy5ub2RlLmdldENoaWxkQnlOYW1lKFwieWlueXVlXCIpO1xuICAgICAgICB2YXIgd2lkdGggPSAzNjggKiBjYy52di5hdWRpb01nci5iZ21Wb2x1bWU7XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHl5LmdldENoaWxkQnlOYW1lKFwicHJvZ3Jlc3NcIik7XG4gICAgICAgIHByb2dyZXNzLmdldENvbXBvbmVudChjYy5TbGlkZXIpLnByb2dyZXNzID0gY2MudnYuYXVkaW9NZ3IuYmdtVm9sdW1lOyBcbiAgICAgICAgXG4gICAgICAgIHByb2dyZXNzLmdldENoaWxkQnlOYW1lKFwicHJvZ3Jlc3NcIikud2lkdGggPSB3aWR0aDtcbiAgICAgICAgLy95eS5nZXRDaGlsZEJ5TmFtZShcImJ0bl9wcm9ncmVzc1wiKS54ID0gcHJvZ3Jlc3MueCArIHdpZHRoO1xuICAgIH0sXG4gICAgXG4gICAgb25CdG5DbGlja2VkOmZ1bmN0aW9uKGV2ZW50KXtcbiAgICAgICAgaWYoZXZlbnQudGFyZ2V0Lm5hbWUgPT0gXCJidG5fY2xvc2VcIil7XG4gICAgICAgICAgICB0aGlzLm5vZGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImJ0bl9leGl0XCIpe1xuICAgICAgICAgICAgY2Muc3lzLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwid3hfYWNjb3VudFwiKTtcbiAgICAgICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInd4X3NpZ25cIik7XG4gICAgICAgICAgICBjYy5kaXJlY3Rvci5sb2FkU2NlbmUoXCJsb2dpblwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuX3l4X29wZW5cIil7XG4gICAgICAgICAgICBjYy52di5hdWRpb01nci5zZXRTRlhWb2x1bWUoMS4wKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFZvbHVtZSgpOyBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGV2ZW50LnRhcmdldC5uYW1lID09IFwiYnRuX3l4X2Nsb3NlXCIpe1xuICAgICAgICAgICAgY2MudnYuYXVkaW9NZ3Iuc2V0U0ZYVm9sdW1lKDApO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVm9sdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImJ0bl95eV9vcGVuXCIpe1xuICAgICAgICAgICAgY2MudnYuYXVkaW9NZ3Iuc2V0QkdNVm9sdW1lKDEpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoVm9sdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihldmVudC50YXJnZXQubmFtZSA9PSBcImJ0bl95eV9jbG9zZVwiKXtcbiAgICAgICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnNldEJHTVZvbHVtZSgwKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFZvbHVtZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgX2Fycm93Om51bGwsXG4gICAgICAgIF9wb2ludGVyOm51bGwsXG4gICAgICAgIF90aW1lTGFiZWw6bnVsbCxcbiAgICAgICAgX3RpbWU6LTEsXG4gICAgICAgIF9hbGVydFRpbWU6LTEsXG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICAvLyAgICB1cmw6IGNjLlRleHR1cmUyRCwgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHR5cGVvZiBkZWZhdWx0XG4gICAgICAgIC8vICAgIHNlcmlhbGl6YWJsZTogdHJ1ZSwgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICB2aXNpYmxlOiB0cnVlLCAgICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgZGlzcGxheU5hbWU6ICdGb28nLCAvLyBvcHRpb25hbFxuICAgICAgICAvLyAgICByZWFkb25seTogZmFsc2UsICAgIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAgICAgIC8vIH0sXG4gICAgICAgIC8vIC4uLlxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdhbWVDaGlsZCA9IHRoaXMubm9kZS5nZXRDaGlsZEJ5TmFtZShcImdhbWVcIik7XG4gICAgICAgIHRoaXMuX2Fycm93ID0gZ2FtZUNoaWxkLmdldENoaWxkQnlOYW1lKFwiYXJyb3dcIik7XG4gICAgICAgIHRoaXMuX3BvaW50ZXIgPSB0aGlzLl9hcnJvdy5nZXRDaGlsZEJ5TmFtZShcInBvaW50ZXJcIik7XG4gICAgICAgIHRoaXMuaW5pdFBvaW50ZXIoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3RpbWVMYWJlbCA9IHRoaXMuX2Fycm93LmdldENoaWxkQnlOYW1lKFwibGJsVGltZVwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpO1xuICAgICAgICB0aGlzLl90aW1lTGFiZWwuc3RyaW5nID0gXCIwMFwiO1xuICAgICAgICBcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5ub2RlLm9uKCdnYW1lX2JlZ2luJyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHNlbGYuaW5pdFBvaW50ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLm5vZGUub24oJ2dhbWVfY2h1cGFpJyxmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICAgIHNlbGYuaW5pdFBvaW50ZXIoKTtcbiAgICAgICAgICAgIHNlbGYuX3RpbWUgPSAxMDtcbiAgICAgICAgICAgIHNlbGYuX2FsZXJ0VGltZSA9IDM7XG4gICAgICAgIH0pO1xuICAgIH0sIFxuICAgIFxuICAgIGluaXRQb2ludGVyOmZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgdGhpcy5fYXJyb3cuYWN0aXZlID0gY2MudnYuZ2FtZU5ldE1nci5nYW1lc3RhdGUgPT0gXCJwbGF5aW5nXCI7XG4gICAgICAgIGlmKCF0aGlzLl9hcnJvdy5hY3RpdmUpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0dXJuID0gY2MudnYuZ2FtZU5ldE1nci50dXJuO1xuICAgICAgICB2YXIgbG9jYWxJbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3IuZ2V0TG9jYWxJbmRleCh0dXJuKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX3BvaW50ZXIuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdGhpcy5fcG9pbnRlci5jaGlsZHJlbltpXS5hY3RpdmUgPSBpID09IGxvY2FsSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8v5peL6L2s6aOO5ZCRXG4gICAgICAgIHZhciBidXR0b24gPSBjYy52di5nYW1lTmV0TWdyLmJ1dHRvbjtcbiAgICAgICAgdmFyIHNlYXRpbmRleCA9IGNjLnZ2LmdhbWVOZXRNZ3Iuc2VhdEluZGV4O1xuICAgICAgICB2YXIgYXJyb3dfZnJhbWUgPSB0aGlzLl9hcnJvdy5nZXRDaGlsZEJ5TmFtZShcIlpfYXJyb3dfZnJhbWVcIik7XG4gICAgICAgIHZhciBkaXMgPSBzZWF0aW5kZXggLSBidXR0b247XG4gICAgICAgIGFycm93X2ZyYW1lLnJvdGF0aW9uID0gZGlzICogOTA7XG4gICAgfSxcbiAgICBcbiAgICAvLyBjYWxsZWQgZXZlcnkgZnJhbWUsIHVuY29tbWVudCB0aGlzIGZ1bmN0aW9uIHRvIGFjdGl2YXRlIHVwZGF0ZSBjYWxsYmFja1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKGR0KSB7XG4gICAgICAgIGlmKHRoaXMuX3RpbWUgPiAwKXtcbiAgICAgICAgICAgIHRoaXMuX3RpbWUgLT0gZHQ7XG4gICAgICAgICAgICBpZih0aGlzLl9hbGVydFRpbWUgPiAwICYmIHRoaXMuX3RpbWUgPCB0aGlzLl9hbGVydFRpbWUpe1xuICAgICAgICAgICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnBsYXlTRlgoXCJ0aW1ldXBfYWxhcm0ubXAzXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FsZXJ0VGltZSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZSA9IFwiXCI7XG4gICAgICAgICAgICBpZih0aGlzLl90aW1lIDwgMCl7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciB0ID0gTWF0aC5jZWlsKHRoaXMuX3RpbWUpO1xuICAgICAgICAgICAgaWYodCA8IDEwKXtcbiAgICAgICAgICAgICAgICBwcmUgPSBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RpbWVMYWJlbC5zdHJpbmcgPSBwcmUgKyB0OyBcbiAgICAgICAgfVxuICAgIH0sXG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLCAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBhdHRhY2hpbmdcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgICAgIF91c2VyaW5mbzpudWxsLFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBvbkxvYWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYoY2MudnYgPT0gbnVsbCl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3VzZXJpbmZvID0gY2MuZmluZChcIkNhbnZhcy91c2VyaW5mb1wiKTtcbiAgICAgICAgdGhpcy5fdXNlcmluZm8uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIGNjLnZ2LnV0aWxzLmFkZENsaWNrRXZlbnQodGhpcy5fdXNlcmluZm8sdGhpcy5ub2RlLFwiVXNlckluZm9TaG93XCIsXCJvbkNsaWNrZWRcIik7XG4gICAgICAgIFxuICAgICAgICBjYy52di51c2VyaW5mb1Nob3cgPSB0aGlzO1xuICAgIH0sXG4gICAgXG4gICAgc2hvdzpmdW5jdGlvbihuYW1lLHVzZXJJZCxpY29uU3ByaXRlLHNleCxpcCl7XG4gICAgICAgIGlmKHVzZXJJZCAhPSBudWxsICYmIHVzZXJJZCA+IDApe1xuICAgICAgICAgICAgdGhpcy5fdXNlcmluZm8uYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3VzZXJpbmZvLmdldENoaWxkQnlOYW1lKFwiaWNvblwiKS5nZXRDb21wb25lbnQoY2MuU3ByaXRlKS5zcHJpdGVGcmFtZSA9IGljb25TcHJpdGUuc3ByaXRlRnJhbWU7XG4gICAgICAgICAgICB0aGlzLl91c2VyaW5mby5nZXRDaGlsZEJ5TmFtZShcIm5hbWVcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBuYW1lO1xuICAgICAgICAgICAgdGhpcy5fdXNlcmluZm8uZ2V0Q2hpbGRCeU5hbWUoXCJpcFwiKS5nZXRDb21wb25lbnQoY2MuTGFiZWwpLnN0cmluZyA9IFwiSVA6IFwiICsgaXAucmVwbGFjZShcIjo6ZmZmZjpcIixcIlwiKTtcbiAgICAgICAgICAgIHRoaXMuX3VzZXJpbmZvLmdldENoaWxkQnlOYW1lKFwiaWRcIikuZ2V0Q29tcG9uZW50KGNjLkxhYmVsKS5zdHJpbmcgPSBcIklEOiBcIiArIHVzZXJJZDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHNleF9mZW1hbGUgPSB0aGlzLl91c2VyaW5mby5nZXRDaGlsZEJ5TmFtZShcInNleF9mZW1hbGVcIik7XG4gICAgICAgICAgICBzZXhfZmVtYWxlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgc2V4X21hbGUgPSB0aGlzLl91c2VyaW5mby5nZXRDaGlsZEJ5TmFtZShcInNleF9tYWxlXCIpO1xuICAgICAgICAgICAgc2V4X21hbGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHNleCA9PSAxKXtcbiAgICAgICAgICAgICAgICBzZXhfbWFsZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgZWxzZSBpZihzZXggPT0gMil7XG4gICAgICAgICAgICAgICAgc2V4X2ZlbWFsZS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBvbkNsaWNrZWQ6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5fdXNlcmluZm8uYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIGFjY291bnQ6bnVsbCxcblx0ICAgIHVzZXJJZDpudWxsLFxuXHRcdHVzZXJOYW1lOm51bGwsXG5cdFx0bHY6MCxcblx0XHRleHA6MCxcblx0XHRjb2luczowLFxuXHRcdGdlbXM6MCxcblx0XHRzaWduOjAsXG4gICAgICAgIGlwOlwiXCIsXG4gICAgICAgIHNleDowLFxuICAgICAgICByb29tRGF0YTpudWxsLFxuICAgICAgICBvbGRSb29tSWQ6bnVsbCxcbiAgICB9LFxuICAgIFxuICAgIGd1ZXN0QXV0aDpmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYWNjb3VudCA9IGNjLmFyZ3NbXCJhY2NvdW50XCJdO1xuICAgICAgICBpZihhY2NvdW50ID09IG51bGwpe1xuICAgICAgICAgICAgYWNjb3VudCA9IGNjLnN5cy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImFjY291bnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGFjY291bnQgPT0gbnVsbCl7XG4gICAgICAgICAgICBhY2NvdW50ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGNjLnN5cy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImFjY291bnRcIixhY2NvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY2MudnYuaHR0cC5zZW5kUmVxdWVzdChcIi9ndWVzdFwiLHthY2NvdW50OmFjY291bnR9LHRoaXMub25BdXRoKTtcbiAgICB9LFxuICAgIFxuICAgIG9uQXV0aDpmdW5jdGlvbihyZXQpe1xuICAgICAgICB2YXIgc2VsZiA9IGNjLnZ2LnVzZXJNZ3I7XG4gICAgICAgIGlmKHJldC5lcnJjb2RlICE9PSAwKXtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJldC5lcnJtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBzZWxmLmFjY291bnQgPSByZXQuYWNjb3VudDtcbiAgICAgICAgICAgIHNlbGYuc2lnbiA9IHJldC5zaWduO1xuICAgICAgICAgICAgY2MudnYuaHR0cC51cmwgPSBcImh0dHA6Ly9cIiArIGNjLnZ2LlNJLmhhbGw7XG4gICAgICAgICAgICBzZWxmLmxvZ2luKCk7XG4gICAgICAgIH0gICBcbiAgICB9LFxuICAgIFxuICAgIGxvZ2luOmZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9uTG9naW4gPSBmdW5jdGlvbihyZXQpe1xuICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgIT09IDApe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJldC5lcnJtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBpZighcmV0LnVzZXJpZCl7XG4gICAgICAgICAgICAgICAgICAgIC8vanVtcCB0byByZWdpc3RlciB1c2VyIGluZm8uXG4gICAgICAgICAgICAgICAgICAgIGNjLmRpcmVjdG9yLmxvYWRTY2VuZShcImNyZWF0ZXJvbGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJldCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuYWNjb3VudCA9IHJldC5hY2NvdW50O1xuICAgICAgICBcdFx0XHRzZWxmLnVzZXJJZCA9IHJldC51c2VyaWQ7XG4gICAgICAgIFx0XHRcdHNlbGYudXNlck5hbWUgPSByZXQubmFtZTtcbiAgICAgICAgXHRcdFx0c2VsZi5sdiA9IHJldC5sdjtcbiAgICAgICAgXHRcdFx0c2VsZi5leHAgPSByZXQuZXhwO1xuICAgICAgICBcdFx0XHRzZWxmLmNvaW5zID0gcmV0LmNvaW5zO1xuICAgICAgICBcdFx0XHRzZWxmLmdlbXMgPSByZXQuZ2VtcztcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yb29tRGF0YSA9IHJldC5yb29taWQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2V4ID0gcmV0LnNleDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5pcCA9IHJldC5pcDtcbiAgICAgICAgXHRcdFx0Y2MuZGlyZWN0b3IubG9hZFNjZW5lKFwiaGFsbFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNjLnZ2LndjLnNob3coXCLmraPlnKjnmbvlvZXmuLjmiI9cIik7XG4gICAgICAgIGNjLnZ2Lmh0dHAuc2VuZFJlcXVlc3QoXCIvbG9naW5cIix7YWNjb3VudDp0aGlzLmFjY291bnQsc2lnbjp0aGlzLnNpZ259LG9uTG9naW4pO1xuICAgIH0sXG4gICAgXG4gICAgY3JlYXRlOmZ1bmN0aW9uKG5hbWUpe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBvbkNyZWF0ZSA9IGZ1bmN0aW9uKHJldCl7XG4gICAgICAgICAgICBpZihyZXQuZXJyY29kZSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmV0LmVycm1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHNlbGYubG9naW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgYWNjb3VudDp0aGlzLmFjY291bnQsXG4gICAgICAgICAgICBzaWduOnRoaXMuc2lnbixcbiAgICAgICAgICAgIG5hbWU6bmFtZVxuICAgICAgICB9O1xuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL2NyZWF0ZV91c2VyXCIsZGF0YSxvbkNyZWF0ZSk7ICAgIFxuICAgIH0sXG4gICAgXG4gICAgZW50ZXJSb29tOmZ1bmN0aW9uKHJvb21JZCxjYWxsYmFjayl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9uRW50ZXIgPSBmdW5jdGlvbihyZXQpe1xuICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgIT09IDApe1xuICAgICAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlID09IC0xKXtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbnRlclJvb20ocm9vbUlkLGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgfSw1MDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgY2MudnYud2MuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjayAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrICE9IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYy52di5nYW1lTmV0TWdyLmNvbm5lY3RHYW1lU2VydmVyKHJldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGFjY291bnQ6Y2MudnYudXNlck1nci5hY2NvdW50LFxuICAgICAgICAgICAgc2lnbjpjYy52di51c2VyTWdyLnNpZ24sXG4gICAgICAgICAgICByb29taWQ6cm9vbUlkXG4gICAgICAgIH07XG4gICAgICAgIGNjLnZ2LndjLnNob3coXCLmraPlnKjov5vlhaXmiL/pl7QgXCIgKyByb29tSWQpO1xuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL2VudGVyX3ByaXZhdGVfcm9vbVwiLGRhdGEsb25FbnRlcik7XG4gICAgfSxcbiAgICBnZXRIaXN0b3J5TGlzdDpmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIG9uR2V0ID0gZnVuY3Rpb24ocmV0KXtcbiAgICAgICAgICAgIGlmKHJldC5lcnJjb2RlICE9PSAwKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXQuZXJybXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmV0Lmhpc3RvcnkpO1xuICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrICE9IG51bGwpe1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXQuaGlzdG9yeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICBhY2NvdW50OmNjLnZ2LnVzZXJNZ3IuYWNjb3VudCxcbiAgICAgICAgICAgIHNpZ246Y2MudnYudXNlck1nci5zaWduLFxuICAgICAgICB9O1xuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL2dldF9oaXN0b3J5X2xpc3RcIixkYXRhLG9uR2V0KTtcbiAgICB9LFxuICAgIGdldEdhbWVzT2ZSb29tOmZ1bmN0aW9uKHV1aWQsY2FsbGJhY2spe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBvbkdldCA9IGZ1bmN0aW9uKHJldCl7XG4gICAgICAgICAgICBpZihyZXQuZXJyY29kZSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocmV0LmVycm1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJldC5kYXRhKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGFjY291bnQ6Y2MudnYudXNlck1nci5hY2NvdW50LFxuICAgICAgICAgICAgc2lnbjpjYy52di51c2VyTWdyLnNpZ24sXG4gICAgICAgICAgICB1dWlkOnV1aWQsXG4gICAgICAgIH07XG4gICAgICAgIGNjLnZ2Lmh0dHAuc2VuZFJlcXVlc3QoXCIvZ2V0X2dhbWVzX29mX3Jvb21cIixkYXRhLG9uR2V0KTtcbiAgICB9LFxuICAgIFxuICAgIGdldERldGFpbE9mR2FtZTpmdW5jdGlvbih1dWlkLGluZGV4LGNhbGxiYWNrKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgb25HZXQgPSBmdW5jdGlvbihyZXQpe1xuICAgICAgICAgICAgaWYocmV0LmVycmNvZGUgIT09IDApe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHJldC5lcnJtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhyZXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmV0LmRhdGEpO1xuICAgICAgICAgICAgfSAgICAgICBcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgYWNjb3VudDpjYy52di51c2VyTWdyLmFjY291bnQsXG4gICAgICAgICAgICBzaWduOmNjLnZ2LnVzZXJNZ3Iuc2lnbixcbiAgICAgICAgICAgIHV1aWQ6dXVpZCxcbiAgICAgICAgICAgIGluZGV4OmluZGV4LFxuICAgICAgICB9O1xuICAgICAgICBjYy52di5odHRwLnNlbmRSZXF1ZXN0KFwiL2dldF9kZXRhaWxfb2ZfZ2FtZVwiLGRhdGEsb25HZXQpO1xuICAgIH1cbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICAgICAgc2hvd0FjdDp0cnVlLFxuICAgIH0sXG4gICAgXG5cbiAgICBhZGRDbGlja0V2ZW50OmZ1bmN0aW9uKG5vZGUsdGFyZ2V0LGNvbXBvbmVudCxoYW5kbGVyKXtcbiAgICAgICAgY29uc29sZS5sb2coY29tcG9uZW50ICsgXCI6XCIgKyBoYW5kbGVyKTtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IG5ldyBjYy5Db21wb25lbnQuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgIGV2ZW50SGFuZGxlci50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGV2ZW50SGFuZGxlci5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIGV2ZW50SGFuZGxlci5oYW5kbGVyID0gaGFuZGxlcjtcblxuICAgICAgICB2YXIgY2xpY2tFdmVudHMgPSBub2RlLmdldENvbXBvbmVudChjYy5CdXR0b24pLmNsaWNrRXZlbnRzO1xuICAgICAgICBjbGlja0V2ZW50cy5wdXNoKGV2ZW50SGFuZGxlcik7XG4gICAgfSxcbiAgICBcbiAgICBhZGRTbGlkZUV2ZW50OmZ1bmN0aW9uKG5vZGUsdGFyZ2V0LGNvbXBvbmVudCxoYW5kbGVyKXtcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlciA9IG5ldyBjYy5Db21wb25lbnQuRXZlbnRIYW5kbGVyKCk7XG4gICAgICAgIGV2ZW50SGFuZGxlci50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIGV2ZW50SGFuZGxlci5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIGV2ZW50SGFuZGxlci5oYW5kbGVyID0gaGFuZGxlcjtcblxuICAgICAgICB2YXIgc2xpZGVFdmVudHMgPSBub2RlLmdldENvbXBvbmVudChjYy5TbGlkZXIpLnNsaWRlRXZlbnRzO1xuICAgICAgICBzbGlkZUV2ZW50cy5wdXNoKGV2ZW50SGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgLy8gdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcblxuICAgIC8vIH0sXG59KTtcbiIsInZhciByYWRpeCA9IDEyO1xudmFyIGJhc2UgPSAxMjggLSByYWRpeDtcbmZ1bmN0aW9uIGNyeXB0byh2YWx1ZSl7XG4gICAgdmFsdWUgLT0gYmFzZTtcbiAgICB2YXIgaCA9IE1hdGguZmxvb3IodmFsdWUvcmFkaXgpICsgYmFzZTtcbiAgICB2YXIgbCA9IHZhbHVlJXJhZGl4ICsgYmFzZTtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShoKSArIFN0cmluZy5mcm9tQ2hhckNvZGUobCk7XG59XG5cbnZhciBlbmNvZGVybWFwID0ge31cbnZhciBkZWNvZGVybWFwID0ge31cbmZvcih2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSl7XG4gICAgdmFyIGNvZGUgPSBudWxsO1xuICAgIHZhciB2ID0gaSArIDE7XG4gICAgaWYodiA+PSBiYXNlKXtcbiAgICAgICAgY29kZSA9IGNyeXB0byh2KTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgY29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUodik7ICAgIFxuICAgIH1cbiAgICBcbiAgICBlbmNvZGVybWFwW2ldID0gY29kZTtcbiAgICBkZWNvZGVybWFwW2NvZGVdID0gaTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlKGRhdGEpe1xuICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgdmFyIGEgPSAobGVuID4+IDI0KSAmIDB4ZmY7XG4gICAgdmFyIGIgPSAobGVuID4+IDE2KSAmIDB4ZmY7XG4gICAgdmFyIGMgPSAobGVuID4+IDgpICYgMHhmZjtcbiAgICB2YXIgZCA9IGxlbiAmIDB4ZmY7XG4gICAgY29udGVudCArPSBlbmNvZGVybWFwW2FdO1xuICAgIGNvbnRlbnQgKz0gZW5jb2Rlcm1hcFtiXTtcbiAgICBjb250ZW50ICs9IGVuY29kZXJtYXBbY107XG4gICAgY29udGVudCArPSBlbmNvZGVybWFwW2RdO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKXtcbiAgICAgICAgY29udGVudCArPSBlbmNvZGVybWFwW2RhdGFbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gY29udGVudDtcbn1cblxuZnVuY3Rpb24gZ2V0Q29kZShjb250ZW50LGluZGV4KXtcbiAgICB2YXIgYyA9IGNvbnRlbnQuY2hhckNvZGVBdChpbmRleCk7XG4gICAgaWYoYyA+PSBiYXNlKXtcbiAgICAgICAgYyA9IGNvbnRlbnQuY2hhckF0KGluZGV4KSArIGNvbnRlbnQuY2hhckF0KGluZGV4ICsgMSk7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIGMgPSBjb250ZW50LmNoYXJBdChpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBjO1xufVxuZnVuY3Rpb24gZGVjb2RlKGNvbnRlbnQpe1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IDQ7ICsraSl7XG4gICAgICAgIHZhciBjID0gZ2V0Q29kZShjb250ZW50LGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gYy5sZW5ndGg7XG4gICAgICAgIHZhciB2ID0gZGVjb2Rlcm1hcFtjXTtcbiAgICAgICAgbGVuIHw9IHYgPDwgKDMtaSkqODtcbiAgICB9XG4gICAgXG4gICAgdmFyIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgIHZhciBjbnQgPSAwO1xuICAgIHdoaWxlKGluZGV4IDwgY29udGVudC5sZW5ndGgpe1xuICAgICAgICB2YXIgYyA9IGdldENvZGUoY29udGVudCxpbmRleCk7XG4gICAgICAgIGluZGV4ICs9IGMubGVuZ3RoO1xuICAgICAgICBuZXdEYXRhW2NudF0gPSBkZWNvZGVybWFwW2NdO1xuICAgICAgICBjbnQrKztcbiAgICB9XG4gICAgcmV0dXJuIG5ld0RhdGE7XG59XG5cbmNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG5cbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8vIGZvbzoge1xuICAgICAgICAvLyAgICBkZWZhdWx0OiBudWxsLCAgICAgIC8vIFRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZCBvbmx5IHdoZW4gdGhlIGNvbXBvbmVudCBhdHRhY2hpbmdcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICB0byBhIG5vZGUgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgICAgIG9uUGxheUNhbGxiYWNrOm51bGwsXG4gICAgICAgIF92b2ljZU1lZGlhUGF0aDpudWxsLFxuICAgIH0sXG5cbiAgICAvLyB1c2UgdGhpcyBmb3IgaW5pdGlhbGl6YXRpb25cbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qXG4gICAgICAgIHZhciB1cmwgPSBjYy51cmwucmF3KFwicmVzb3VyY2VzL3Rlc3QuYW1yXCIpO1xuICAgICAgICB2YXIgZmlsZURhdGEgPSBqc2IuZmlsZVV0aWxzLmdldERhdGFGcm9tRmlsZSh1cmwpO1xuICAgICAgICB2YXIgY29udGVudCA9IFwiXCI7XG4gICAgICAgIHZhciBzZXAgPSBcIlwiO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZmlsZURhdGEubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgY29udGVudCArPSBzZXAgKyBmaWxlRGF0YVtpXTtcbiAgICAgICAgICAgIHNlcCA9IFwiLFwiO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgdXJsID0gY2MudXJsLnJhdyhcInJlc291cmNlcy90ZXN0LnR4dFwiKTtcbiAgICAgICAganNiLmZpbGVVdGlscy53cml0ZVN0cmluZ1RvRmlsZShjb250ZW50LHVybCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgdXJsID0gY2MudXJsLnJhdyhcInJlc291cmNlcy90ZXN0Mi5hbXJzXCIpO1xuICAgICAgICB2YXIgY29udGVudCA9IGVuY29kZShmaWxlRGF0YSk7XG4gICAgICAgIGpzYi5maWxlVXRpbHMud3JpdGVTdHJpbmdUb0ZpbGUoY29udGVudCx1cmwpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHVybCA9IGNjLnVybC5yYXcoXCJyZXNvdXJjZXMvdGVzdDIuYW1yXCIpO1xuICAgICAgICBqc2IuZmlsZVV0aWxzLndyaXRlRGF0YVRvRmlsZShkZWNvZGUoY29udGVudCksdXJsKTtcbiAgICAgICAgKi9cbiAgICAgICAgXG4gICAgICAgIGlmKGNjLnN5cy5pc05hdGl2ZSl7XG4gICAgICAgICAgICB0aGlzLl92b2ljZU1lZGlhUGF0aCA9IGpzYi5maWxlVXRpbHMuZ2V0V3JpdGFibGVQYXRoKCkgKyBcIi92b2ljZW1zZ3MvXCI7XG4gICAgICAgICAgICB0aGlzLnNldFN0b3JhZ2VEaXIodGhpcy5fdm9pY2VNZWRpYVBhdGgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBwcmVwYXJlOmZ1bmN0aW9uKGZpbGVuYW1lKXtcbiAgICAgICAgaWYoIWNjLnN5cy5pc05hdGl2ZSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2MudnYuYXVkaW9NZ3IucGF1c2VBbGwoKTtcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKGZpbGVuYW1lKTtcbiAgICAgICAgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19BTkRST0lEKXtcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QoXCJjb20vdml2aWdhbWVzL3ZvaWNlc2RrL1ZvaWNlUmVjb3JkZXJcIiwgXCJwcmVwYXJlXCIsIFwiKExqYXZhL2xhbmcvU3RyaW5nOylWXCIsZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1Mpe1xuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChcIlZvaWNlU0RLXCIsIFwicHJlcGFyZVJlY29yZDpcIixmaWxlbmFtZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHJlbGVhc2U6ZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWNjLnN5cy5pc05hdGl2ZSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2MudnYuYXVkaW9NZ3IucmVzdW1lQWxsKCk7XG4gICAgICAgIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfQU5EUk9JRCl7XG4gICAgICAgICAgICBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKFwiY29tL3ZpdmlnYW1lcy92b2ljZXNkay9Wb2ljZVJlY29yZGVyXCIsIFwicmVsZWFzZVwiLCBcIigpVlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfSU9TKXtcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QoXCJWb2ljZVNES1wiLCBcImZpbmlzaFJlY29yZFwiKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgY2FuY2VsOmZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNjLnZ2LmF1ZGlvTWdyLnJlc3VtZUFsbCgpO1xuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpe1xuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChcImNvbS92aXZpZ2FtZXMvdm9pY2VzZGsvVm9pY2VSZWNvcmRlclwiLCBcImNhbmNlbFwiLCBcIigpVlwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfSU9TKXtcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QoXCJWb2ljZVNES1wiLCBcImNhbmNlbFJlY29yZFwiKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3cml0ZVZvaWNlOmZ1bmN0aW9uKGZpbGVuYW1lLHZvaWNlRGF0YSl7XG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKHZvaWNlRGF0YSAmJiB2b2ljZURhdGEubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICB2YXIgZmlsZURhdGEgPSBkZWNvZGUodm9pY2VEYXRhKTtcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLl92b2ljZU1lZGlhUGF0aCArIGZpbGVuYW1lO1xuICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlKGZpbGVuYW1lKTtcbiAgICAgICAgICAgIGpzYi5maWxlVXRpbHMud3JpdGVEYXRhVG9GaWxlKGZpbGVEYXRhLHVybCk7IFxuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBjbGVhckNhY2hlOmZ1bmN0aW9uKGZpbGVuYW1lKXtcbiAgICAgICAgaWYoY2Muc3lzLmlzTmF0aXZlKXtcbiAgICAgICAgICAgIHZhciB1cmwgPSB0aGlzLl92b2ljZU1lZGlhUGF0aCArIGZpbGVuYW1lO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImNoZWNrIGZpbGU6XCIgKyB1cmwpO1xuICAgICAgICAgICAgaWYoanNiLmZpbGVVdGlscy5pc0ZpbGVFeGlzdCh1cmwpKXtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicmVtb3ZlOlwiICsgdXJsKTtcbiAgICAgICAgICAgICAgICBqc2IuZmlsZVV0aWxzLnJlbW92ZUZpbGUodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGpzYi5maWxlVXRpbHMuaXNGaWxlRXhpc3QodXJsICsgXCIud2F2XCIpKXtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwicmVtb3ZlOlwiICsgdXJsICsgXCIud2F2XCIpO1xuICAgICAgICAgICAgICAgIGpzYi5maWxlVXRpbHMucmVtb3ZlRmlsZSh1cmwgKyBcIi53YXZcIik7XG4gICAgICAgICAgICB9ICAgXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHBsYXk6ZnVuY3Rpb24oZmlsZW5hbWUpe1xuICAgICAgICBpZighY2Muc3lzLmlzTmF0aXZlKXtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYy52di5hdWRpb01nci5wYXVzZUFsbCgpO1xuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpe1xuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChcImNvbS92aXZpZ2FtZXMvdm9pY2VzZGsvVm9pY2VQbGF5ZXJcIiwgXCJwbGF5XCIsIFwiKExqYXZhL2xhbmcvU3RyaW5nOylWXCIsZmlsZW5hbWUpOyBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfSU9TKXtcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QoXCJWb2ljZVNES1wiLCBcInBsYXk6XCIsZmlsZW5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHN0b3A6ZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIWNjLnN5cy5pc05hdGl2ZSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2MudnYuYXVkaW9NZ3IucmVzdW1lQWxsKCk7XG4gICAgICAgIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfQU5EUk9JRCl7XG4gICAgICAgICAgICBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKFwiY29tL3ZpdmlnYW1lcy92b2ljZXNkay9Wb2ljZVBsYXllclwiLCBcInN0b3BcIiwgXCIoKVZcIik7IFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoY2Muc3lzLm9zID09IGNjLnN5cy5PU19JT1Mpe1xuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChcIlZvaWNlU0RLXCIsIFwic3RvcFBsYXlcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgZ2V0Vm9pY2VMZXZlbDpmdW5jdGlvbihtYXhMZXZlbCl7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXhMZXZlbCArIDEpO1xuICAgICAgICBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0FORFJPSUQpeyBcbiAgICAgICAgICAgIHJldHVybiBqc2IucmVmbGVjdGlvbi5jYWxsU3RhdGljTWV0aG9kKFwiY29tL3ZpdmlnYW1lcy92b2ljZXNkay9Wb2ljZVJlY29yZGVyXCIsIFwiZ2V0Vm9pY2VMZXZlbFwiLCBcIihJKUlcIixtYXhMZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihjYy5zeXMub3MgPT0gY2Muc3lzLk9TX0lPUyl7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXhMZXZlbCArIDEpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBnZXRWb2ljZURhdGE6ZnVuY3Rpb24oZmlsZW5hbWUpe1xuICAgICAgICBpZihjYy5zeXMuaXNOYXRpdmUpe1xuICAgICAgICAgICAgdmFyIHVybCA9IHRoaXMuX3ZvaWNlTWVkaWFQYXRoICsgZmlsZW5hbWU7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcImdldFZvaWNlRGF0YTpcIiArIHVybCk7XG4gICAgICAgICAgICB2YXIgZmlsZURhdGEgPSBqc2IuZmlsZVV0aWxzLmdldERhdGFGcm9tRmlsZSh1cmwpO1xuICAgICAgICAgICAgaWYoZmlsZURhdGEpe1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gZW5jb2RlKGZpbGVEYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9LFxuICAgIFxuICAgIGRvd25sb2FkOmZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgIH0sXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICAvLyB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuXG4gICAgLy8gfSxcbiAgICBcbiAgICBzZXRTdG9yYWdlRGlyOmZ1bmN0aW9uKGRpcil7XG4gICAgICAgIGlmKCFjYy5zeXMuaXNOYXRpdmUpe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfQU5EUk9JRCl7IFxuICAgICAgICAgICAganNiLnJlZmxlY3Rpb24uY2FsbFN0YXRpY01ldGhvZChcImNvbS92aXZpZ2FtZXMvdm9pY2VzZGsvVm9pY2VSZWNvcmRlclwiLCBcInNldFN0b3JhZ2VEaXJcIiwgXCIoTGphdmEvbGFuZy9TdHJpbmc7KVZcIixkaXIpOyAgICBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGNjLnN5cy5vcyA9PSBjYy5zeXMuT1NfSU9TKXtcbiAgICAgICAgICAgIGpzYi5yZWZsZWN0aW9uLmNhbGxTdGF0aWNNZXRob2QoXCJWb2ljZVNES1wiLCBcInNldFN0b3JhZ2VEaXI6XCIsZGlyKTtcbiAgICAgICAgICAgIGlmKCFqc2IuZmlsZVV0aWxzLmlzRGlyZWN0b3J5RXhpc3QoZGlyKSl7XG4gICAgICAgICAgICAgICAganNiLmZpbGVVdGlscy5jcmVhdGVEaXJlY3RvcnkoZGlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiY2MuQ2xhc3Moe1xuICAgIGV4dGVuZHM6IGNjLkNvbXBvbmVudCxcblxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSB1c2VkIG9ubHkgd2hlbiB0aGUgY29tcG9uZW50IGF0dGFjaGluZ1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGEgbm9kZSBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgLy8gICAgdXJsOiBjYy5UZXh0dXJlMkQsICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0eXBlb2YgZGVmYXVsdFxuICAgICAgICAvLyAgICBzZXJpYWxpemFibGU6IHRydWUsIC8vIG9wdGlvbmFsLCBkZWZhdWx0IGlzIHRydWVcbiAgICAgICAgLy8gICAgdmlzaWJsZTogdHJ1ZSwgICAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIGRpc3BsYXlOYW1lOiAnRm9vJywgLy8gb3B0aW9uYWxcbiAgICAgICAgLy8gICAgcmVhZG9ubHk6IGZhbHNlLCAgICAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZVxuICAgICAgICAvLyB9LFxuICAgICAgICAvLyAuLi5cbiAgICAgICAgX2xhc3RUb3VjaFRpbWU6bnVsbCxcbiAgICAgICAgX3ZvaWNlOm51bGwsXG4gICAgICAgIF92b2x1bWU6bnVsbCxcbiAgICAgICAgX3ZvaWNlX2ZhaWxlZDpudWxsLFxuICAgICAgICBfbGFzdENoZWNrVGltZTotMSxcbiAgICAgICAgX3RpbWVCYXI6bnVsbCxcbiAgICAgICAgTUFYX1RJTUU6MTUwMDAsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBcbiAgICAgICAgdGhpcy5fdm9pY2UgPSBjYy5maW5kKFwiQ2FudmFzL3ZvaWNlXCIpO1xuICAgICAgICB0aGlzLl92b2ljZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3ZvaWNlX2ZhaWxlZCA9IGNjLmZpbmQoXCJDYW52YXMvdm9pY2Uvdm9pY2VfZmFpbGVkXCIpO1xuICAgICAgICB0aGlzLl92b2ljZV9mYWlsZWQuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICB0aGlzLl90aW1lQmFyID0gY2MuZmluZChcIkNhbnZhcy92b2ljZS90aW1lXCIpO1xuICAgICAgICB0aGlzLl90aW1lQmFyLnNjYWxlWCA9IDAuMDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3ZvbHVtZSA9IGNjLmZpbmQoXCJDYW52YXMvdm9pY2Uvdm9sdW1lXCIpO1xuICAgICAgICBmb3IodmFyIGkgPSAxOyBpIDwgdGhpcy5fdm9sdW1lLmNoaWxkcmVuLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIHRoaXMuX3ZvbHVtZS5jaGlsZHJlbltpXS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGJ0blZvaWNlID0gY2MuZmluZChcIkNhbnZhcy92b2ljZS92b2ljZV9mYWlsZWQvYnRuX29rXCIpO1xuICAgICAgICBpZihidG5Wb2ljZSl7XG4gICAgICAgICAgICBjYy52di51dGlscy5hZGRDbGlja0V2ZW50KGJ0blZvaWNlLHRoaXMubm9kZSxcIlZvaWNlXCIsXCJvbkJ0bk9LQ2xpY2tlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgYnRuVm9pY2UgPSBjYy5maW5kKFwiQ2FudmFzL2J0bl92b2ljZVwiKTtcbiAgICAgICAgaWYoYnRuVm9pY2Upe1xuICAgICAgICAgICAgYnRuVm9pY2Uub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfU1RBUlQsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX1NUQVJUXCIpO1xuICAgICAgICAgICAgICAgIGNjLnZ2LnZvaWNlTWdyLnByZXBhcmUoXCJyZWNvcmQuYW1yXCIpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2xhc3RUb3VjaFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIHNlbGYuX3ZvaWNlLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi5fdm9pY2VfZmFpbGVkLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJ0blZvaWNlLm9uKGNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX01PVkUsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX01PVkVcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgYnRuVm9pY2Uub24oY2MuTm9kZS5FdmVudFR5cGUuVE9VQ0hfRU5ELGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9FTkRcIik7XG4gICAgICAgICAgICAgICAgaWYoRGF0ZS5ub3coKSAtIHNlbGYuX2xhc3RUb3VjaFRpbWUgPCAxMDAwKXtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fdm9pY2VfZmFpbGVkLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNjLnZ2LnZvaWNlTWdyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uVm9pY2VPSygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLl9sYXN0VG91Y2hUaW1lID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBidG5Wb2ljZS5vbihjYy5Ob2RlLkV2ZW50VHlwZS5UT1VDSF9DQU5DRUwsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNjLk5vZGUuRXZlbnRUeXBlLlRPVUNIX0NBTkNFTFwiKTtcbiAgICAgICAgICAgICAgICBjYy52di52b2ljZU1nci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9sYXN0VG91Y2hUaW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzZWxmLl92b2ljZS5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBvblZvaWNlT0s6ZnVuY3Rpb24oKXtcbiAgICAgICAgaWYodGhpcy5fbGFzdFRvdWNoVGltZSAhPSBudWxsKXtcbiAgICAgICAgICAgIGNjLnZ2LnZvaWNlTWdyLnJlbGVhc2UoKTtcbiAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKSAtIHRoaXMuX2xhc3RUb3VjaFRpbWU7XG4gICAgICAgICAgICB2YXIgbXNnID0gY2MudnYudm9pY2VNZ3IuZ2V0Vm9pY2VEYXRhKFwicmVjb3JkLmFtclwiKTtcbiAgICAgICAgICAgIGNjLnZ2Lm5ldC5zZW5kKFwidm9pY2VfbXNnXCIse21zZzptc2csdGltZTp0aW1lfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdm9pY2UuYWN0aXZlID0gZmFsc2U7XG4gICAgfSxcbiAgICBcbiAgICBvbkJ0bk9LQ2xpY2tlZDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLl92b2ljZS5hY3RpdmUgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gY2FsbGVkIGV2ZXJ5IGZyYW1lLCB1bmNvbW1lbnQgdGhpcyBmdW5jdGlvbiB0byBhY3RpdmF0ZSB1cGRhdGUgY2FsbGJhY2tcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIChkdCkge1xuICAgICAgICBpZih0aGlzLl92b2ljZS5hY3RpdmUgPT0gdHJ1ZSAmJiB0aGlzLl92b2ljZV9mYWlsZWQuYWN0aXZlID09IGZhbHNlKXtcbiAgICAgICAgICAgIGlmKERhdGUubm93KCkgLSB0aGlzLl9sYXN0Q2hlY2tUaW1lID4gMzAwKXtcbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fdm9sdW1lLmNoaWxkcmVuLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdm9sdW1lLmNoaWxkcmVuW2ldLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdiA9IGNjLnZ2LnZvaWNlTWdyLmdldFZvaWNlTGV2ZWwoNyk7XG4gICAgICAgICAgICAgICAgaWYodiA+PSAxICYmIHYgPD0gNyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3ZvbHVtZS5jaGlsZHJlblt2LTFdLmFjdGl2ZSA9IHRydWU7ICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RDaGVja1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZih0aGlzLl9sYXN0VG91Y2hUaW1lKXtcbiAgICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKSAtIHRoaXMuX2xhc3RUb3VjaFRpbWU7XG4gICAgICAgICAgICBpZih0aW1lID49IHRoaXMuTUFYX1RJTUUpe1xuICAgICAgICAgICAgICAgIHRoaXMub25Wb2ljZU9LKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFRvdWNoVGltZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHZhciBwZXJjZW50ID0gdGltZSAvIHRoaXMuTUFYX1RJTUU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZUJhci5zY2FsZVggPSAxIC0gcGVyY2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG59KTtcbiIsImNjLkNsYXNzKHtcbiAgICBleHRlbmRzOiBjYy5Db21wb25lbnQsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgICB0YXJnZXQ6Y2MuTm9kZSxcbiAgICAgICAgLy8gZm9vOiB7XG4gICAgICAgIC8vICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgIC8vICAgIHVybDogY2MuVGV4dHVyZTJELCAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHlwZW9mIGRlZmF1bHRcbiAgICAgICAgLy8gICAgc2VyaWFsaXphYmxlOiB0cnVlLCAvLyBvcHRpb25hbCwgZGVmYXVsdCBpcyB0cnVlXG4gICAgICAgIC8vICAgIHZpc2libGU6IHRydWUsICAgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgdHJ1ZVxuICAgICAgICAvLyAgICBkaXNwbGF5TmFtZTogJ0ZvbycsIC8vIG9wdGlvbmFsXG4gICAgICAgIC8vICAgIHJlYWRvbmx5OiBmYWxzZSwgICAgLy8gb3B0aW9uYWwsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLy8gLi4uXG4gICAgICAgIF9pc1Nob3c6ZmFsc2UsXG4gICAgICAgIGxibENvbnRlbnQ6Y2MuTGFiZWwsXG4gICAgfSxcblxuICAgIC8vIHVzZSB0aGlzIGZvciBpbml0aWFsaXphdGlvblxuICAgIG9uTG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZihjYy52diA9PSBudWxsKXtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjYy52di53YyA9IHRoaXM7XG4gICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSB0aGlzLl9pc1Nob3c7XG4gICAgfSxcblxuICAgIC8vIGNhbGxlZCBldmVyeSBmcmFtZSwgdW5jb21tZW50IHRoaXMgZnVuY3Rpb24gdG8gYWN0aXZhdGUgdXBkYXRlIGNhbGxiYWNrXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoZHQpIHtcbiAgICAgICAgdGhpcy50YXJnZXQucm90YXRpb24gPSB0aGlzLnRhcmdldC5yb3RhdGlvbiAtIGR0KjQ1O1xuICAgIH0sXG4gICAgXG4gICAgc2hvdzpmdW5jdGlvbihjb250ZW50KXtcbiAgICAgICAgdGhpcy5faXNTaG93ID0gdHJ1ZTtcbiAgICAgICAgaWYodGhpcy5ub2RlKXtcbiAgICAgICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSB0aGlzLl9pc1Nob3c7ICAgXG4gICAgICAgIH1cbiAgICAgICAgaWYodGhpcy5sYmxDb250ZW50KXtcbiAgICAgICAgICAgIGlmKGNvbnRlbnQgPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxibENvbnRlbnQuc3RyaW5nID0gY29udGVudDtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaGlkZTpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLl9pc1Nob3cgPSBmYWxzZTtcbiAgICAgICAgaWYodGhpcy5ub2RlKXtcbiAgICAgICAgICAgIHRoaXMubm9kZS5hY3RpdmUgPSB0aGlzLl9pc1Nob3c7ICAgXG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsImlmICghQ0NfSlNCICYmICFjYy5zeXMuaXNOYXRpdmUpIHtcblx0KGZ1bmN0aW9uKGYpe2lmKHR5cGVvZiBleHBvcnRzPT09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZSE9PVwidW5kZWZpbmVkXCIpe21vZHVsZS5leHBvcnRzPWYoKX1lbHNlIGlmKHR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpe2RlZmluZShbXSxmKX1lbHNle3ZhciBnO2lmKHR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cInVuZGVmaW5lZFwiKXtnPWdsb2JhbH1lbHNlIGlmKHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIil7Zz1zZWxmfWVsc2V7Zz10aGlzfWcuaW8gPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSAgX2RlcmVxXygnLi9saWIvJyk7XG5cblx0fSx7XCIuL2xpYi9cIjoyfV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL3NvY2tldCcpO1xuXG5cdC8qKlxuXHQgKiBFeHBvcnRzIHBhcnNlclxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKlxuXHQgKi9cblx0bW9kdWxlLmV4cG9ydHMucGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xuXG5cdH0se1wiLi9zb2NrZXRcIjozLFwiZW5naW5lLmlvLXBhcnNlclwiOjE5fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdChmdW5jdGlvbiAoZ2xvYmFsKXtcblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciB0cmFuc3BvcnRzID0gX2RlcmVxXygnLi90cmFuc3BvcnRzJyk7XG5cdHZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcblx0dmFyIGRlYnVnID0gX2RlcmVxXygnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcblx0dmFyIGluZGV4ID0gX2RlcmVxXygnaW5kZXhvZicpO1xuXHR2YXIgcGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xuXHR2YXIgcGFyc2V1cmkgPSBfZGVyZXFfKCdwYXJzZXVyaScpO1xuXHR2YXIgcGFyc2Vqc29uID0gX2RlcmVxXygncGFyc2Vqc29uJyk7XG5cdHZhciBwYXJzZXFzID0gX2RlcmVxXygncGFyc2VxcycpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cblx0LyoqXG5cdCAqIE5vb3AgZnVuY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBub29wKCl7fVxuXG5cdC8qKlxuXHQgKiBTb2NrZXQgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gU29ja2V0KHVyaSwgb3B0cyl7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cblx0ICBvcHRzID0gb3B0cyB8fCB7fTtcblxuXHQgIGlmICh1cmkgJiYgJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkge1xuXHRcdG9wdHMgPSB1cmk7XG5cdFx0dXJpID0gbnVsbDtcblx0ICB9XG5cblx0ICBpZiAodXJpKSB7XG5cdFx0dXJpID0gcGFyc2V1cmkodXJpKTtcblx0XHRvcHRzLmhvc3RuYW1lID0gdXJpLmhvc3Q7XG5cdFx0b3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT0gJ3dzcyc7XG5cdFx0b3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG5cdFx0aWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcblx0ICB9IGVsc2UgaWYgKG9wdHMuaG9zdCkge1xuXHRcdG9wdHMuaG9zdG5hbWUgPSBwYXJzZXVyaShvcHRzLmhvc3QpLmhvc3Q7XG5cdCAgfVxuXG5cdCAgdGhpcy5zZWN1cmUgPSBudWxsICE9IG9wdHMuc2VjdXJlID8gb3B0cy5zZWN1cmUgOlxuXHRcdChnbG9iYWwubG9jYXRpb24gJiYgJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG5cdCAgaWYgKG9wdHMuaG9zdG5hbWUgJiYgIW9wdHMucG9ydCkge1xuXHRcdC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcblx0XHRvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcblx0ICB9XG5cblx0ICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcblx0ICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuXHRcdChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcblx0ICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0ID9cblx0XHQgICBsb2NhdGlvbi5wb3J0IDpcblx0XHQgICAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuXHQgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuXHQgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuXHQgIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG5cdCAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG5cdCAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG5cdCAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXHQgIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG5cdCAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG5cdCAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuXHQgIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuXHQgIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG5cdCAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuXHQgIHRoaXMucG9saWN5UG9ydCA9IG9wdHMucG9saWN5UG9ydCB8fCA4NDM7XG5cdCAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcblx0ICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuXHQgIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG5cdCAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IGZhbHNlICE9PSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlID8gKG9wdHMucGVyTWVzc2FnZURlZmxhdGUgfHwge30pIDogZmFsc2U7XG5cblx0ICBpZiAodHJ1ZSA9PT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IHt9O1xuXHQgIGlmICh0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmIG51bGwgPT0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcblx0XHR0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZCA9IDEwMjQ7XG5cdCAgfVxuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuXHQgIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcblx0ICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcblx0ICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcblx0ICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuXHQgIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuXHQgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuXHQgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0ICBpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRpZiAob3B0cy5leHRyYUhlYWRlcnMgJiYgT2JqZWN0LmtleXMob3B0cy5leHRyYUhlYWRlcnMpLmxlbmd0aCA+IDApIHtcblx0XHQgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cdFx0fVxuXHQgIH1cblxuXHQgIHRoaXMub3BlbigpO1xuXHR9XG5cblx0U29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBNaXggaW4gYEVtaXR0ZXJgLlxuXHQgKi9cblxuXHRFbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG5cdC8qKlxuXHQgKiBQcm90b2NvbCB2ZXJzaW9uLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cblx0LyoqXG5cdCAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuXHQgKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cblx0ICovXG5cblx0U29ja2V0LlNvY2tldCA9IFNvY2tldDtcblx0U29ja2V0LlRyYW5zcG9ydCA9IF9kZXJlcV8oJy4vdHJhbnNwb3J0Jyk7XG5cdFNvY2tldC50cmFuc3BvcnRzID0gX2RlcmVxXygnLi90cmFuc3BvcnRzJyk7XG5cdFNvY2tldC5wYXJzZXIgPSBfZGVyZXFfKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcblx0ICogQHJldHVybiB7VHJhbnNwb3J0fVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG5cdCAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cblx0ICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcblx0ICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cblx0ICAvLyB0cmFuc3BvcnQgbmFtZVxuXHQgIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cblx0ICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcblx0ICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuXHQgIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG5cdFx0YWdlbnQ6IHRoaXMuYWdlbnQsXG5cdFx0aG9zdG5hbWU6IHRoaXMuaG9zdG5hbWUsXG5cdFx0cG9ydDogdGhpcy5wb3J0LFxuXHRcdHNlY3VyZTogdGhpcy5zZWN1cmUsXG5cdFx0cGF0aDogdGhpcy5wYXRoLFxuXHRcdHF1ZXJ5OiBxdWVyeSxcblx0XHRmb3JjZUpTT05QOiB0aGlzLmZvcmNlSlNPTlAsXG5cdFx0anNvbnA6IHRoaXMuanNvbnAsXG5cdFx0Zm9yY2VCYXNlNjQ6IHRoaXMuZm9yY2VCYXNlNjQsXG5cdFx0ZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSLFxuXHRcdHRpbWVzdGFtcFJlcXVlc3RzOiB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuXHRcdHRpbWVzdGFtcFBhcmFtOiB0aGlzLnRpbWVzdGFtcFBhcmFtLFxuXHRcdHBvbGljeVBvcnQ6IHRoaXMucG9saWN5UG9ydCxcblx0XHRzb2NrZXQ6IHRoaXMsXG5cdFx0cGZ4OiB0aGlzLnBmeCxcblx0XHRrZXk6IHRoaXMua2V5LFxuXHRcdHBhc3NwaHJhc2U6IHRoaXMucGFzc3BocmFzZSxcblx0XHRjZXJ0OiB0aGlzLmNlcnQsXG5cdFx0Y2E6IHRoaXMuY2EsXG5cdFx0Y2lwaGVyczogdGhpcy5jaXBoZXJzLFxuXHRcdHJlamVjdFVuYXV0aG9yaXplZDogdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQsXG5cdFx0cGVyTWVzc2FnZURlZmxhdGU6IHRoaXMucGVyTWVzc2FnZURlZmxhdGUsXG5cdFx0ZXh0cmFIZWFkZXJzOiB0aGlzLmV4dHJhSGVhZGVyc1xuXHQgIH0pO1xuXG5cdCAgcmV0dXJuIHRyYW5zcG9ydDtcblx0fTtcblxuXHRmdW5jdGlvbiBjbG9uZSAob2JqKSB7XG5cdCAgdmFyIG8gPSB7fTtcblx0ICBmb3IgKHZhciBpIGluIG9iaikge1xuXHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHQgIG9baV0gPSBvYmpbaV07XG5cdFx0fVxuXHQgIH1cblx0ICByZXR1cm4gbztcblx0fVxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblx0U29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgIHZhciB0cmFuc3BvcnQ7XG5cdCAgaWYgKHRoaXMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoJ3dlYnNvY2tldCcpICE9IC0xKSB7XG5cdFx0dHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG5cdCAgfSBlbHNlIGlmICgwID09PSB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG5cdFx0Ly8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0ICBzZWxmLmVtaXQoJ2Vycm9yJywgJ05vIHRyYW5zcG9ydHMgYXZhaWxhYmxlJyk7XG5cdFx0fSwgMCk7XG5cdFx0cmV0dXJuO1xuXHQgIH0gZWxzZSB7XG5cdFx0dHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuXHQgIH1cblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cblx0ICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG5cdCAgdHJ5IHtcblx0XHR0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0XHR0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcblx0XHR0aGlzLm9wZW4oKTtcblx0XHRyZXR1cm47XG5cdCAgfVxuXG5cdCAgdHJhbnNwb3J0Lm9wZW4oKTtcblx0ICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0KXtcblx0ICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG5cdFx0ZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuXHRcdHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXHQgIH1cblxuXHQgIC8vIHNldCB1cCB0cmFuc3BvcnRcblx0ICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuXHQgIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG5cdCAgdHJhbnNwb3J0XG5cdCAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG5cdFx0c2VsZi5vbkRyYWluKCk7XG5cdCAgfSlcblx0ICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uKHBhY2tldCl7XG5cdFx0c2VsZi5vblBhY2tldChwYWNrZXQpO1xuXHQgIH0pXG5cdCAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpe1xuXHRcdHNlbGYub25FcnJvcihlKTtcblx0ICB9KVxuXHQgIC5vbignY2xvc2UnLCBmdW5jdGlvbigpe1xuXHRcdHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG5cdCAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFByb2JlcyBhIHRyYW5zcG9ydC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG5cdCAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSlcblx0XHQsIGZhaWxlZCA9IGZhbHNlXG5cdFx0LCBzZWxmID0gdGhpcztcblxuXHQgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuXHQgIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3Blbigpe1xuXHRcdGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuXHRcdCAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuXHRcdCAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcblx0XHR9XG5cdFx0aWYgKGZhaWxlZCkgcmV0dXJuO1xuXG5cdFx0ZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG5cdFx0dHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcblx0XHR0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuXHRcdCAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXHRcdCAgaWYgKCdwb25nJyA9PSBtc2cudHlwZSAmJiAncHJvYmUnID09IG1zZy5kYXRhKSB7XG5cdFx0XHRkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG5cdFx0XHRzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG5cdFx0XHRzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG5cdFx0XHRpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuXHRcdFx0U29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRyYW5zcG9ydC5uYW1lO1xuXG5cdFx0XHRkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcblx0XHRcdHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcblx0XHRcdCAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXHRcdFx0ICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG5cdFx0XHQgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuXHRcdFx0ICBjbGVhbnVwKCk7XG5cblx0XHRcdCAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcblx0XHRcdCAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcblx0XHRcdCAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcblx0XHRcdCAgdHJhbnNwb3J0ID0gbnVsbDtcblx0XHRcdCAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcblx0XHRcdCAgc2VsZi5mbHVzaCgpO1xuXHRcdFx0fSk7XG5cdFx0ICB9IGVsc2Uge1xuXHRcdFx0ZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG5cdFx0XHR2YXIgZXJyID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcicpO1xuXHRcdFx0ZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXHRcdFx0c2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuXHRcdCAgfVxuXHRcdH0pO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCgpIHtcblx0XHRpZiAoZmFpbGVkKSByZXR1cm47XG5cblx0XHQvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcblx0XHRmYWlsZWQgPSB0cnVlO1xuXG5cdFx0Y2xlYW51cCgpO1xuXG5cdFx0dHJhbnNwb3J0LmNsb3NlKCk7XG5cdFx0dHJhbnNwb3J0ID0gbnVsbDtcblx0ICB9XG5cblx0ICAvL0hhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2Jpbmdcblx0ICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuXHRcdHZhciBlcnJvciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3I6ICcgKyBlcnIpO1xuXHRcdGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG5cdFx0ZnJlZXplVHJhbnNwb3J0KCk7XG5cblx0XHRkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLCBuYW1lLCBlcnIpO1xuXG5cdFx0c2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpe1xuXHRcdG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuXHQgIH1cblxuXHQgIC8vV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG5cdCAgZnVuY3Rpb24gb25jbG9zZSgpe1xuXHRcdG9uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuXHQgIH1cblxuXHQgIC8vV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2Jpbmdcblx0ICBmdW5jdGlvbiBvbnVwZ3JhZGUodG8pe1xuXHRcdGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPSB0cmFuc3BvcnQubmFtZSkge1xuXHRcdCAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcblx0XHQgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXHRcdH1cblx0ICB9XG5cblx0ICAvL1JlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcblx0ICBmdW5jdGlvbiBjbGVhbnVwKCl7XG5cdFx0dHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcblx0XHR0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cdFx0dHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXHRcdHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cdFx0c2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcblx0ICB9XG5cblx0ICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG5cdCAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG5cdCAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cblx0ICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG5cdCAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG5cdCAgdHJhbnNwb3J0Lm9wZW4oKTtcblxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG5cdCAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG5cdCAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cdCAgdGhpcy5mbHVzaCgpO1xuXG5cdCAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuXHQgIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcblx0ICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcblx0XHRkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0ICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuXHRcdH1cblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEhhbmRsZXMgYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuXHQgIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0XHRkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cblx0XHR0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cblx0XHQvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG5cdFx0dGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuXHRcdHN3aXRjaCAocGFja2V0LnR5cGUpIHtcblx0XHQgIGNhc2UgJ29wZW4nOlxuXHRcdFx0dGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0ICBjYXNlICdwb25nJzpcblx0XHRcdHRoaXMuc2V0UGluZygpO1xuXHRcdFx0dGhpcy5lbWl0KCdwb25nJyk7XG5cdFx0XHRicmVhaztcblxuXHRcdCAgY2FzZSAnZXJyb3InOlxuXHRcdFx0dmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG5cdFx0XHRlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuXHRcdFx0dGhpcy5vbkVycm9yKGVycik7XG5cdFx0XHRicmVhaztcblxuXHRcdCAgY2FzZSAnbWVzc2FnZSc6XG5cdFx0XHR0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG5cdFx0XHR0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdCAgfSBlbHNlIHtcblx0XHRkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcblx0ICB0aGlzLmlkID0gZGF0YS5zaWQ7XG5cdCAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG5cdCAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG5cdCAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcblx0ICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcblx0ICB0aGlzLm9uT3BlbigpO1xuXHQgIC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcblx0ICBpZiAgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHQgIHRoaXMuc2V0UGluZygpO1xuXG5cdCAgLy8gUHJvbG9uZyBsaXZlbmVzcyBvZiBzb2NrZXQgb24gaGVhcnRiZWF0XG5cdCAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG5cdCAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcblx0ICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgc2VsZi5waW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHRcdHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG5cdCAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG5cdCAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcblx0ICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0ZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuXHRcdHNlbGYucGluZygpO1xuXHRcdHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG5cdCAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xuXHR9O1xuXG5cdC8qKlxuXHQqIFNlbmRzIGEgcGluZyBwYWNrZXQuXG5cdCpcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblxuXHRTb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHRoaXMuc2VuZFBhY2tldCgncGluZycsIGZ1bmN0aW9uKCl7XG5cdFx0c2VsZi5lbWl0KCdwaW5nJyk7XG5cdCAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbigpIHtcblx0ICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG5cdCAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuXHQgIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuXHQgIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG5cdCAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuXHQgIGlmICgwID09PSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuXHRcdHRoaXMuZW1pdCgnZHJhaW4nKTtcblx0ICB9IGVsc2Uge1xuXHRcdHRoaXMuZmx1c2goKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcblx0XHQhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcblx0XHRkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG5cdFx0dGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcblx0XHQvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG5cdFx0Ly8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG5cdFx0dGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG5cdFx0dGhpcy5lbWl0KCdmbHVzaCcpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogU2VuZHMgYSBtZXNzYWdlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuXHQgKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5cdFNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGZuKSB7XG5cdCAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBvcHRpb25zLCBmbik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgb3B0aW9ucywgZm4pIHtcblx0ICBpZignZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSB7XG5cdFx0Zm4gPSBkYXRhO1xuXHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdCAgfVxuXG5cdCAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIG9wdGlvbnMpIHtcblx0XHRmbiA9IG9wdGlvbnM7XG5cdFx0b3B0aW9ucyA9IG51bGw7XG5cdCAgfVxuXG5cdCAgaWYgKCdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFx0cmV0dXJuO1xuXHQgIH1cblxuXHQgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQgIG9wdGlvbnMuY29tcHJlc3MgPSBmYWxzZSAhPT0gb3B0aW9ucy5jb21wcmVzcztcblxuXHQgIHZhciBwYWNrZXQgPSB7XG5cdFx0dHlwZTogdHlwZSxcblx0XHRkYXRhOiBkYXRhLFxuXHRcdG9wdGlvbnM6IG9wdGlvbnNcblx0ICB9O1xuXHQgIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcblx0ICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcblx0ICBpZiAoZm4pIHRoaXMub25jZSgnZmx1c2gnLCBmbik7XG5cdCAgdGhpcy5mbHVzaCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0XHR0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cblx0XHRpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcblx0XHQgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLnVwZ3JhZGluZykge1xuXHRcdFx0ICB3YWl0Rm9yVXBncmFkZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdCAgY2xvc2UoKTtcblx0XHRcdH1cblx0XHQgIH0pO1xuXHRcdH0gZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcblx0XHQgIHdhaXRGb3JVcGdyYWRlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHQgIGNsb3NlKCk7XG5cdFx0fVxuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNsb3NlKCkge1xuXHRcdHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG5cdFx0ZGVidWcoJ3NvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2UnKTtcblx0XHRzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSgpIHtcblx0XHRzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcblx0XHRzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuXHRcdGNsb3NlKCk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKSB7XG5cdFx0Ly8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcblx0XHRzZWxmLm9uY2UoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuXHRcdHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG5cdCAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG5cdCAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXHQgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuXHQgIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuXHRcdGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0Ly8gY2xlYXIgdGltZXJzXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuXHRcdGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXG5cdFx0Ly8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG5cdFx0dGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG5cdFx0Ly8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cblx0XHR0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG5cdFx0Ly8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cblx0XHR0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuXHRcdC8vIHNldCByZWFkeSBzdGF0ZVxuXHRcdHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG5cdFx0Ly8gY2xlYXIgc2Vzc2lvbiBpZFxuXHRcdHRoaXMuaWQgPSBudWxsO1xuXG5cdFx0Ly8gZW1pdCBjbG9zZSBldmVudFxuXHRcdHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24sIGRlc2MpO1xuXG5cdFx0Ly8gY2xlYW4gYnVmZmVycyBhZnRlciwgc28gdXNlcnMgY2FuIHN0aWxsXG5cdFx0Ly8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG5cdFx0c2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuXHRcdHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKlxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG5cdCAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaTxqOyBpKyspIHtcblx0XHRpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuXHQgIH1cblx0ICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcblx0fTtcblxuXHR9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcblx0fSx7XCIuL3RyYW5zcG9ydFwiOjQsXCIuL3RyYW5zcG9ydHNcIjo1LFwiY29tcG9uZW50LWVtaXR0ZXJcIjoxNSxcImRlYnVnXCI6MTcsXCJlbmdpbmUuaW8tcGFyc2VyXCI6MTksXCJpbmRleG9mXCI6MjMsXCJwYXJzZWpzb25cIjoyNixcInBhcnNlcXNcIjoyNyxcInBhcnNldXJpXCI6Mjh9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBwYXJzZXIgPSBfZGVyZXFfKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cdHZhciBFbWl0dGVyID0gX2RlcmVxXygnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG5cdC8qKlxuXHQgKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG5cdCAgdGhpcy5wYXRoID0gb3B0cy5wYXRoO1xuXHQgIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuXHQgIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcblx0ICB0aGlzLnNlY3VyZSA9IG9wdHMuc2VjdXJlO1xuXHQgIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuXHQgIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuXHQgIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuXHQgIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuXHQgIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG5cdCAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5wZnggPSBvcHRzLnBmeDtcblx0ICB0aGlzLmtleSA9IG9wdHMua2V5O1xuXHQgIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcblx0ICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG5cdCAgdGhpcy5jYSA9IG9wdHMuY2E7XG5cdCAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuXHQgIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIHRoaXMuZXh0cmFIZWFkZXJzID0gb3B0cy5leHRyYUhlYWRlcnM7XG5cdH1cblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cblx0RW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuXHQvKipcblx0ICogRW1pdHMgYW4gZXJyb3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0ICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuXHQgIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcblx0ICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG5cdCAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcblx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgIGlmICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFx0dGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXHRcdHRoaXMuZG9PcGVuKCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFx0dGhpcy5kb0Nsb3NlKCk7XG5cdFx0dGhpcy5vbkNsb3NlKCk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuXHQgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFx0dGhpcy53cml0ZShwYWNrZXRzKTtcblx0ICB9IGVsc2Uge1xuXHRcdHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBvcGVuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG5cdCAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cdCAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aXRoIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuXHQgIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuXHQgIHRoaXMub25QYWNrZXQocGFja2V0KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcblx0ICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGNsb3NlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHQgIHRoaXMuZW1pdCgnY2xvc2UnKTtcblx0fTtcblxuXHR9LHtcImNvbXBvbmVudC1lbWl0dGVyXCI6MTUsXCJlbmdpbmUuaW8tcGFyc2VyXCI6MTl9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0KGZ1bmN0aW9uIChnbG9iYWwpe1xuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llc1xuXHQgKi9cblxuXHR2YXIgWE1MSHR0cFJlcXVlc3QgPSBfZGVyZXFfKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcblx0dmFyIFhIUiA9IF9kZXJlcV8oJy4vcG9sbGluZy14aHInKTtcblx0dmFyIEpTT05QID0gX2RlcmVxXygnLi9wb2xsaW5nLWpzb25wJyk7XG5cdHZhciB3ZWJzb2NrZXQgPSBfZGVyZXFfKCcuL3dlYnNvY2tldCcpO1xuXG5cdC8qKlxuXHQgKiBFeHBvcnQgdHJhbnNwb3J0cy5cblx0ICovXG5cblx0ZXhwb3J0cy5wb2xsaW5nID0gcG9sbGluZztcblx0ZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cblx0LyoqXG5cdCAqIFBvbGxpbmcgdHJhbnNwb3J0IHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuXHQgKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHBvbGxpbmcob3B0cyl7XG5cdCAgdmFyIHhocjtcblx0ICB2YXIgeGQgPSBmYWxzZTtcblx0ICB2YXIgeHMgPSBmYWxzZTtcblx0ICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuXHQgIGlmIChnbG9iYWwubG9jYXRpb24pIHtcblx0XHR2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcblx0XHR2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cblx0XHQvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG5cdFx0aWYgKCFwb3J0KSB7XG5cdFx0ICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcblx0XHR9XG5cblx0XHR4ZCA9IG9wdHMuaG9zdG5hbWUgIT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPSBvcHRzLnBvcnQ7XG5cdFx0eHMgPSBvcHRzLnNlY3VyZSAhPSBpc1NTTDtcblx0ICB9XG5cblx0ICBvcHRzLnhkb21haW4gPSB4ZDtcblx0ICBvcHRzLnhzY2hlbWUgPSB4cztcblx0ICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cblx0ICBpZiAoJ29wZW4nIGluIHhociAmJiAhb3B0cy5mb3JjZUpTT05QKSB7XG5cdFx0cmV0dXJuIG5ldyBYSFIob3B0cyk7XG5cdCAgfSBlbHNlIHtcblx0XHRpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG5cdFx0cmV0dXJuIG5ldyBKU09OUChvcHRzKTtcblx0ICB9XG5cdH1cblxuXHR9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcblx0fSx7XCIuL3BvbGxpbmctanNvbnBcIjo2LFwiLi9wb2xsaW5nLXhoclwiOjcsXCIuL3dlYnNvY2tldFwiOjksXCJ4bWxodHRwcmVxdWVzdC1zc2xcIjoxMH1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG5cdCAqL1xuXG5cdHZhciBQb2xsaW5nID0gX2RlcmVxXygnLi9wb2xsaW5nJyk7XG5cdHZhciBpbmhlcml0ID0gX2RlcmVxXygnY29tcG9uZW50LWluaGVyaXQnKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gSlNPTlBQb2xsaW5nO1xuXG5cdC8qKlxuXHQgKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cblx0ICovXG5cblx0dmFyIHJOZXdsaW5lID0gL1xcbi9nO1xuXHR2YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cblx0LyoqXG5cdCAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG5cdCAqL1xuXG5cdHZhciBjYWxsYmFja3M7XG5cblx0LyoqXG5cdCAqIENhbGxiYWNrcyBjb3VudC5cblx0ICovXG5cblx0dmFyIGluZGV4ID0gMDtcblxuXHQvKipcblx0ICogTm9vcC5cblx0ICovXG5cblx0ZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cblx0LyoqXG5cdCAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcblx0ICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cblx0ICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuXHQgIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG5cdCAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cblx0ICBpZiAoIWNhbGxiYWNrcykge1xuXHRcdC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG5cdFx0aWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG5cdFx0Y2FsbGJhY2tzID0gZ2xvYmFsLl9fX2Vpbztcblx0ICB9XG5cblx0ICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG5cdCAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cblx0ICAvLyBhZGQgY2FsbGJhY2sgdG8ganNvbnAgZ2xvYmFsXG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcblx0XHRzZWxmLm9uRGF0YShtc2cpO1xuXHQgIH0pO1xuXG5cdCAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuXHQgIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cblx0ICAvLyBwcmV2ZW50IHNwdXJpb3VzIGVycm9ycyBmcm9tIGJlaW5nIGVtaXR0ZWQgd2hlbiB0aGUgd2luZG93IGlzIHVubG9hZGVkXG5cdCAgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuXHRcdGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0ICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcblx0XHR9LCBmYWxzZSk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cblx0ICovXG5cblx0aW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG5cdC8qXG5cdCAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3Ncblx0ICovXG5cblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG5cdC8qKlxuXHQgKiBDbG9zZXMgdGhlIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdEpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcblx0ICBpZiAodGhpcy5zY3JpcHQpIHtcblx0XHR0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcblx0XHR0aGlzLnNjcmlwdCA9IG51bGw7XG5cdCAgfVxuXG5cdCAgaWYgKHRoaXMuZm9ybSkge1xuXHRcdHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG5cdFx0dGhpcy5mb3JtID0gbnVsbDtcblx0XHR0aGlzLmlmcmFtZSA9IG51bGw7XG5cdCAgfVxuXG5cdCAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuXHQgIGlmICh0aGlzLnNjcmlwdCkge1xuXHRcdHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuXHRcdHRoaXMuc2NyaXB0ID0gbnVsbDtcblx0ICB9XG5cblx0ICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuXHQgIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuXHQgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG5cdFx0c2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJyxlKTtcblx0ICB9O1xuXG5cdCAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuXHQgIGlmIChpbnNlcnRBdCkge1xuXHRcdGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuXHQgIH1cblx0ICBlbHNlIHtcblx0XHQoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHQgIH1cblx0ICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuXHQgIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cdCAgXG5cdCAgaWYgKGlzVUFnZWNrbykge1xuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdCAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuXHRcdCAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHRcdCAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuXHRcdH0sIDEwMCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRKU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICBpZiAoIXRoaXMuZm9ybSkge1xuXHRcdHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuXHRcdHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcblx0XHR2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG5cdFx0dmFyIGlmcmFtZTtcblxuXHRcdGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcblx0XHRmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XHRmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4Jztcblx0XHRmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG5cdFx0Zm9ybS50YXJnZXQgPSBpZDtcblx0XHRmb3JtLm1ldGhvZCA9ICdQT1NUJztcblx0XHRmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcblx0XHRhcmVhLm5hbWUgPSAnZCc7XG5cdFx0Zm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcblx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG5cdFx0dGhpcy5mb3JtID0gZm9ybTtcblx0XHR0aGlzLmFyZWEgPSBhcmVhO1xuXHQgIH1cblxuXHQgIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG5cdCAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuXHRcdGluaXRJZnJhbWUoKTtcblx0XHRmbigpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuXHRcdGlmIChzZWxmLmlmcmFtZSkge1xuXHRcdCAgdHJ5IHtcblx0XHRcdHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG5cdFx0ICB9IGNhdGNoIChlKSB7XG5cdFx0XHRzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcblx0XHQgIH1cblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdCAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG5cdFx0ICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInKyBzZWxmLmlmcmFtZUlkICsnXCI+Jztcblx0XHQgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdCAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG5cdFx0ICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG5cdFx0ICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG5cdFx0fVxuXG5cdFx0aWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuXHRcdHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXHRcdHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuXHQgIH1cblxuXHQgIGluaXRJZnJhbWUoKTtcblxuXHQgIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuXHQgIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcblx0ICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcblx0ICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG5cdCAgdHJ5IHtcblx0XHR0aGlzLmZvcm0uc3VibWl0KCk7XG5cdCAgfSBjYXRjaChlKSB7fVxuXG5cdCAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG5cdFx0dGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcblx0XHQgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIHtcblx0XHRcdGNvbXBsZXRlKCk7XG5cdFx0ICB9XG5cdFx0fTtcblx0ICB9IGVsc2Uge1xuXHRcdHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuXHQgIH1cblx0fTtcblxuXHR9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcblx0fSx7XCIuL3BvbGxpbmdcIjo4LFwiY29tcG9uZW50LWluaGVyaXRcIjoxNn1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cdC8qKlxuXHQgKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuXHQgKi9cblxuXHR2YXIgWE1MSHR0cFJlcXVlc3QgPSBfZGVyZXFfKCd4bWxodHRwcmVxdWVzdC1zc2wnKTtcblx0dmFyIFBvbGxpbmcgPSBfZGVyZXFfKCcuL3BvbGxpbmcnKTtcblx0dmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXHR2YXIgaW5oZXJpdCA9IF9kZXJlcV8oJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cdHZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gWEhSO1xuXHRtb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuXHQvKipcblx0ICogRW1wdHkgZnVuY3Rpb25cblx0ICovXG5cblx0ZnVuY3Rpb24gZW1wdHkoKXt9XG5cblx0LyoqXG5cdCAqIFhIUiBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBYSFIob3B0cyl7XG5cdCAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG5cdCAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuXHRcdHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuXHRcdHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuXHRcdC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcblx0XHRpZiAoIXBvcnQpIHtcblx0XHQgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuXHRcdH1cblxuXHRcdHRoaXMueGQgPSBvcHRzLmhvc3RuYW1lICE9IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSB8fFxuXHRcdCAgcG9ydCAhPSBvcHRzLnBvcnQ7XG5cdFx0dGhpcy54cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuXHQgIH0gZWxzZSB7XG5cdFx0dGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblx0ICB9XG5cdH1cblxuXHQvKipcblx0ICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuXHQgKi9cblxuXHRpbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cblx0LyoqXG5cdCAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcblx0ICovXG5cblx0WEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRYSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihvcHRzKXtcblx0ICBvcHRzID0gb3B0cyB8fCB7fTtcblx0ICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG5cdCAgb3B0cy54ZCA9IHRoaXMueGQ7XG5cdCAgb3B0cy54cyA9IHRoaXMueHM7XG5cdCAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG5cdCAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG5cdCAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgb3B0cy5wZnggPSB0aGlzLnBmeDtcblx0ICBvcHRzLmtleSA9IHRoaXMua2V5O1xuXHQgIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcblx0ICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG5cdCAgb3B0cy5jYSA9IHRoaXMuY2E7XG5cdCAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuXHQgIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICAvLyBvdGhlciBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIG9wdHMuZXh0cmFIZWFkZXJzID0gdGhpcy5leHRyYUhlYWRlcnM7XG5cblx0ICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0WEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZm4pe1xuXHQgIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG5cdCAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHJlcS5vbignc3VjY2VzcycsIGZuKTtcblx0ICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcblx0XHRzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcblx0ICB9KTtcblx0ICB0aGlzLnNlbmRYaHIgPSByZXE7XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRYSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uKCl7XG5cdCAgZGVidWcoJ3hociBwb2xsJyk7XG5cdCAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKXtcblx0XHRzZWxmLm9uRGF0YShkYXRhKTtcblx0ICB9KTtcblx0ICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcblx0XHRzZWxmLm9uRXJyb3IoJ3hociBwb2xsIGVycm9yJywgZXJyKTtcblx0ICB9KTtcblx0ICB0aGlzLnBvbGxYaHIgPSByZXE7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlcXVlc3QgY29uc3RydWN0b3Jcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gUmVxdWVzdChvcHRzKXtcblx0ICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuXHQgIHRoaXMudXJpID0gb3B0cy51cmk7XG5cdCAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcblx0ICB0aGlzLnhzID0gISFvcHRzLnhzO1xuXHQgIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcblx0ICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcblx0ICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcblx0ICB0aGlzLmlzQmluYXJ5ID0gb3B0cy5pc0JpbmFyeTtcblx0ICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcblx0ICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cblx0ICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcblx0ICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuXHQgIHRoaXMua2V5ID0gb3B0cy5rZXk7XG5cdCAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuXHQgIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcblx0ICB0aGlzLmNhID0gb3B0cy5jYTtcblx0ICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG5cdCAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuXHQgIC8vIG90aGVyIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgdGhpcy5leHRyYUhlYWRlcnMgPSBvcHRzLmV4dHJhSGVhZGVycztcblxuXHQgIHRoaXMuY3JlYXRlKCk7XG5cdH1cblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cblx0RW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG5cdCAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG5cdCAgb3B0cy5wZnggPSB0aGlzLnBmeDtcblx0ICBvcHRzLmtleSA9IHRoaXMua2V5O1xuXHQgIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcblx0ICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG5cdCAgb3B0cy5jYSA9IHRoaXMuY2E7XG5cdCAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuXHQgIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cblx0ICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgdHJ5IHtcblx0XHRkZWJ1ZygneGhyIG9wZW4gJXM6ICVzJywgdGhpcy5tZXRob2QsIHRoaXMudXJpKTtcblx0XHR4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmksIHRoaXMuYXN5bmMpO1xuXHRcdHRyeSB7XG5cdFx0ICBpZiAodGhpcy5leHRyYUhlYWRlcnMpIHtcblx0XHRcdHhoci5zZXREaXNhYmxlSGVhZGVyQ2hlY2sodHJ1ZSk7XG5cdFx0XHRmb3IgKHZhciBpIGluIHRoaXMuZXh0cmFIZWFkZXJzKSB7XG5cdFx0XHQgIGlmICh0aGlzLmV4dHJhSGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihpLCB0aGlzLmV4dHJhSGVhZGVyc1tpXSk7XG5cdFx0XHQgIH1cblx0XHRcdH1cblx0XHQgIH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdGlmICh0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG5cdFx0ICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIGFmdGVyIG9wZW4gYmVjYXVzZSBGaXJlZm94IGlzIHN0dXBpZFxuXHRcdCAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG5cdFx0ICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblx0XHR9XG5cblx0XHRpZiAoJ1BPU1QnID09IHRoaXMubWV0aG9kKSB7XG5cdFx0ICB0cnkge1xuXHRcdFx0aWYgKHRoaXMuaXNCaW5hcnkpIHtcblx0XHRcdCAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHQgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG5cdFx0XHR9XG5cdFx0ICB9IGNhdGNoIChlKSB7fVxuXHRcdH1cblxuXHRcdC8vIGllNiBjaGVja1xuXHRcdGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcblx0XHQgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmhhc1hEUigpKSB7XG5cdFx0ICB4aHIub25sb2FkID0gZnVuY3Rpb24oKXtcblx0XHRcdHNlbGYub25Mb2FkKCk7XG5cdFx0ICB9O1xuXHRcdCAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuXHRcdFx0c2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuXHRcdCAgfTtcblx0XHR9IGVsc2Uge1xuXHRcdCAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRpZiAoNCAhPSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuXHRcdFx0aWYgKDIwMCA9PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT0geGhyLnN0YXR1cykge1xuXHRcdFx0ICBzZWxmLm9uTG9hZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdCAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG5cdFx0XHQgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcblx0XHRcdCAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuXHRcdFx0XHRzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG5cdFx0XHQgIH0sIDApO1xuXHRcdFx0fVxuXHRcdCAgfTtcblx0XHR9XG5cblx0XHRkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuXHRcdHhoci5zZW5kKHRoaXMuZGF0YSk7XG5cdCAgfSBjYXRjaCAoZSkge1xuXHRcdC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3Jcblx0XHQvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cblx0XHQvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdCAgc2VsZi5vbkVycm9yKGUpO1xuXHRcdH0sIDApO1xuXHRcdHJldHVybjtcblx0ICB9XG5cblx0ICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG5cdFx0dGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuXHRcdFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG5cdCAgdGhpcy5jbGVhbnVwKCk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcblx0ICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcblx0ICB0aGlzLm9uU3VjY2VzcygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlcnJvci5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuXHQgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuXHQgIHRoaXMuY2xlYW51cCh0cnVlKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xlYW5zIHVwIGhvdXNlLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKGZyb21FcnJvcil7XG5cdCAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuXHRcdHJldHVybjtcblx0ICB9XG5cdCAgLy8geG1saHR0cHJlcXVlc3Rcblx0ICBpZiAodGhpcy5oYXNYRFIoKSkge1xuXHRcdHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcblx0ICB9IGVsc2Uge1xuXHRcdHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuXHQgIH1cblxuXHQgIGlmIChmcm9tRXJyb3IpIHtcblx0XHR0cnkge1xuXHRcdCAgdGhpcy54aHIuYWJvcnQoKTtcblx0XHR9IGNhdGNoKGUpIHt9XG5cdCAgfVxuXG5cdCAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuXHRcdGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuXHQgIH1cblxuXHQgIHRoaXMueGhyID0gbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gbG9hZC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIGRhdGE7XG5cdCAgdHJ5IHtcblx0XHR2YXIgY29udGVudFR5cGU7XG5cdFx0dHJ5IHtcblx0XHQgIGNvbnRlbnRUeXBlID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpLnNwbGl0KCc7JylbMF07XG5cdFx0fSBjYXRjaCAoZSkge31cblx0XHRpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG5cdFx0ICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2U7XG5cdFx0fSBlbHNlIHtcblx0XHQgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuXHRcdFx0ZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcblx0XHQgIH0gZWxzZSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0ICBkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheSh0aGlzLnhoci5yZXNwb25zZSkpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0ICB2YXIgdWk4QXJyID0gbmV3IFVpbnQ4QXJyYXkodGhpcy54aHIucmVzcG9uc2UpO1xuXHRcdFx0ICB2YXIgZGF0YUFycmF5ID0gW107XG5cdFx0XHQgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IHVpOEFyci5sZW5ndGg7IGlkeCA8IGxlbmd0aDsgaWR4KyspIHtcblx0XHRcdFx0ZGF0YUFycmF5LnB1c2godWk4QXJyW2lkeF0pO1xuXHRcdFx0ICB9XG5cblx0XHRcdCAgZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgZGF0YUFycmF5KTtcblx0XHRcdH1cblx0XHQgIH1cblx0XHR9XG5cdCAgfSBjYXRjaCAoZSkge1xuXHRcdHRoaXMub25FcnJvcihlKTtcblx0ICB9XG5cdCAgaWYgKG51bGwgIT0gZGF0YSkge1xuXHRcdHRoaXMub25EYXRhKGRhdGEpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24oKXtcblx0ICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcblx0ICB0aGlzLmNsZWFudXAoKTtcblx0fTtcblxuXHQvKipcblx0ICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuXHQgKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG5cdCAqIGVtaXR0ZWQuXG5cdCAqL1xuXG5cdGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcblx0ICBSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuXHQgIFJlcXVlc3QucmVxdWVzdHMgPSB7fTtcblx0ICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG5cdFx0Z2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuXHQgIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKSB7XG5cdCAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG5cdFx0aWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHQgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcblx0XHR9XG5cdCAgfVxuXHR9XG5cblx0fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG5cdH0se1wiLi9wb2xsaW5nXCI6OCxcImNvbXBvbmVudC1lbWl0dGVyXCI6MTUsXCJjb21wb25lbnQtaW5oZXJpdFwiOjE2LFwiZGVidWdcIjoxNyxcInhtbGh0dHByZXF1ZXN0LXNzbFwiOjEwfV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgVHJhbnNwb3J0ID0gX2RlcmVxXygnLi4vdHJhbnNwb3J0Jyk7XG5cdHZhciBwYXJzZXFzID0gX2RlcmVxXygncGFyc2VxcycpO1xuXHR2YXIgcGFyc2VyID0gX2RlcmVxXygnZW5naW5lLmlvLXBhcnNlcicpO1xuXHR2YXIgaW5oZXJpdCA9IF9kZXJlcV8oJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cdHZhciB5ZWFzdCA9IF9kZXJlcV8oJ3llYXN0Jyk7XG5cdHZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG5cdC8qKlxuXHQgKiBJcyBYSFIyIHN1cHBvcnRlZD9cblx0ICovXG5cblx0dmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24oKSB7XG5cdCAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gX2RlcmVxXygneG1saHR0cHJlcXVlc3Qtc3NsJyk7XG5cdCAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuXHQgIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG5cdH0pKCk7XG5cblx0LyoqXG5cdCAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gUG9sbGluZyhvcHRzKXtcblx0ICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcblx0ICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcblx0XHR0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXHQgIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuXHQgKi9cblxuXHRpbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cblx0LyoqXG5cdCAqIFRyYW5zcG9ydCBuYW1lLlxuXHQgKi9cblxuXHRQb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG5cdC8qKlxuXHQgKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG5cdCAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcblx0ICB0aGlzLnBvbGwoKTtcblx0fTtcblxuXHQvKipcblx0ICogUGF1c2VzIHBvbGxpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbihvblBhdXNlKXtcblx0ICB2YXIgcGVuZGluZyA9IDA7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG5cdCAgZnVuY3Rpb24gcGF1c2UoKXtcblx0XHRkZWJ1ZygncGF1c2VkJyk7XG5cdFx0c2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG5cdFx0b25QYXVzZSgpO1xuXHQgIH1cblxuXHQgIGlmICh0aGlzLnBvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcblx0XHR2YXIgdG90YWwgPSAwO1xuXG5cdFx0aWYgKHRoaXMucG9sbGluZykge1xuXHRcdCAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcblx0XHQgIHRvdGFsKys7XG5cdFx0ICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uKCl7XG5cdFx0XHRkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcblx0XHRcdC0tdG90YWwgfHwgcGF1c2UoKTtcblx0XHQgIH0pO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy53cml0YWJsZSkge1xuXHRcdCAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcblx0XHQgIHRvdGFsKys7XG5cdFx0ICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKXtcblx0XHRcdGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuXHRcdFx0LS10b3RhbCB8fCBwYXVzZSgpO1xuXHRcdCAgfSk7XG5cdFx0fVxuXHQgIH0gZWxzZSB7XG5cdFx0cGF1c2UoKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRQb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oKXtcblx0ICBkZWJ1ZygncG9sbGluZycpO1xuXHQgIHRoaXMucG9sbGluZyA9IHRydWU7XG5cdCAgdGhpcy5kb1BvbGwoKTtcblx0ICB0aGlzLmVtaXQoJ3BvbGwnKTtcblx0fTtcblxuXHQvKipcblx0ICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRQb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgZGVidWcoJ3BvbGxpbmcgZ290IGRhdGEgJXMnLCBkYXRhKTtcblx0ICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuXHRcdC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cblx0XHRpZiAoJ29wZW5pbmcnID09IHNlbGYucmVhZHlTdGF0ZSkge1xuXHRcdCAgc2VsZi5vbk9wZW4oKTtcblx0XHR9XG5cblx0XHQvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG5cdFx0aWYgKCdjbG9zZScgPT0gcGFja2V0LnR5cGUpIHtcblx0XHQgIHNlbGYub25DbG9zZSgpO1xuXHRcdCAgcmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2Vcblx0XHRzZWxmLm9uUGFja2V0KHBhY2tldCk7XG5cdCAgfTtcblxuXHQgIC8vIGRlY29kZSBwYXlsb2FkXG5cdCAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG5cdCAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3Npbmdcblx0ICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFx0Ly8gaWYgd2UgZ290IGRhdGEgd2UncmUgbm90IHBvbGxpbmdcblx0XHR0aGlzLnBvbGxpbmcgPSBmYWxzZTtcblx0XHR0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXG5cdFx0aWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcblx0XHQgIHRoaXMucG9sbCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0ICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuXHRcdH1cblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXG5cdCAgZnVuY3Rpb24gY2xvc2UoKXtcblx0XHRkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcblx0XHRzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuXHQgIH1cblxuXHQgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFx0ZGVidWcoJ3RyYW5zcG9ydCBvcGVuIC0gY2xvc2luZycpO1xuXHRcdGNsb3NlKCk7XG5cdCAgfSBlbHNlIHtcblx0XHQvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuXHRcdC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG5cdFx0ZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuXHRcdHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRQb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cdCAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbigpIHtcblx0XHRzZWxmLndyaXRhYmxlID0gdHJ1ZTtcblx0XHRzZWxmLmVtaXQoJ2RyYWluJyk7XG5cdCAgfTtcblxuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG5cdFx0c2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuXHQgIH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0UG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXHQgIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG5cdCAgdmFyIHBvcnQgPSAnJztcblxuXHQgIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG5cdCAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG5cdFx0cXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSB5ZWFzdCgpO1xuXHQgIH1cblxuXHQgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG5cdFx0cXVlcnkuYjY0ID0gMTtcblx0ICB9XG5cblx0ICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuXHQgIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG5cdCAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpIHx8XG5cdFx0ICgnaHR0cCcgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG5cdFx0cG9ydCA9ICc6JyArIHRoaXMucG9ydDtcblx0ICB9XG5cblx0ICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcblx0ICBpZiAocXVlcnkubGVuZ3RoKSB7XG5cdFx0cXVlcnkgPSAnPycgKyBxdWVyeTtcblx0ICB9XG5cblx0ICB2YXIgaXB2NiA9IHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpICE9PSAtMTtcblx0ICByZXR1cm4gc2NoZW1hICsgJzovLycgKyAoaXB2NiA/ICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScgOiB0aGlzLmhvc3RuYW1lKSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcblx0fTtcblxuXHR9LHtcIi4uL3RyYW5zcG9ydFwiOjQsXCJjb21wb25lbnQtaW5oZXJpdFwiOjE2LFwiZGVidWdcIjoxNyxcImVuZ2luZS5pby1wYXJzZXJcIjoxOSxcInBhcnNlcXNcIjoyNyxcInhtbGh0dHByZXF1ZXN0LXNzbFwiOjEwLFwieWVhc3RcIjozMH1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgVHJhbnNwb3J0ID0gX2RlcmVxXygnLi4vdHJhbnNwb3J0Jyk7XG5cdHZhciBwYXJzZXIgPSBfZGVyZXFfKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cdHZhciBwYXJzZXFzID0gX2RlcmVxXygncGFyc2VxcycpO1xuXHR2YXIgaW5oZXJpdCA9IF9kZXJlcV8oJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cdHZhciB5ZWFzdCA9IF9kZXJlcV8oJ3llYXN0Jyk7XG5cdHZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG5cdHZhciBCcm93c2VyV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuXG5cdC8qKlxuXHQgKiBHZXQgZWl0aGVyIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG5cdCAqIGluIHRoZSBicm93c2VyIG9yIHRyeSB0byByZXNvbHZlIFdlYlNvY2tldC1jb21wYXRpYmxlXG5cdCAqIGludGVyZmFjZSBleHBvc2VkIGJ5IGB3c2AgZm9yIE5vZGUtbGlrZSBlbnZpcm9ubWVudC5cblx0ICovXG5cblx0dmFyIFdlYlNvY2tldCA9IEJyb3dzZXJXZWJTb2NrZXQ7XG5cdGlmICghV2ViU29ja2V0ICYmIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG5cdCAgdHJ5IHtcblx0XHRXZWJTb2NrZXQgPSBfZGVyZXFfKCd3cycpO1xuXHQgIH0gY2F0Y2ggKGUpIHsgfVxuXHR9XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG5cdC8qKlxuXHQgKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBXUyhvcHRzKXtcblx0ICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcblx0ICBpZiAoZm9yY2VCYXNlNjQpIHtcblx0XHR0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXHQgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuXHQgIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuXHQgKi9cblxuXHRpbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG5cdC8qKlxuXHQgKiBUcmFuc3BvcnQgbmFtZS5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0V1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuXHQvKlxuXHQgKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cblx0LyoqXG5cdCAqIE9wZW5zIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuXHQgIGlmICghdGhpcy5jaGVjaygpKSB7XG5cdFx0Ly8gbGV0IHByb2JlIHRpbWVvdXRcblx0XHRyZXR1cm47XG5cdCAgfVxuXG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuXHQgIHZhciBwcm90b2NvbHMgPSB2b2lkKDApO1xuXHQgIHZhciBvcHRzID0ge1xuXHRcdGFnZW50OiB0aGlzLmFnZW50LFxuXHRcdHBlck1lc3NhZ2VEZWZsYXRlOiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlXG5cdCAgfTtcblxuXHQgIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuXHQgIG9wdHMucGZ4ID0gdGhpcy5wZng7XG5cdCAgb3B0cy5rZXkgPSB0aGlzLmtleTtcblx0ICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG5cdCAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuXHQgIG9wdHMuY2EgPSB0aGlzLmNhO1xuXHQgIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcblx0ICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXHQgIGlmICh0aGlzLmV4dHJhSGVhZGVycykge1xuXHRcdG9wdHMuaGVhZGVycyA9IHRoaXMuZXh0cmFIZWFkZXJzO1xuXHQgIH1cblxuXHQgIHRoaXMud3MgPSBCcm93c2VyV2ViU29ja2V0ID8gbmV3IFdlYlNvY2tldCh1cmkpIDogbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scywgb3B0cyk7XG5cblx0ICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcblx0XHR0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXG5cdCAgaWYgKHRoaXMud3Muc3VwcG9ydHMgJiYgdGhpcy53cy5zdXBwb3J0cy5iaW5hcnkpIHtcblx0XHR0aGlzLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblx0XHR0aGlzLndzLmJpbmFyeVR5cGUgPSAnYnVmZmVyJztcblx0ICB9IGVsc2Uge1xuXHRcdHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG5cdCAgfVxuXG5cdCAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRXUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpe1xuXHQgIHZhciBzZWxmID0gdGhpcztcblxuXHQgIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24oKXtcblx0XHRzZWxmLm9uT3BlbigpO1xuXHQgIH07XG5cdCAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oKXtcblx0XHRzZWxmLm9uQ2xvc2UoKTtcblx0ICB9O1xuXHQgIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpe1xuXHRcdHNlbGYub25EYXRhKGV2LmRhdGEpO1xuXHQgIH07XG5cdCAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG5cdFx0c2VsZi5vbkVycm9yKCd3ZWJzb2NrZXQgZXJyb3InLCBlKTtcblx0ICB9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBPdmVycmlkZSBgb25EYXRhYCB0byB1c2UgYSB0aW1lciBvbiBpT1MuXG5cdCAqIFNlZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWxvdWdocmFuLzIwNTIwMDZcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yXG5cdCAgJiYgL2lQYWR8aVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG5cdCAgV1MucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0ICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YS5jYWxsKHNlbGYsIGRhdGEpO1xuXHRcdH0sIDApO1xuXHQgIH07XG5cdH1cblxuXHQvKipcblx0ICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0V1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG5cdCAgdmFyIHNlbGYgPSB0aGlzO1xuXHQgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuXHQgIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG5cdCAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuXHQgIHZhciB0b3RhbCA9IHBhY2tldHMubGVuZ3RoO1xuXHQgIGZvciAodmFyIGkgPSAwLCBsID0gdG90YWw7IGkgPCBsOyBpKyspIHtcblx0XHQoZnVuY3Rpb24ocGFja2V0KSB7XG5cdFx0ICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgc2VsZi5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuXHRcdFx0aWYgKCFCcm93c2VyV2ViU29ja2V0KSB7XG5cdFx0XHQgIC8vIGFsd2F5cyBjcmVhdGUgYSBuZXcgb2JqZWN0IChHSC00MzcpXG5cdFx0XHQgIHZhciBvcHRzID0ge307XG5cdFx0XHQgIGlmIChwYWNrZXQub3B0aW9ucykge1xuXHRcdFx0XHRvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG5cdFx0XHQgIH1cblxuXHRcdFx0ICBpZiAoc2VsZi5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuXHRcdFx0XHR2YXIgbGVuID0gJ3N0cmluZycgPT0gdHlwZW9mIGRhdGEgPyBnbG9iYWwuQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcblx0XHRcdFx0aWYgKGxlbiA8IHNlbGYucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG5cdFx0XHRcdCAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHQgIH1cblx0XHRcdH1cblxuXHRcdFx0Ly9Tb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG5cdFx0XHQvL2hhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuXHRcdFx0Ly90aHJvdyBhbiBlcnJvclxuXHRcdFx0dHJ5IHtcblx0XHRcdCAgaWYgKEJyb3dzZXJXZWJTb2NrZXQpIHtcblx0XHRcdFx0Ly8gVHlwZUVycm9yIGlzIHRocm93biB3aGVuIHBhc3NpbmcgdGhlIHNlY29uZCBhcmd1bWVudCBvbiBTYWZhcmlcblx0XHRcdFx0c2VsZi53cy5zZW5kKGRhdGEpO1xuXHRcdFx0ICB9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLndzLnNlbmQoZGF0YSwgb3B0cyk7XG5cdFx0XHQgIH1cblx0XHRcdH0gY2F0Y2ggKGUpe1xuXHRcdFx0ICBkZWJ1Zygnd2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudCcpO1xuXHRcdFx0fVxuXG5cdFx0XHQtLXRvdGFsIHx8IGRvbmUoKTtcblx0XHQgIH0pO1xuXHRcdH0pKHBhY2tldHNbaV0pO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGRvbmUoKXtcblx0XHRzZWxmLmVtaXQoJ2ZsdXNoJyk7XG5cblx0XHQvLyBmYWtlIGRyYWluXG5cdFx0Ly8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblx0XHQgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuXHRcdCAgc2VsZi5lbWl0KCdkcmFpbicpO1xuXHRcdH0sIDApO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gY2xvc2Vcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKXtcblx0ICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2xvc2VzIHNvY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24oKXtcblx0ICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG5cdFx0dGhpcy53cy5jbG9zZSgpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFdTLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuXHQgIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cdCAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuXHQgIHZhciBwb3J0ID0gJyc7XG5cblx0ICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuXHQgIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0Mylcblx0XHR8fCAoJ3dzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcblx0XHRwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuXHQgIH1cblxuXHQgIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG5cdCAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcblx0XHRxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9IHllYXN0KCk7XG5cdCAgfVxuXG5cdCAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG5cdCAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG5cdFx0cXVlcnkuYjY0ID0gMTtcblx0ICB9XG5cblx0ICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuXHQgIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuXHQgIGlmIChxdWVyeS5sZW5ndGgpIHtcblx0XHRxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuXHQgIH1cblxuXHQgIHZhciBpcHY2ID0gdGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgIT09IC0xO1xuXHQgIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIChpcHY2ID8gJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyA6IHRoaXMuaG9zdG5hbWUpICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0V1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKXtcblx0ICByZXR1cm4gISFXZWJTb2NrZXQgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG5cdH07XG5cblx0fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG5cdH0se1wiLi4vdHJhbnNwb3J0XCI6NCxcImNvbXBvbmVudC1pbmhlcml0XCI6MTYsXCJkZWJ1Z1wiOjE3LFwiZW5naW5lLmlvLXBhcnNlclwiOjE5LFwicGFyc2Vxc1wiOjI3LFwid3NcIjp1bmRlZmluZWQsXCJ5ZWFzdFwiOjMwfV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxuXHR2YXIgaGFzQ09SUyA9IF9kZXJlcV8oJ2hhcy1jb3JzJyk7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG5cdCAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cblx0ICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3Rcblx0ICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG5cdCAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cblx0ICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvZW5naW5lLmlvLWNsaWVudC9wdWxsLzIxN1xuXHQgIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG5cdCAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG5cdCAgdHJ5IHtcblx0XHRpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuXHRcdCAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdH1cblx0ICB9IGNhdGNoIChlKSB7IH1cblxuXHQgIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuXHQgIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG5cdCAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG5cdCAgdHJ5IHtcblx0XHRpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcblx0XHQgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcblx0XHR9XG5cdCAgfSBjYXRjaCAoZSkgeyB9XG5cblx0ICBpZiAoIXhkb21haW4pIHtcblx0XHR0cnkge1xuXHRcdCAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuXHRcdH0gY2F0Y2goZSkgeyB9XG5cdCAgfVxuXHR9XG5cblx0fSx7XCJoYXMtY29yc1wiOjIyfV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHRtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cblx0ZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrLCBlcnJfY2IpIHtcblx0XHR2YXIgYmFpbCA9IGZhbHNlXG5cdFx0ZXJyX2NiID0gZXJyX2NiIHx8IG5vb3Bcblx0XHRwcm94eS5jb3VudCA9IGNvdW50XG5cblx0XHRyZXR1cm4gKGNvdW50ID09PSAwKSA/IGNhbGxiYWNrKCkgOiBwcm94eVxuXG5cdFx0ZnVuY3Rpb24gcHJveHkoZXJyLCByZXN1bHQpIHtcblx0XHRcdGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignYWZ0ZXIgY2FsbGVkIHRvbyBtYW55IHRpbWVzJylcblx0XHRcdH1cblx0XHRcdC0tcHJveHkuY291bnRcblxuXHRcdFx0Ly8gYWZ0ZXIgZmlyc3QgZXJyb3IsIHJlc3QgYXJlIHBhc3NlZCB0byBlcnJfY2Jcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0YmFpbCA9IHRydWVcblx0XHRcdFx0Y2FsbGJhY2soZXJyKVxuXHRcdFx0XHQvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuXHRcdFx0XHRjYWxsYmFjayA9IGVycl9jYlxuXHRcdFx0fSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCByZXN1bHQpXG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cblx0fSx7fV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQvKipcblx0ICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG5cdCAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcblx0ICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuXHQgIHN0YXJ0ID0gc3RhcnQgfHwgMDtcblx0ICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cblx0ICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cblx0ICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG5cdCAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG5cdCAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cblx0ICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG5cdFx0cmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcblx0ICB9XG5cblx0ICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXHQgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG5cdCAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuXHRcdHJlc3VsdFtpaV0gPSBhYnZbaV07XG5cdCAgfVxuXHQgIHJldHVybiByZXN1bHQuYnVmZmVyO1xuXHR9O1xuXG5cdH0se31dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0Lypcblx0ICogYmFzZTY0LWFycmF5YnVmZmVyXG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcblx0ICpcblx0ICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuXHQgKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG5cdCAqL1xuXHQoZnVuY3Rpb24oY2hhcnMpe1xuXHQgIFwidXNlIHN0cmljdFwiO1xuXG5cdCAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuXHRcdHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcblx0XHRpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG5cdFx0ICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG5cdFx0ICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG5cdFx0ICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcblx0XHQgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG5cdFx0fVxuXG5cdFx0aWYgKChsZW4gJSAzKSA9PT0gMikge1xuXHRcdCAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcblx0XHR9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcblx0XHQgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuXHRcdH1cblxuXHRcdHJldHVybiBiYXNlNjQ7XG5cdCAgfTtcblxuXHQgIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuXHRcdHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcblx0XHRsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcblx0XHRlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuXHRcdGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuXHRcdCAgYnVmZmVyTGVuZ3RoLS07XG5cdFx0ICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcblx0XHRcdGJ1ZmZlckxlbmd0aC0tO1xuXHRcdCAgfVxuXHRcdH1cblxuXHRcdHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuXHRcdGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuXHRcdCAgZW5jb2RlZDEgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpXSk7XG5cdFx0ICBlbmNvZGVkMiA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMV0pO1xuXHRcdCAgZW5jb2RlZDMgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzJdKTtcblx0XHQgIGVuY29kZWQ0ID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSszXSk7XG5cblx0XHQgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG5cdFx0ICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcblx0XHQgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycmF5YnVmZmVyO1xuXHQgIH07XG5cdH0pKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiKTtcblxuXHR9LHt9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdChmdW5jdGlvbiAoZ2xvYmFsKXtcblx0LyoqXG5cdCAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG5cdCAqL1xuXG5cdHZhciBCbG9iQnVpbGRlciA9IGdsb2JhbC5CbG9iQnVpbGRlclxuXHQgIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuXHQgIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG5cdCAgfHwgZ2xvYmFsLk1vekJsb2JCdWlsZGVyO1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuXHQgKi9cblxuXHR2YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcblx0ICB0cnkge1xuXHRcdHZhciBhID0gbmV3IEJsb2IoWydoaSddKTtcblx0XHRyZXR1cm4gYS5zaXplID09PSAyO1xuXHQgIH0gY2F0Y2goZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH0pKCk7XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3Igc3VwcG9ydHMgQXJyYXlCdWZmZXJWaWV3c1xuXHQgKiBGYWlscyBpbiBTYWZhcmkgNiwgc28gd2UgbmVlZCB0byBtYXAgdG8gQXJyYXlCdWZmZXJzIHRoZXJlLlxuXHQgKi9cblxuXHR2YXIgYmxvYlN1cHBvcnRzQXJyYXlCdWZmZXJWaWV3ID0gYmxvYlN1cHBvcnRlZCAmJiAoZnVuY3Rpb24oKSB7XG5cdCAgdHJ5IHtcblx0XHR2YXIgYiA9IG5ldyBCbG9iKFtuZXcgVWludDhBcnJheShbMSwyXSldKTtcblx0XHRyZXR1cm4gYi5zaXplID09PSAyO1xuXHQgIH0gY2F0Y2goZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0ICB9XG5cdH0pKCk7XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxuXHQgKi9cblxuXHR2YXIgYmxvYkJ1aWxkZXJTdXBwb3J0ZWQgPSBCbG9iQnVpbGRlclxuXHQgICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcblx0ICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuXHQvKipcblx0ICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgbWFwcyBBcnJheUJ1ZmZlclZpZXdzIHRvIEFycmF5QnVmZmVyc1xuXHQgKiBVc2VkIGJ5IEJsb2JCdWlsZGVyIGNvbnN0cnVjdG9yIGFuZCBvbGQgYnJvd3NlcnMgdGhhdCBkaWRuJ3Rcblx0ICogc3VwcG9ydCBpdCBpbiB0aGUgQmxvYiBjb25zdHJ1Y3Rvci5cblx0ICovXG5cblx0ZnVuY3Rpb24gbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpIHtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBjaHVuayA9IGFyeVtpXTtcblx0XHRpZiAoY2h1bmsuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHQgIHZhciBidWYgPSBjaHVuay5idWZmZXI7XG5cblx0XHQgIC8vIGlmIHRoaXMgaXMgYSBzdWJhcnJheSwgbWFrZSBhIGNvcHkgc28gd2Ugb25seVxuXHRcdCAgLy8gaW5jbHVkZSB0aGUgc3ViYXJyYXkgcmVnaW9uIGZyb20gdGhlIHVuZGVybHlpbmcgYnVmZmVyXG5cdFx0ICBpZiAoY2h1bmsuYnl0ZUxlbmd0aCAhPT0gYnVmLmJ5dGVMZW5ndGgpIHtcblx0XHRcdHZhciBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmsuYnl0ZUxlbmd0aCk7XG5cdFx0XHRjb3B5LnNldChuZXcgVWludDhBcnJheShidWYsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpKTtcblx0XHRcdGJ1ZiA9IGNvcHkuYnVmZmVyO1xuXHRcdCAgfVxuXG5cdFx0ICBhcnlbaV0gPSBidWY7XG5cdFx0fVxuXHQgIH1cblx0fVxuXG5cdGZ1bmN0aW9uIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0ICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcblx0ICBtYXBBcnJheUJ1ZmZlclZpZXdzKGFyeSk7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuXHRcdGJiLmFwcGVuZChhcnlbaV0pO1xuXHQgIH1cblxuXHQgIHJldHVybiAob3B0aW9ucy50eXBlKSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcblx0fTtcblxuXHRmdW5jdGlvbiBCbG9iQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG5cdCAgbWFwQXJyYXlCdWZmZXJWaWV3cyhhcnkpO1xuXHQgIHJldHVybiBuZXcgQmxvYihhcnksIG9wdGlvbnMgfHwge30pO1xuXHR9O1xuXG5cdG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuXHQgIGlmIChibG9iU3VwcG9ydGVkKSB7XG5cdFx0cmV0dXJuIGJsb2JTdXBwb3J0c0FycmF5QnVmZmVyVmlldyA/IGdsb2JhbC5CbG9iIDogQmxvYkNvbnN0cnVjdG9yO1xuXHQgIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcblx0XHRyZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3Rvcjtcblx0ICB9IGVsc2Uge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdCAgfVxuXHR9KSgpO1xuXG5cdH0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxuXHR9LHt9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cblx0LyoqXG5cdCAqIEV4cG9zZSBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG5cdCAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG5cdCAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG5cdFx0b2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuXHQgIH1cblx0ICByZXR1cm4gb2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG5cdFx0LnB1c2goZm4pO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcblx0ICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cblx0ICBmdW5jdGlvbiBvbigpIHtcblx0XHRzZWxmLm9mZihldmVudCwgb24pO1xuXHRcdGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgfVxuXG5cdCAgb24uZm4gPSBmbjtcblx0ICB0aGlzLm9uKGV2ZW50LCBvbik7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG5cdCAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cblx0ICogQHJldHVybiB7RW1pdHRlcn1cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW1pdHRlci5wcm90b3R5cGUub2ZmID1cblx0RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cblx0ICAvLyBhbGxcblx0ICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0dGhpcy5fY2FsbGJhY2tzID0ge307XG5cdFx0cmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgLy8gc3BlY2lmaWMgZXZlbnRcblx0ICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblx0ICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cblx0ICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG5cdCAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuXHRcdGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXHRcdHJldHVybiB0aGlzO1xuXHQgIH1cblxuXHQgIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG5cdCAgdmFyIGNiO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2IgPSBjYWxsYmFja3NbaV07XG5cdFx0aWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcblx0XHQgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG5cdFx0ICBicmVhaztcblx0XHR9XG5cdCAgfVxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuXHRcdCwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuXHQgIGlmIChjYWxsYmFja3MpIHtcblx0XHRjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuXHRcdCAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHRcdH1cblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG5cdCAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG5cdH07XG5cblx0fSx7fV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYSwgYil7XG5cdCAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuXHQgIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuXHQgIGEucHJvdG90eXBlID0gbmV3IGZuO1xuXHQgIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcblx0fTtcblx0fSx7fV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cdC8qKlxuXHQgKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG5cdCAqXG5cdCAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cblx0ICovXG5cblx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9kZWJ1ZycpO1xuXHRleHBvcnRzLmxvZyA9IGxvZztcblx0ZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcblx0ZXhwb3J0cy5zYXZlID0gc2F2ZTtcblx0ZXhwb3J0cy5sb2FkID0gbG9hZDtcblx0ZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5cdGV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcblx0XHRcdFx0ICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG5cdFx0XHRcdFx0ICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG5cdFx0XHRcdFx0ICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG5cdC8qKlxuXHQgKiBDb2xvcnMuXG5cdCAqL1xuXG5cdGV4cG9ydHMuY29sb3JzID0gW1xuXHQgICdsaWdodHNlYWdyZWVuJyxcblx0ICAnZm9yZXN0Z3JlZW4nLFxuXHQgICdnb2xkZW5yb2QnLFxuXHQgICdkb2RnZXJibHVlJyxcblx0ICAnZGFya29yY2hpZCcsXG5cdCAgJ2NyaW1zb24nXG5cdF07XG5cblx0LyoqXG5cdCAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG5cdCAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuXHQgKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG5cdCAqXG5cdCAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0ICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQgIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcblx0XHQvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBpcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cblx0ICovXG5cblx0ZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG5cdCAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9O1xuXG5cblx0LyoqXG5cdCAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcblx0ICB2YXIgYXJncyA9IGFyZ3VtZW50cztcblx0ICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cblx0ICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcblx0XHQrIHRoaXMubmFtZXNwYWNlXG5cdFx0KyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG5cdFx0KyBhcmdzWzBdXG5cdFx0KyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG5cdFx0KyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0ICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cblx0ICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdCAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG5cdCAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0ICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdCAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdCAgdmFyIGluZGV4ID0gMDtcblx0ICB2YXIgbGFzdEMgPSAwO1xuXHQgIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuXHRcdGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuXHRcdGluZGV4Kys7XG5cdFx0aWYgKCclYycgPT09IG1hdGNoKSB7XG5cdFx0ICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHQgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0ICBsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0ICB9KTtcblxuXHQgIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcblx0ICByZXR1cm4gYXJncztcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cblx0ICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gbG9nKCkge1xuXHQgIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG5cdCAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcblx0ICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG5cdFx0JiYgY29uc29sZS5sb2dcblx0XHQmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTYXZlIGBuYW1lc3BhY2VzYC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHQgIHRyeSB7XG5cdFx0aWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuXHRcdCAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fSBlbHNlIHtcblx0XHQgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG5cdFx0fVxuXHQgIH0gY2F0Y2goZSkge31cblx0fVxuXG5cdC8qKlxuXHQgKiBMb2FkIGBuYW1lc3BhY2VzYC5cblx0ICpcblx0ICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gbG9hZCgpIHtcblx0ICB2YXIgcjtcblx0ICB0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG5cdCAgfSBjYXRjaChlKSB7fVxuXHQgIHJldHVybiByO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG5cdCAqL1xuXG5cdGV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cblx0LyoqXG5cdCAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cblx0ICpcblx0ICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG5cdCAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG5cdCAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuXHQgIHRyeSB7XG5cdFx0cmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG5cdCAgfSBjYXRjaCAoZSkge31cblx0fVxuXG5cdH0se1wiLi9kZWJ1Z1wiOjE4fV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cdC8qKlxuXHQgKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG5cdCAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG5cdCAqXG5cdCAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cblx0ICovXG5cblx0ZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5cdGV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuXHRleHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRleHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcblx0ZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcblx0ZXhwb3J0cy5odW1hbml6ZSA9IF9kZXJlcV8oJ21zJyk7XG5cblx0LyoqXG5cdCAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQgKi9cblxuXHRleHBvcnRzLm5hbWVzID0gW107XG5cdGV4cG9ydHMuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0ICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQgKlxuXHQgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cblx0ICovXG5cblx0ZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG5cdCAqL1xuXG5cdHZhciBwcmV2Q29sb3IgPSAwO1xuXG5cdC8qKlxuXHQgKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuXHQgKi9cblxuXHR2YXIgcHJldlRpbWU7XG5cblx0LyoqXG5cdCAqIFNlbGVjdCBhIGNvbG9yLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcblx0ICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuXHQgIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG5cdCAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG5cdCAgfVxuXHQgIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuXHQgIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cblx0ICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG5cdFx0dmFyIHNlbGYgPSBlbmFibGVkO1xuXG5cdFx0Ly8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHR2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuXHRcdHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHQvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuXHRcdGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG5cdFx0aWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cblx0XHRhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG5cdFx0ICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuXHRcdCAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG5cdFx0fVxuXG5cdFx0Ly8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHR2YXIgaW5kZXggPSAwO1xuXHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG5cdFx0ICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0ICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcblx0XHQgIGluZGV4Kys7XG5cdFx0ICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0ICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuXHRcdFx0dmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHQvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRpbmRleC0tO1xuXHRcdCAgfVxuXHRcdCAgcmV0dXJuIG1hdGNoO1xuXHRcdH0pO1xuXG5cdFx0aWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcblx0XHQgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXHRcdHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG5cdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdCAgfVxuXHQgIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cblx0ICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuXHQgIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuXHQgIHJldHVybiBmbjtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdCAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG5cdCAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdCAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0ICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0ICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0fVxuXHQgIH1cblx0fVxuXG5cdC8qKlxuXHQgKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0ICBleHBvcnRzLmVuYWJsZSgnJyk7XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0ICB2YXIgaSwgbGVuO1xuXHQgIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0ICByZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHQgIH1cblx0ICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0aWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdCAgcmV0dXJuIHRydWU7XG5cdFx0fVxuXHQgIH1cblx0ICByZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29lcmNlIGB2YWxgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge01peGVkfSB2YWxcblx0ICogQHJldHVybiB7TWl4ZWR9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdCAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHQgIHJldHVybiB2YWw7XG5cdH1cblxuXHR9LHtcIm1zXCI6MjV9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdChmdW5jdGlvbiAoZ2xvYmFsKXtcblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBrZXlzID0gX2RlcmVxXygnLi9rZXlzJyk7XG5cdHZhciBoYXNCaW5hcnkgPSBfZGVyZXFfKCdoYXMtYmluYXJ5Jyk7XG5cdHZhciBzbGljZUJ1ZmZlciA9IF9kZXJlcV8oJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG5cdHZhciBiYXNlNjRlbmNvZGVyID0gX2RlcmVxXygnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG5cdHZhciBhZnRlciA9IF9kZXJlcV8oJ2FmdGVyJyk7XG5cdHZhciB1dGY4ID0gX2RlcmVxXygndXRmOCcpO1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG5cdCAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG5cdCAqXG5cdCAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG5cdCAqL1xuXG5cdHZhciBpc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpO1xuXG5cdC8qKlxuXHQgKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG5cdCAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG5cdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBpc1BoYW50b21KUyA9IC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG5cdC8qKlxuXHQgKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG5cdCAqIEB0eXBlIGJvb2xlYW5cblx0ICovXG5cdHZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG5cdC8qKlxuXHQgKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG5cdCAqL1xuXG5cdGV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZXMuXG5cdCAqL1xuXG5cdHZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuXHRcdG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuXHQgICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG5cdCAgLCBwaW5nOiAgICAgMlxuXHQgICwgcG9uZzogICAgIDNcblx0ICAsIG1lc3NhZ2U6ICA0XG5cdCAgLCB1cGdyYWRlOiAgNVxuXHQgICwgbm9vcDogICAgIDZcblx0fTtcblxuXHR2YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG5cdC8qKlxuXHQgKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cblx0ICovXG5cblx0dmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuXHQvKipcblx0ICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG5cdCAqL1xuXG5cdHZhciBCbG9iID0gX2RlcmVxXygnYmxvYicpO1xuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG5cdCAqXG5cdCAqIEV4YW1wbGU6XG5cdCAqXG5cdCAqICAgICA1aGVsbG8gd29ybGRcblx0ICogICAgIDNcblx0ICogICAgIDRcblx0ICpcblx0ICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcblx0ICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3VwcG9ydHNCaW5hcnkpIHtcblx0XHRjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuXHRcdHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cdCAgfVxuXG5cdCAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHV0ZjhlbmNvZGUpIHtcblx0XHRjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG5cdFx0dXRmOGVuY29kZSA9IG51bGw7XG5cdCAgfVxuXG5cdCAgdmFyIGRhdGEgPSAocGFja2V0LmRhdGEgPT09IHVuZGVmaW5lZClcblx0XHQ/IHVuZGVmaW5lZFxuXHRcdDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG5cdCAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRyZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuXHQgIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcblx0XHRyZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG5cdCAgfVxuXG5cdCAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG5cdCAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcblx0XHRyZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuXHQgIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cblx0ICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG5cdCAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcblx0XHRlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpKSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cblx0fTtcblxuXHRmdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuXHQgIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cblx0ICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuXHQgIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuXHQgKi9cblxuXHRmdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcblx0XHRyZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG5cdCAgfVxuXG5cdCAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcblx0ICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG5cdCAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG5cdCAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRyZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcblx0ICB9XG5cblx0ICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcblx0XHRyZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG5cdCAgfVxuXG5cdCAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0ICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRwYWNrZXQuZGF0YSA9IGZyLnJlc3VsdDtcblx0XHRleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG5cdCAgfTtcblx0ICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcblx0XHRyZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG5cdCAgfVxuXG5cdCAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcblx0XHRyZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcblx0ICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblx0ICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG5cdCAgcmV0dXJuIGNhbGxiYWNrKGJsb2IpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG5cdCAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuXHQgKi9cblxuXHRleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcblx0ICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG5cdCAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuXHRcdHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0ZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0ICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG5cdFx0ICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcblx0XHR9O1xuXHRcdHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcblx0ICB9XG5cblx0ICB2YXIgYjY0ZGF0YTtcblx0ICB0cnkge1xuXHRcdGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG5cdCAgfSBjYXRjaCAoZSkge1xuXHRcdC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG5cdFx0dmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuXHRcdHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcblx0XHQgIGJhc2ljW2ldID0gdHlwZWRbaV07XG5cdFx0fVxuXHRcdGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcblx0ICB9XG5cdCAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcblx0ICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcblx0ICAvLyBTdHJpbmcgZGF0YVxuXHQgIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcblx0XHRpZiAoZGF0YS5jaGFyQXQoMCkgPT0gJ2InKSB7XG5cdFx0ICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuXHRcdH1cblxuXHRcdGlmICh1dGY4ZGVjb2RlKSB7XG5cdFx0ICB0cnkge1xuXHRcdFx0ZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEpO1xuXHRcdCAgfSBjYXRjaCAoZSkge1xuXHRcdFx0cmV0dXJuIGVycjtcblx0XHQgIH1cblx0XHR9XG5cdFx0dmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuXHRcdGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcblx0XHQgIHJldHVybiBlcnI7XG5cdFx0fVxuXG5cdFx0aWYgKGRhdGEubGVuZ3RoID4gMSkge1xuXHRcdCAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG5cdFx0fSBlbHNlIHtcblx0XHQgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG5cdFx0fVxuXHQgIH1cblxuXHQgIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG5cdCAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuXHQgIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG5cdCAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG5cdFx0cmVzdCA9IG5ldyBCbG9iKFtyZXN0XSk7XG5cdCAgfVxuXHQgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiByZXN0IH07XG5cdH07XG5cblx0LyoqXG5cdCAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2Vcblx0ICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG5cdCAqL1xuXG5cdGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG5cdCAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcblx0ICBpZiAoIWdsb2JhbC5BcnJheUJ1ZmZlcikge1xuXHRcdHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcblx0ICB9XG5cblx0ICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXG5cdCAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG5cdFx0ZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cblx0ICpcblx0ICogICAgIDxsZW5ndGg+OmRhdGFcblx0ICpcblx0ICogRXhhbXBsZTpcblx0ICpcblx0ICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuXHQgKlxuXHQgKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuXHQgKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuXHQgIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG5cdFx0c3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuXHQgIH1cblxuXHQgIHZhciBpc0JpbmFyeSA9IGhhc0JpbmFyeShwYWNrZXRzKTtcblxuXHQgIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuXHRcdGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG5cdFx0ICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsIGNhbGxiYWNrKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG5cdCAgfVxuXG5cdCAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuXHRcdHJldHVybiBjYWxsYmFjaygnMDonKTtcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuXHRcdHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG5cdFx0ZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0ICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcblx0XHR9KTtcblx0ICB9XG5cblx0ICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcblx0XHRyZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG5cdCAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuXHQgKi9cblxuXHRmdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG5cdCAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcblx0ICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG5cdCAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcblx0XHRlYWNoKGVsLCBmdW5jdGlvbihlcnJvciwgbXNnKSB7XG5cdFx0ICByZXN1bHRbaV0gPSBtc2c7XG5cdFx0ICBjYihlcnJvciwgcmVzdWx0KTtcblx0XHR9KTtcblx0ICB9O1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcblx0XHRlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG5cdCAgfVxuXHR9XG5cblx0Lypcblx0ICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG5cdCAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcblx0ICBpZiAodHlwZW9mIGRhdGEgIT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXHQgIH1cblxuXHQgIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcblx0XHRiaW5hcnlUeXBlID0gbnVsbDtcblx0ICB9XG5cblx0ICB2YXIgcGFja2V0O1xuXHQgIGlmIChkYXRhID09ICcnKSB7XG5cdFx0Ly8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuXHRcdHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXHQgIH1cblxuXHQgIHZhciBsZW5ndGggPSAnJ1xuXHRcdCwgbiwgbXNnO1xuXG5cdCAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuXHRcdGlmICgnOicgIT0gY2hyKSB7XG5cdFx0ICBsZW5ndGggKz0gY2hyO1xuXHRcdH0gZWxzZSB7XG5cdFx0ICBpZiAoJycgPT0gbGVuZ3RoIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG5cdFx0XHQvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG5cdFx0XHRyZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblx0XHQgIH1cblxuXHRcdCAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG5cdFx0ICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcblx0XHRcdC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcblx0XHRcdHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXHRcdCAgfVxuXG5cdFx0ICBpZiAobXNnLmxlbmd0aCkge1xuXHRcdFx0cGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCB0cnVlKTtcblxuXHRcdFx0aWYgKGVyci50eXBlID09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09IHBhY2tldC5kYXRhKSB7XG5cdFx0XHQgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcblx0XHRcdCAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcblx0XHRcdGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG5cdFx0ICB9XG5cblx0XHQgIC8vIGFkdmFuY2UgY3Vyc29yXG5cdFx0ICBpICs9IG47XG5cdFx0ICBsZW5ndGggPSAnJztcblx0XHR9XG5cdCAgfVxuXG5cdCAgaWYgKGxlbmd0aCAhPSAnJykge1xuXHRcdC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcblx0XHRyZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblx0ICB9XG5cblx0fTtcblxuXHQvKipcblx0ICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuXHQgKlxuXHQgKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG5cdCAqIDI1NT48ZGF0YT5cblx0ICpcblx0ICogRXhhbXBsZTpcblx0ICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcblx0ICpcblx0ICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuXHQgKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcblx0ICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG5cdFx0cmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG5cdFx0ZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihkYXRhKSB7XG5cdFx0ICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuXHRcdH0pO1xuXHQgIH1cblxuXHQgIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcblx0XHR2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG5cdFx0ICB2YXIgbGVuO1xuXHRcdCAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG5cdFx0XHRsZW4gPSBwLmxlbmd0aDtcblx0XHQgIH0gZWxzZSB7XG5cdFx0XHRsZW4gPSBwLmJ5dGVMZW5ndGg7XG5cdFx0ICB9XG5cdFx0ICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuXHRcdH0sIDApO1xuXG5cdFx0dmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG5cdFx0dmFyIGJ1ZmZlckluZGV4ID0gMDtcblx0XHRlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcblx0XHQgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcblx0XHQgIHZhciBhYiA9IHA7XG5cdFx0ICBpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHR9XG5cdFx0XHRhYiA9IHZpZXcuYnVmZmVyO1xuXHRcdCAgfVxuXG5cdFx0ICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG5cdFx0XHRyZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG5cdFx0ICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuXHRcdFx0cmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuXHRcdCAgfVxuXG5cdFx0ICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuXHRcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcblx0XHRcdHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcblx0XHQgIH1cblx0XHQgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG5cdFx0ICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcblx0XHQgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuXHRcdFx0cmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuXHRcdCAgfVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG5cdCAgfSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVuY29kZSBhcyBCbG9iXG5cdCAqL1xuXG5cdGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG5cdCAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG5cdFx0ZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG5cdFx0ICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuXHRcdCAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG5cdFx0ICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHR2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuXHRcdFx0ICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0fVxuXHRcdFx0ZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuXHRcdFx0YmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG5cdFx0ICB9XG5cblx0XHQgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuXHRcdFx0PyBlbmNvZGVkLmJ5dGVMZW5ndGhcblx0XHRcdDogZW5jb2RlZC5zaXplO1xuXG5cdFx0ICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG5cdFx0ICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuXHRcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG5cdFx0ICB9XG5cdFx0ICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cblx0XHQgIGlmIChCbG9iKSB7XG5cdFx0XHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuXHRcdFx0ZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuXHRcdCAgfVxuXHRcdH0pO1xuXHQgIH1cblxuXHQgIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuXHRcdHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG5cdCAgfSk7XG5cdH07XG5cblx0Lypcblx0ICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG5cdCAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcblx0ICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG5cdCAqXG5cdCAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuXHQgIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcblx0XHRiaW5hcnlUeXBlID0gbnVsbDtcblx0ICB9XG5cblx0ICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG5cdCAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuXHQgIHZhciBudW1iZXJUb29Mb25nID0gZmFsc2U7XG5cdCAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcblx0XHR2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG5cdFx0dmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuXHRcdHZhciBtc2dMZW5ndGggPSAnJztcblxuXHRcdGZvciAodmFyIGkgPSAxOyA7IGkrKykge1xuXHRcdCAgaWYgKHRhaWxBcnJheVtpXSA9PSAyNTUpIGJyZWFrO1xuXG5cdFx0ICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuXHRcdFx0bnVtYmVyVG9vTG9uZyA9IHRydWU7XG5cdFx0XHRicmVhaztcblx0XHQgIH1cblxuXHRcdCAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcblx0XHR9XG5cblx0XHRpZihudW1iZXJUb29Mb25nKSByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblxuXHRcdGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG5cdFx0bXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuXHRcdHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdCAgdHJ5IHtcblx0XHRcdG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG5cdFx0ICB9IGNhdGNoIChlKSB7XG5cdFx0XHQvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcblx0XHRcdHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG5cdFx0XHRtc2cgPSAnJztcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcblx0XHRcdCAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuXHRcdFx0fVxuXHRcdCAgfVxuXHRcdH1cblxuXHRcdGJ1ZmZlcnMucHVzaChtc2cpO1xuXHRcdGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuXHQgIH1cblxuXHQgIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuXHQgIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcblx0XHRjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG5cdCAgfSk7XG5cdH07XG5cblx0fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG5cdH0se1wiLi9rZXlzXCI6MjAsXCJhZnRlclwiOjExLFwiYXJyYXlidWZmZXIuc2xpY2VcIjoxMixcImJhc2U2NC1hcnJheWJ1ZmZlclwiOjEzLFwiYmxvYlwiOjE0LFwiaGFzLWJpbmFyeVwiOjIxLFwidXRmOFwiOjI5fV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cdC8qKlxuXHQgKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG5cdCAqXG5cdCAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG5cdCAgdmFyIGFyciA9IFtdO1xuXHQgIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cdCAgZm9yICh2YXIgaSBpbiBvYmopIHtcblx0XHRpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuXHRcdCAgYXJyLnB1c2goaSk7XG5cdFx0fVxuXHQgIH1cblx0ICByZXR1cm4gYXJyO1xuXHR9O1xuXG5cdH0se31dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0KGZ1bmN0aW9uIChnbG9iYWwpe1xuXG5cdC8qXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG5cdCAqL1xuXG5cdHZhciBpc0FycmF5ID0gX2RlcmVxXygnaXNhcnJheScpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cblx0LyoqXG5cdCAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG5cdCAqXG5cdCAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG5cdCAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcblx0XHRpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG5cdFx0aWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG5cdFx0XHQgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcblx0XHRcdCAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcblx0XHRcdCAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcblx0XHRcdCkge1xuXHRcdCAgcmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKGlzQXJyYXkob2JqKSkge1xuXHRcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcblx0XHRcdCAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuXHRcdFx0XHQgIHJldHVybiB0cnVlO1xuXHRcdFx0ICB9XG5cdFx0ICB9XG5cdFx0fSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuXHRcdCAgaWYgKG9iai50b0pTT04pIHtcblx0XHRcdG9iaiA9IG9iai50b0pTT04oKTtcblx0XHQgIH1cblxuXHRcdCAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcblx0XHRcdCAgcmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xuXHR9XG5cblx0fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG5cdH0se1wiaXNhcnJheVwiOjI0fV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICpcblx0ICogTG9naWMgYm9ycm93ZWQgZnJvbSBNb2Rlcm5penI6XG5cdCAqXG5cdCAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuXHQgKi9cblxuXHR0cnkge1xuXHQgIG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJyAmJlxuXHRcdCd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0ICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG5cdCAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblx0fVxuXG5cdH0se31dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXHR2YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cblx0bW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG5cdCAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG5cdFx0aWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcblx0ICB9XG5cdCAgcmV0dXJuIC0xO1xuXHR9O1xuXHR9LHt9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdG1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG5cdCAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG5cdH07XG5cblx0fSx7fV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQvKipcblx0ICogSGVscGVycy5cblx0ICovXG5cblx0dmFyIHMgPSAxMDAwO1xuXHR2YXIgbSA9IHMgKiA2MDtcblx0dmFyIGggPSBtICogNjA7XG5cdHZhciBkID0gaCAqIDI0O1xuXHR2YXIgeSA9IGQgKiAzNjUuMjU7XG5cblx0LyoqXG5cdCAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG5cdCAqXG5cdCAqIE9wdGlvbnM6XG5cdCAqXG5cdCAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG5cdCAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdCAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuXHQgIHJldHVybiBvcHRpb25zLmxvbmdcblx0XHQ/IGxvbmcodmFsKVxuXHRcdDogc2hvcnQodmFsKTtcblx0fTtcblxuXHQvKipcblx0ICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm4ge051bWJlcn1cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHBhcnNlKHN0cikge1xuXHQgIHN0ciA9ICcnICsgc3RyO1xuXHQgIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHJldHVybjtcblx0ICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG5cdCAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuXHQgIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG5cdCAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcblx0ICBzd2l0Y2ggKHR5cGUpIHtcblx0XHRjYXNlICd5ZWFycyc6XG5cdFx0Y2FzZSAneWVhcic6XG5cdFx0Y2FzZSAneXJzJzpcblx0XHRjYXNlICd5cic6XG5cdFx0Y2FzZSAneSc6XG5cdFx0ICByZXR1cm4gbiAqIHk7XG5cdFx0Y2FzZSAnZGF5cyc6XG5cdFx0Y2FzZSAnZGF5Jzpcblx0XHRjYXNlICdkJzpcblx0XHQgIHJldHVybiBuICogZDtcblx0XHRjYXNlICdob3Vycyc6XG5cdFx0Y2FzZSAnaG91cic6XG5cdFx0Y2FzZSAnaHJzJzpcblx0XHRjYXNlICdocic6XG5cdFx0Y2FzZSAnaCc6XG5cdFx0ICByZXR1cm4gbiAqIGg7XG5cdFx0Y2FzZSAnbWludXRlcyc6XG5cdFx0Y2FzZSAnbWludXRlJzpcblx0XHRjYXNlICdtaW5zJzpcblx0XHRjYXNlICdtaW4nOlxuXHRcdGNhc2UgJ20nOlxuXHRcdCAgcmV0dXJuIG4gKiBtO1xuXHRcdGNhc2UgJ3NlY29uZHMnOlxuXHRcdGNhc2UgJ3NlY29uZCc6XG5cdFx0Y2FzZSAnc2Vjcyc6XG5cdFx0Y2FzZSAnc2VjJzpcblx0XHRjYXNlICdzJzpcblx0XHQgIHJldHVybiBuICogcztcblx0XHRjYXNlICdtaWxsaXNlY29uZHMnOlxuXHRcdGNhc2UgJ21pbGxpc2Vjb25kJzpcblx0XHRjYXNlICdtc2Vjcyc6XG5cdFx0Y2FzZSAnbXNlYyc6XG5cdFx0Y2FzZSAnbXMnOlxuXHRcdCAgcmV0dXJuIG47XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1zXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHNob3J0KG1zKSB7XG5cdCAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG5cdCAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG5cdCAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG5cdCAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG5cdCAgcmV0dXJuIG1zICsgJ21zJztcblx0fVxuXG5cdC8qKlxuXHQgKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG1zXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGxvbmcobXMpIHtcblx0ICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5Jylcblx0XHR8fCBwbHVyYWwobXMsIGgsICdob3VyJylcblx0XHR8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuXHRcdHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG5cdFx0fHwgbXMgKyAnIG1zJztcblx0fVxuXG5cdC8qKlxuXHQgKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cblx0ICovXG5cblx0ZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG5cdCAgaWYgKG1zIDwgbikgcmV0dXJuO1xuXHQgIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuXHQgIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG5cdH1cblxuXHR9LHt9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdChmdW5jdGlvbiAoZ2xvYmFsKXtcblx0LyoqXG5cdCAqIEpTT04gcGFyc2UuXG5cdCAqXG5cdCAqIEBzZWUgQmFzZWQgb24galF1ZXJ5I3BhcnNlSlNPTiAoTUlUKSBhbmQgSlNPTjJcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdHZhciBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvO1xuXHR2YXIgcnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZztcblx0dmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcblx0dmFyIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcblx0dmFyIHJ0cmltTGVmdCA9IC9eXFxzKy87XG5cdHZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlanNvbihkYXRhKSB7XG5cdCAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBkYXRhIHx8ICFkYXRhKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdCAgfVxuXG5cdCAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcblxuXHQgIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuXHQgIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG5cdCAgfVxuXG5cdCAgaWYgKHJ2YWxpZGNoYXJzLnRlc3QoZGF0YS5yZXBsYWNlKHJ2YWxpZGVzY2FwZSwgJ0AnKVxuXHRcdCAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpXG5cdFx0ICAucmVwbGFjZShydmFsaWRicmFjZXMsICcnKSkpIHtcblx0XHRyZXR1cm4gKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBkYXRhKSkoKTtcblx0ICB9XG5cdH07XG5cdH0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxuXHR9LHt9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdC8qKlxuXHQgKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXG5cdCAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3Rcblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcblx0ICB2YXIgc3RyID0gJyc7XG5cblx0ICBmb3IgKHZhciBpIGluIG9iaikge1xuXHRcdGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcblx0XHQgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xuXHRcdCAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuXHRcdH1cblx0ICB9XG5cblx0ICByZXR1cm4gc3RyO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3Rcblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IHFzXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRleHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcblx0ICB2YXIgcXJ5ID0ge307XG5cdCAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcblx0ICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcblx0XHRxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcblx0ICB9XG5cdCAgcmV0dXJuIHFyeTtcblx0fTtcblxuXHR9LHt9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdC8qKlxuXHQgKiBQYXJzZXMgYW4gVVJJXG5cdCAqXG5cdCAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdHZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuXG5cdHZhciBwYXJ0cyA9IFtcblx0XHQnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcblx0XTtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xuXHRcdHZhciBzcmMgPSBzdHIsXG5cdFx0XHRiID0gc3RyLmluZGV4T2YoJ1snKSxcblx0XHRcdGUgPSBzdHIuaW5kZXhPZignXScpO1xuXG5cdFx0aWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuXHRcdFx0c3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcblx0XHR9XG5cblx0XHR2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcblx0XHRcdHVyaSA9IHt9LFxuXHRcdFx0aSA9IDE0O1xuXG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0dXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG5cdFx0fVxuXG5cdFx0aWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuXHRcdFx0dXJpLnNvdXJjZSA9IHNyYztcblx0XHRcdHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcblx0XHRcdHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XG5cdFx0XHR1cmkuaXB2NnVyaSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVyaTtcblx0fTtcblxuXHR9LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdChmdW5jdGlvbiAoZ2xvYmFsKXtcblx0LyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMC4wIGJ5IEBtYXRoaWFzICovXG5cdDsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHRcdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0XHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHRcdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHRcdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdFx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0XHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRcdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdFx0fVxuXG5cdFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0XHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHRcdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdFx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHRcdHZhciBjb3VudGVyID0gMDtcblx0XHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0dmFyIGV4dHJhO1xuXHRcdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9XG5cblx0XHQvLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuXHRcdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdFx0fVxuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpIHtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdFx0JyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdFx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0XHR9XG5cdFx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdFx0cmV0dXJuIHN5bWJvbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cdFx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYnl0ZVN0cmluZztcblx0XHR9XG5cblx0XHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRcdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0XHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woKSB7XG5cdFx0XHR2YXIgYnl0ZTE7XG5cdFx0XHR2YXIgYnl0ZTI7XG5cdFx0XHR2YXIgYnl0ZTM7XG5cdFx0XHR2YXIgYnl0ZTQ7XG5cdFx0XHR2YXIgY29kZVBvaW50O1xuXG5cdFx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0XHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHRcdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRcdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHRcdHZhciBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGJ5dGVBcnJheTtcblx0XHR2YXIgYnl0ZUNvdW50O1xuXHRcdHZhciBieXRlSW5kZXg7XG5cdFx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdFx0dmFyIHRtcDtcblx0XHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHRcdH1cblxuXHRcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdFx0dmFyIHV0ZjggPSB7XG5cdFx0XHQndmVyc2lvbic6ICcyLjAuMCcsXG5cdFx0XHQnZW5jb2RlJzogdXRmOGVuY29kZSxcblx0XHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdFx0fTtcblxuXHRcdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHRcdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0XHRpZiAoXG5cdFx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0XHRkZWZpbmUuYW1kXG5cdFx0KSB7XG5cdFx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB1dGY4O1xuXHRcdFx0fSk7XG5cdFx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSB1dGY4O1xuXHRcdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0XHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRcdHJvb3QudXRmOCA9IHV0Zjg7XG5cdFx0fVxuXG5cdH0odGhpcykpO1xuXG5cdH0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxuXHR9LHt9XSwzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotXycuc3BsaXQoJycpXG5cdCAgLCBsZW5ndGggPSA2NFxuXHQgICwgbWFwID0ge31cblx0ICAsIHNlZWQgPSAwXG5cdCAgLCBpID0gMFxuXHQgICwgcHJldjtcblxuXHQvKipcblx0ICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIG51bWJlci5cblx0ICpcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRvIGNvbnZlcnQuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG51bWJlci5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShudW0pIHtcblx0ICB2YXIgZW5jb2RlZCA9ICcnO1xuXG5cdCAgZG8ge1xuXHRcdGVuY29kZWQgPSBhbHBoYWJldFtudW0gJSBsZW5ndGhdICsgZW5jb2RlZDtcblx0XHRudW0gPSBNYXRoLmZsb29yKG51bSAvIGxlbmd0aCk7XG5cdCAgfSB3aGlsZSAobnVtID4gMCk7XG5cblx0ICByZXR1cm4gZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIGludGVnZXIgdmFsdWUgc3BlY2lmaWVkIGJ5IHRoZSBnaXZlbiBzdHJpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgaW50ZWdlciB2YWx1ZSByZXByZXNlbnRlZCBieSB0aGUgc3RyaW5nLlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKHN0cikge1xuXHQgIHZhciBkZWNvZGVkID0gMDtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcblx0XHRkZWNvZGVkID0gZGVjb2RlZCAqIGxlbmd0aCArIG1hcFtzdHIuY2hhckF0KGkpXTtcblx0ICB9XG5cblx0ICByZXR1cm4gZGVjb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBZZWFzdDogQSB0aW55IGdyb3dpbmcgaWQgZ2VuZXJhdG9yLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBBIHVuaXF1ZSBpZC5cblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cdGZ1bmN0aW9uIHllYXN0KCkge1xuXHQgIHZhciBub3cgPSBlbmNvZGUoK25ldyBEYXRlKCkpO1xuXG5cdCAgaWYgKG5vdyAhPT0gcHJldikgcmV0dXJuIHNlZWQgPSAwLCBwcmV2ID0gbm93O1xuXHQgIHJldHVybiBub3cgKycuJysgZW5jb2RlKHNlZWQrKyk7XG5cdH1cblxuXHQvL1xuXHQvLyBNYXAgZWFjaCBjaGFyYWN0ZXIgdG8gaXRzIGluZGV4LlxuXHQvL1xuXHRmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSBtYXBbYWxwaGFiZXRbaV1dID0gaTtcblxuXHQvL1xuXHQvLyBFeHBvc2UgdGhlIGB5ZWFzdGAsIGBlbmNvZGVgIGFuZCBgZGVjb2RlYCBmdW5jdGlvbnMuXG5cdC8vXG5cdHllYXN0LmVuY29kZSA9IGVuY29kZTtcblx0eWVhc3QuZGVjb2RlID0gZGVjb2RlO1xuXHRtb2R1bGUuZXhwb3J0cyA9IHllYXN0O1xuXG5cdH0se31dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIHVybCA9IF9kZXJlcV8oJy4vdXJsJyk7XG5cdHZhciBwYXJzZXIgPSBfZGVyZXFfKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG5cdHZhciBNYW5hZ2VyID0gX2RlcmVxXygnLi9tYW5hZ2VyJyk7XG5cdHZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuXHQvKipcblx0ICogTWFuYWdlcnMgY2FjaGUuXG5cdCAqL1xuXG5cdHZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuXHQvKipcblx0ICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG5cdCAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG5cdCAqXG5cdCAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG5cdCAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG5cdCAqXG5cdCAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG5cdCAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBsb29rdXAodXJpLCBvcHRzKSB7XG5cdCAgaWYgKHR5cGVvZiB1cmkgPT0gJ29iamVjdCcpIHtcblx0XHRvcHRzID0gdXJpO1xuXHRcdHVyaSA9IHVuZGVmaW5lZDtcblx0ICB9XG5cblx0ICBvcHRzID0gb3B0cyB8fCB7fTtcblxuXHQgIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcblx0ICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcblx0ICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG5cdCAgdmFyIHBhdGggPSBwYXJzZWQucGF0aDtcblx0ICB2YXIgc2FtZU5hbWVzcGFjZSA9IGNhY2hlW2lkXSAmJiBwYXRoIGluIGNhY2hlW2lkXS5uc3BzO1xuXHQgIHZhciBuZXdDb25uZWN0aW9uID0gb3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8XG5cdFx0XHRcdFx0XHQgIGZhbHNlID09PSBvcHRzLm11bHRpcGxleCB8fCBzYW1lTmFtZXNwYWNlO1xuXG5cdCAgdmFyIGlvO1xuXG5cdCAgaWYgKG5ld0Nvbm5lY3Rpb24pIHtcblx0XHRkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG5cdFx0aW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG5cdCAgfSBlbHNlIHtcblx0XHRpZiAoIWNhY2hlW2lkXSkge1xuXHRcdCAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuXHRcdCAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuXHRcdH1cblx0XHRpbyA9IGNhY2hlW2lkXTtcblx0ICB9XG5cblx0ICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQcm90b2NvbCB2ZXJzaW9uLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG5cdC8qKlxuXHQgKiBgY29ubmVjdGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG5cdC8qKlxuXHQgKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLk1hbmFnZXIgPSBfZGVyZXFfKCcuL21hbmFnZXInKTtcblx0ZXhwb3J0cy5Tb2NrZXQgPSBfZGVyZXFfKCcuL3NvY2tldCcpO1xuXG5cdH0se1wiLi9tYW5hZ2VyXCI6MzIsXCIuL3NvY2tldFwiOjM0LFwiLi91cmxcIjozNSxcImRlYnVnXCI6MzksXCJzb2NrZXQuaW8tcGFyc2VyXCI6NDd9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBlaW8gPSBfZGVyZXFfKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG5cdHZhciBTb2NrZXQgPSBfZGVyZXFfKCcuL3NvY2tldCcpO1xuXHR2YXIgRW1pdHRlciA9IF9kZXJlcV8oJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cdHZhciBwYXJzZXIgPSBfZGVyZXFfKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG5cdHZhciBvbiA9IF9kZXJlcV8oJy4vb24nKTtcblx0dmFyIGJpbmQgPSBfZGVyZXFfKCdjb21wb25lbnQtYmluZCcpO1xuXHR2YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcblx0dmFyIGluZGV4T2YgPSBfZGVyZXFfKCdpbmRleG9mJyk7XG5cdHZhciBCYWNrb2ZmID0gX2RlcmVxXygnYmFja28yJyk7XG5cblx0LyoqXG5cdCAqIElFNisgaGFzT3duUHJvcGVydHlcblx0ICovXG5cblx0dmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuXHQvKipcblx0ICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBNYW5hZ2VyKHVyaSwgb3B0cyl7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcblx0ICBpZiAodXJpICYmICgnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSkge1xuXHRcdG9wdHMgPSB1cmk7XG5cdFx0dXJpID0gdW5kZWZpbmVkO1xuXHQgIH1cblx0ICBvcHRzID0gb3B0cyB8fCB7fTtcblxuXHQgIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG5cdCAgdGhpcy5uc3BzID0ge307XG5cdCAgdGhpcy5zdWJzID0gW107XG5cdCAgdGhpcy5vcHRzID0gb3B0cztcblx0ICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuXHQgIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG5cdCAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuXHQgIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcblx0ICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG5cdCAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuXHRcdG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuXHRcdG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuXHRcdGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcblx0ICB9KTtcblx0ICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cdCAgdGhpcy51cmkgPSB1cmk7XG5cdCAgdGhpcy5jb25uZWN0aW5nID0gW107XG5cdCAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cdCAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuXHQgIHRoaXMucGFja2V0QnVmZmVyID0gW107XG5cdCAgdGhpcy5lbmNvZGVyID0gbmV3IHBhcnNlci5FbmNvZGVyKCk7XG5cdCAgdGhpcy5kZWNvZGVyID0gbmV3IHBhcnNlci5EZWNvZGVyKCk7XG5cdCAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuXHQgIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2Bcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbigpIHtcblx0ICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG5cdFx0aWYgKGhhcy5jYWxsKHRoaXMubnNwcywgbnNwKSkge1xuXHRcdCAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcblx0XHR9XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uKCl7XG5cdCAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuXHRcdGlmIChoYXMuY2FsbCh0aGlzLm5zcHMsIG5zcCkpIHtcblx0XHQgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5lbmdpbmUuaWQ7XG5cdFx0fVxuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cblx0RW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cblx0ICpcblx0ICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uKHYpe1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcblx0ICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uKHYpe1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuXHQgIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcblx0ICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uKHYpe1xuXHQgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuXHQgIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcblx0ICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yID0gZnVuY3Rpb24odil7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3Rvcjtcblx0ICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcblx0ICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24odil7XG5cdCAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG5cdCAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuXHQgIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuXHQgKlxuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbih2KXtcblx0ICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuXHQgIHRoaXMuX3RpbWVvdXQgPSB2O1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3Rcblx0ICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuXHQgIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3Rpbmdcblx0ICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcblx0XHQvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG5cdFx0dGhpcy5yZWNvbm5lY3QoKTtcblx0ICB9XG5cdH07XG5cblxuXHQvKipcblx0ICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuXHQgKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuXHRNYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZm4pe1xuXHQgIGRlYnVnKCdyZWFkeVN0YXRlICVzJywgdGhpcy5yZWFkeVN0YXRlKTtcblx0ICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG5cdCAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG5cdCAgdGhpcy5lbmdpbmUgPSBlaW8odGhpcy51cmksIHRoaXMub3B0cyk7XG5cdCAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cdCAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cblx0ICAvLyBlbWl0IGBvcGVuYFxuXHQgIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uKCkge1xuXHRcdHNlbGYub25vcGVuKCk7XG5cdFx0Zm4gJiYgZm4oKTtcblx0ICB9KTtcblxuXHQgIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG5cdCAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbihkYXRhKXtcblx0XHRkZWJ1ZygnY29ubmVjdF9lcnJvcicpO1xuXHRcdHNlbGYuY2xlYW51cCgpO1xuXHRcdHNlbGYucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXHRcdHNlbGYuZW1pdEFsbCgnY29ubmVjdF9lcnJvcicsIGRhdGEpO1xuXHRcdGlmIChmbikge1xuXHRcdCAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBlcnJvcicpO1xuXHRcdCAgZXJyLmRhdGEgPSBkYXRhO1xuXHRcdCAgZm4oZXJyKTtcblx0XHR9IGVsc2Uge1xuXHRcdCAgLy8gT25seSBkbyB0aGlzIGlmIHRoZXJlIGlzIG5vIGZuIHRvIGhhbmRsZSB0aGUgZXJyb3Jcblx0XHQgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcblx0XHR9XG5cdCAgfSk7XG5cblx0ICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG5cdCAgaWYgKGZhbHNlICE9PSB0aGlzLl90aW1lb3V0KSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuXHRcdGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgd2lsbCB0aW1lb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG5cblx0XHQvLyBzZXQgdGltZXJcblx0XHR2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0ICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXHRcdCAgb3BlblN1Yi5kZXN0cm95KCk7XG5cdFx0ICBzb2NrZXQuY2xvc2UoKTtcblx0XHQgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG5cdFx0ICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuXHRcdH0sIHRpbWVvdXQpO1xuXG5cdFx0dGhpcy5zdWJzLnB1c2goe1xuXHRcdCAgZGVzdHJveTogZnVuY3Rpb24oKXtcblx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0ICB9XG5cdFx0fSk7XG5cdCAgfVxuXG5cdCAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG5cdCAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcblx0ICBkZWJ1Zygnb3BlbicpO1xuXG5cdCAgLy8gY2xlYXIgb2xkIHN1YnNcblx0ICB0aGlzLmNsZWFudXAoKTtcblxuXHQgIC8vIG1hcmsgYXMgb3BlblxuXHQgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcblx0ICB0aGlzLmVtaXQoJ29wZW4nKTtcblxuXHQgIC8vIGFkZCBuZXcgc3Vic1xuXHQgIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwaW5nJywgYmluZCh0aGlzLCAnb25waW5nJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdwb25nJywgYmluZCh0aGlzLCAnb25wb25nJykpKTtcblx0ICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuXHQgIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG5cdCAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGEgcGluZy5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9ucGluZyA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5sYXN0UGluZyA9IG5ldyBEYXRlO1xuXHQgIHRoaXMuZW1pdEFsbCgncGluZycpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBhIHBhY2tldC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9ucG9uZyA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5lbWl0QWxsKCdwb25nJywgbmV3IERhdGUgLSB0aGlzLmxhc3RQaW5nKTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdpdGggZGF0YS5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuXHQgIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24ocGFja2V0KSB7XG5cdCAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oZXJyKXtcblx0ICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuXHQgIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTb2NrZXR9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uKG5zcCl7XG5cdCAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuXHQgIGlmICghc29ja2V0KSB7XG5cdFx0c29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3ApO1xuXHRcdHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRzb2NrZXQub24oJ2Nvbm5lY3RpbmcnLCBvbkNvbm5lY3RpbmcpO1xuXHRcdHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG5cdFx0ICBzb2NrZXQuaWQgPSBzZWxmLmVuZ2luZS5pZDtcblx0XHR9KTtcblxuXHRcdGlmICh0aGlzLmF1dG9Db25uZWN0KSB7XG5cdFx0ICAvLyBtYW51YWxseSBjYWxsIGhlcmUgc2luY2UgY29ubmVjdGluZyBldm5ldCBpcyBmaXJlZCBiZWZvcmUgbGlzdGVuaW5nXG5cdFx0ICBvbkNvbm5lY3RpbmcoKTtcblx0XHR9XG5cdCAgfVxuXG5cdCAgZnVuY3Rpb24gb25Db25uZWN0aW5nKCkge1xuXHRcdGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0aW5nLCBzb2NrZXQpKSB7XG5cdFx0ICBzZWxmLmNvbm5lY3RpbmcucHVzaChzb2NrZXQpO1xuXHRcdH1cblx0ICB9XG5cblx0ICByZXR1cm4gc29ja2V0O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cblx0ICpcblx0ICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oc29ja2V0KXtcblx0ICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMuY29ubmVjdGluZywgc29ja2V0KTtcblx0ICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3Rpbmcuc3BsaWNlKGluZGV4LCAxKTtcblx0ICBpZiAodGhpcy5jb25uZWN0aW5nLmxlbmd0aCkgcmV0dXJuO1xuXG5cdCAgdGhpcy5jbG9zZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBXcml0ZXMgYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG5cdCAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcblx0XHQvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG5cdFx0c2VsZi5lbmNvZGluZyA9IHRydWU7XG5cdFx0dGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uKGVuY29kZWRQYWNrZXRzKSB7XG5cdFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSwgcGFja2V0Lm9wdGlvbnMpO1xuXHRcdCAgfVxuXHRcdCAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuXHRcdCAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcblx0XHR9KTtcblx0ICB9IGVsc2UgeyAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuXHRcdHNlbGYucGFja2V0QnVmZmVyLnB1c2gocGFja2V0KTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG5cdCAqIG5leHQgcGFja2V0IGluIGxpbmUuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbigpIHtcblx0ICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuXHRcdHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcblx0XHR0aGlzLnBhY2tldChwYWNrKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0TWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKCl7XG5cdCAgZGVidWcoJ2NsZWFudXAnKTtcblxuXHQgIHZhciBzdWI7XG5cdCAgd2hpbGUgKHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpKSBzdWIuZGVzdHJveSgpO1xuXG5cdCAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcblx0ICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG5cdCAgdGhpcy5sYXN0UGluZyA9IG51bGw7XG5cblx0ICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5cdE1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuXHQgIGRlYnVnKCdkaXNjb25uZWN0Jyk7XG5cdCAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcblx0ICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuXHQgIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG5cdFx0Ly8gYG9uY2xvc2VgIHdpbGwgbm90IGZpcmUgYmVjYXVzZVxuXHRcdC8vIGFuIG9wZW4gZXZlbnQgbmV2ZXIgaGFwcGVuZWRcblx0XHR0aGlzLmNsZWFudXAoKTtcblx0ICB9XG5cdCAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cdCAgaWYgKHRoaXMuZW5naW5lKSB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcblx0ICBkZWJ1Zygnb25jbG9zZScpO1xuXG5cdCAgdGhpcy5jbGVhbnVwKCk7XG5cdCAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG5cdCAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cdCAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG5cblx0ICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcblx0XHR0aGlzLnJlY29ubmVjdCgpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdE1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG5cdCAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7XG5cblx0ICB2YXIgc2VsZiA9IHRoaXM7XG5cblx0ICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG5cdFx0ZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcblx0XHR0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0XHR0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcblx0XHR0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuXHQgIH0gZWxzZSB7XG5cdFx0dmFyIGRlbGF5ID0gdGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7XG5cdFx0ZGVidWcoJ3dpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdCcsIGRlbGF5KTtcblxuXHRcdHRoaXMucmVjb25uZWN0aW5nID0gdHJ1ZTtcblx0XHR2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cdFx0ICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cblx0XHQgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuXHRcdCAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cdFx0ICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cblx0XHQgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuXHRcdCAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG5cdFx0ICBzZWxmLm9wZW4oZnVuY3Rpb24oZXJyKXtcblx0XHRcdGlmIChlcnIpIHtcblx0XHRcdCAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG5cdFx0XHQgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG5cdFx0XHQgIHNlbGYucmVjb25uZWN0KCk7XG5cdFx0XHQgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdCAgZGVidWcoJ3JlY29ubmVjdCBzdWNjZXNzJyk7XG5cdFx0XHQgIHNlbGYub25yZWNvbm5lY3QoKTtcblx0XHRcdH1cblx0XHQgIH0pO1xuXHRcdH0sIGRlbGF5KTtcblxuXHRcdHRoaXMuc3Vicy5wdXNoKHtcblx0XHQgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdCAgfVxuXHRcdH0pO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRNYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG5cdCAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcblx0ICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcblx0ICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuXHQgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG5cdH07XG5cblx0fSx7XCIuL29uXCI6MzMsXCIuL3NvY2tldFwiOjM0LFwiYmFja28yXCI6MzYsXCJjb21wb25lbnQtYmluZFwiOjM3LFwiY29tcG9uZW50LWVtaXR0ZXJcIjozOCxcImRlYnVnXCI6MzksXCJlbmdpbmUuaW8tY2xpZW50XCI6MSxcImluZGV4b2ZcIjo0MixcInNvY2tldC5pby1wYXJzZXJcIjo0N31dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXHQvKipcblx0ICogTW9kdWxlIGV4cG9ydHMuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gb247XG5cblx0LyoqXG5cdCAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gb24ob2JqLCBldiwgZm4pIHtcblx0ICBvYmoub24oZXYsIGZuKTtcblx0ICByZXR1cm4ge1xuXHRcdGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG5cdFx0ICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcblx0XHR9XG5cdCAgfTtcblx0fVxuXG5cdH0se31dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXHQvKipcblx0ICogTW9kdWxlIGRlcGVuZGVuY2llcy5cblx0ICovXG5cblx0dmFyIHBhcnNlciA9IF9kZXJlcV8oJ3NvY2tldC5pby1wYXJzZXInKTtcblx0dmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXHR2YXIgdG9BcnJheSA9IF9kZXJlcV8oJ3RvLWFycmF5Jyk7XG5cdHZhciBvbiA9IF9kZXJlcV8oJy4vb24nKTtcblx0dmFyIGJpbmQgPSBfZGVyZXFfKCdjb21wb25lbnQtYmluZCcpO1xuXHR2YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xuXHR2YXIgaGFzQmluID0gX2RlcmVxXygnaGFzLWJpbmFyeScpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cblx0ICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHR2YXIgZXZlbnRzID0ge1xuXHQgIGNvbm5lY3Q6IDEsXG5cdCAgY29ubmVjdF9lcnJvcjogMSxcblx0ICBjb25uZWN0X3RpbWVvdXQ6IDEsXG5cdCAgY29ubmVjdGluZzogMSxcblx0ICBkaXNjb25uZWN0OiAxLFxuXHQgIGVycm9yOiAxLFxuXHQgIHJlY29ubmVjdDogMSxcblx0ICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcblx0ICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuXHQgIHJlY29ubmVjdF9lcnJvcjogMSxcblx0ICByZWNvbm5lY3Rpbmc6IDEsXG5cdCAgcGluZzogMSxcblx0ICBwb25nOiAxXG5cdH07XG5cblx0LyoqXG5cdCAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuXHQgKi9cblxuXHR2YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cblx0LyoqXG5cdCAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBTb2NrZXQoaW8sIG5zcCl7XG5cdCAgdGhpcy5pbyA9IGlvO1xuXHQgIHRoaXMubnNwID0gbnNwO1xuXHQgIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuXHQgIHRoaXMuaWRzID0gMDtcblx0ICB0aGlzLmFja3MgPSB7fTtcblx0ICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblx0ICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcblx0ICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuXHQgIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcblx0ICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG5cdH1cblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYC5cblx0ICovXG5cblx0RW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuXHQvKipcblx0ICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG5cdCAqXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuXHQgIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuXHQgIHZhciBpbyA9IHRoaXMuaW87XG5cdCAgdGhpcy5zdWJzID0gW1xuXHRcdG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcblx0XHRvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuXHRcdG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG5cdCAgXTtcblx0fTtcblxuXHQvKipcblx0ICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5cdFNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuXHQgIHRoaXMuc3ViRXZlbnRzKCk7XG5cdCAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG5cdCAgaWYgKCdvcGVuJyA9PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG5cdCAgdGhpcy5lbWl0KCdjb25uZWN0aW5nJyk7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oKXtcblx0ICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcblx0ICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcblx0ICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJyaWRlIGBlbWl0YC5cblx0ICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG5cdCAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldil7XG5cdCAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcblx0XHRlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cdCAgdmFyIHBhcnNlclR5cGUgPSBwYXJzZXIuRVZFTlQ7IC8vIGRlZmF1bHRcblx0ICBpZiAoaGFzQmluKGFyZ3MpKSB7IHBhcnNlclR5cGUgPSBwYXJzZXIuQklOQVJZX0VWRU5UOyB9IC8vIGJpbmFyeVxuXHQgIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlclR5cGUsIGRhdGE6IGFyZ3MgfTtcblxuXHQgIHBhY2tldC5vcHRpb25zID0ge307XG5cdCAgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3MgPSAhdGhpcy5mbGFncyB8fCBmYWxzZSAhPT0gdGhpcy5mbGFncy5jb21wcmVzcztcblxuXHQgIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuXHQgIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcblx0XHRkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuXHRcdHRoaXMuYWNrc1t0aGlzLmlkc10gPSBhcmdzLnBvcCgpO1xuXHRcdHBhY2tldC5pZCA9IHRoaXMuaWRzKys7XG5cdCAgfVxuXG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdFx0dGhpcy5wYWNrZXQocGFja2V0KTtcblx0ICB9IGVsc2Uge1xuXHRcdHRoaXMuc2VuZEJ1ZmZlci5wdXNoKHBhY2tldCk7XG5cdCAgfVxuXG5cdCAgZGVsZXRlIHRoaXMuZmxhZ3M7XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogU2VuZHMgYSBwYWNrZXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcblx0ICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG5cdCAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcblx0ICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cblx0ICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3Nhcnlcblx0ICBpZiAoJy8nICE9IHRoaXMubnNwKSB7XG5cdFx0dGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuQ09OTkVDVCB9KTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuXHQgIGRlYnVnKCdjbG9zZSAoJXMpJywgcmVhc29uKTtcblx0ICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuXHQgIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcblx0ICBkZWxldGUgdGhpcy5pZDtcblx0ICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcblx0ICBpZiAocGFja2V0Lm5zcCAhPSB0aGlzLm5zcCkgcmV0dXJuO1xuXG5cdCAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuXHRcdGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG5cdFx0ICB0aGlzLm9uY29ubmVjdCgpO1xuXHRcdCAgYnJlYWs7XG5cblx0XHRjYXNlIHBhcnNlci5FVkVOVDpcblx0XHQgIHRoaXMub25ldmVudChwYWNrZXQpO1xuXHRcdCAgYnJlYWs7XG5cblx0XHRjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG5cdFx0ICB0aGlzLm9uZXZlbnQocGFja2V0KTtcblx0XHQgIGJyZWFrO1xuXG5cdFx0Y2FzZSBwYXJzZXIuQUNLOlxuXHRcdCAgdGhpcy5vbmFjayhwYWNrZXQpO1xuXHRcdCAgYnJlYWs7XG5cblx0XHRjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuXHRcdCAgdGhpcy5vbmFjayhwYWNrZXQpO1xuXHRcdCAgYnJlYWs7XG5cblx0XHRjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuXHRcdCAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcblx0XHQgIGJyZWFrO1xuXG5cdFx0Y2FzZSBwYXJzZXIuRVJST1I6XG5cdFx0ICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuXHRcdCAgYnJlYWs7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24ocGFja2V0KXtcblx0ICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuXHQgIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG5cdCAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG5cdFx0ZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcblx0XHRhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG5cdCAgfVxuXG5cdCAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG5cdFx0ZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcblx0ICB9IGVsc2Uge1xuXHRcdHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24oaWQpe1xuXHQgIHZhciBzZWxmID0gdGhpcztcblx0ICB2YXIgc2VudCA9IGZhbHNlO1xuXHQgIHJldHVybiBmdW5jdGlvbigpe1xuXHRcdC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuXHRcdGlmIChzZW50KSByZXR1cm47XG5cdFx0c2VudCA9IHRydWU7XG5cdFx0dmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG5cdFx0ZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cblx0XHR2YXIgdHlwZSA9IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSztcblx0XHRzZWxmLnBhY2tldCh7XG5cdFx0ICB0eXBlOiB0eXBlLFxuXHRcdCAgaWQ6IGlkLFxuXHRcdCAgZGF0YTogYXJnc1xuXHRcdH0pO1xuXHQgIH07XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRTb2NrZXQucHJvdG90eXBlLm9uYWNrID0gZnVuY3Rpb24ocGFja2V0KXtcblx0ICB2YXIgYWNrID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG5cdCAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGFjaykge1xuXHRcdGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG5cdFx0YWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcblx0XHRkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG5cdCAgfSBlbHNlIHtcblx0XHRkZWJ1ZygnYmFkIGFjayAlcycsIHBhY2tldC5pZCk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24oKXtcblx0ICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG5cdCAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcblx0ICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcblx0ICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0U29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbigpe1xuXHQgIHZhciBpO1xuXHQgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcblx0XHRlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG5cdCAgfVxuXHQgIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG5cdCAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuXHRcdHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG5cdCAgfVxuXHQgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcblx0ICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcblx0ICB0aGlzLmRlc3Ryb3koKTtcblx0ICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG5cdCAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG5cdCAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGUuXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG5cdCAgaWYgKHRoaXMuc3Vicykge1xuXHRcdC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG5cdFx0ICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuXHRcdH1cblx0XHR0aGlzLnN1YnMgPSBudWxsO1xuXHQgIH1cblxuXHQgIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcblx0fTtcblxuXHQvKipcblx0ICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cblx0ICpcblx0ICogQHJldHVybiB7U29ja2V0fSBzZWxmXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuXHRTb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuXHQgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuXHRcdGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcblx0XHR0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuXHQgIH1cblxuXHQgIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG5cdCAgdGhpcy5kZXN0cm95KCk7XG5cblx0ICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcblx0XHQvLyBmaXJlIGV2ZW50c1xuXHRcdHRoaXMub25jbG9zZSgnaW8gY2xpZW50IGRpc2Nvbm5lY3QnKTtcblx0ICB9XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcblx0ICogQHJldHVybiB7U29ja2V0fSBzZWxmXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdFNvY2tldC5wcm90b3R5cGUuY29tcHJlc3MgPSBmdW5jdGlvbihjb21wcmVzcyl7XG5cdCAgdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfHwge307XG5cdCAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdH0se1wiLi9vblwiOjMzLFwiY29tcG9uZW50LWJpbmRcIjozNyxcImNvbXBvbmVudC1lbWl0dGVyXCI6MzgsXCJkZWJ1Z1wiOjM5LFwiaGFzLWJpbmFyeVwiOjQxLFwic29ja2V0LmlvLXBhcnNlclwiOjQ3LFwidG8tYXJyYXlcIjo1MX1dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblx0KGZ1bmN0aW9uIChnbG9iYWwpe1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuXHQgKi9cblxuXHR2YXIgcGFyc2V1cmkgPSBfZGVyZXFfKCdwYXJzZXVyaScpO1xuXHR2YXIgZGVidWcgPSBfZGVyZXFfKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG5cdC8qKlxuXHQgKiBNb2R1bGUgZXhwb3J0cy5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSB1cmw7XG5cblx0LyoqXG5cdCAqIFVSTCBwYXJzZXIuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcblx0ICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG5cdCAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIHVybCh1cmksIGxvYyl7XG5cdCAgdmFyIG9iaiA9IHVyaTtcblxuXHQgIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG5cdCAgdmFyIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG5cdCAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cblx0ICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcblx0ICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHVyaSkge1xuXHRcdGlmICgnLycgPT0gdXJpLmNoYXJBdCgwKSkge1xuXHRcdCAgaWYgKCcvJyA9PSB1cmkuY2hhckF0KDEpKSB7XG5cdFx0XHR1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG5cdFx0ICB9IGVsc2Uge1xuXHRcdFx0dXJpID0gbG9jLmhvc3QgKyB1cmk7XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0aWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcblx0XHQgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG5cdFx0ICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGxvYykge1xuXHRcdFx0dXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcblx0XHQgIH0gZWxzZSB7XG5cdFx0XHR1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuXHRcdCAgfVxuXHRcdH1cblxuXHRcdC8vIHBhcnNlXG5cdFx0ZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcblx0XHRvYmogPSBwYXJzZXVyaSh1cmkpO1xuXHQgIH1cblxuXHQgIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuXHQgIGlmICghb2JqLnBvcnQpIHtcblx0XHRpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcblx0XHQgIG9iai5wb3J0ID0gJzgwJztcblx0XHR9XG5cdFx0ZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG5cdFx0ICBvYmoucG9ydCA9ICc0NDMnO1xuXHRcdH1cblx0ICB9XG5cblx0ICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuXHQgIHZhciBpcHY2ID0gb2JqLmhvc3QuaW5kZXhPZignOicpICE9PSAtMTtcblx0ICB2YXIgaG9zdCA9IGlwdjYgPyAnWycgKyBvYmouaG9zdCArICddJyA6IG9iai5ob3N0O1xuXG5cdCAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuXHQgIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICc6JyArIG9iai5wb3J0O1xuXHQgIC8vIGRlZmluZSBocmVmXG5cdCAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIGhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09IG9iai5wb3J0ID8gJycgOiAoJzonICsgb2JqLnBvcnQpKTtcblxuXHQgIHJldHVybiBvYmo7XG5cdH1cblxuXHR9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB7fSlcblx0fSx7XCJkZWJ1Z1wiOjM5LFwicGFyc2V1cmlcIjo0NX1dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuXHQvKipcblx0ICogRXhwb3NlIGBCYWNrb2ZmYC5cblx0ICovXG5cblx0bW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG5cdCAqXG5cdCAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuXHQgKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cblx0ICogLSBgaml0dGVyYCBbMF1cblx0ICogLSBgZmFjdG9yYCBbMl1cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdHNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG5cdCAgb3B0cyA9IG9wdHMgfHwge307XG5cdCAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcblx0ICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuXHQgIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcblx0ICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuXHQgIHRoaXMuYXR0ZW1wdHMgPSAwO1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cblx0ICpcblx0ICogQHJldHVybiB7TnVtYmVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG5cdCAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuXHQgIGlmICh0aGlzLmppdHRlcikge1xuXHRcdHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG5cdFx0dmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuXHRcdG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcblx0ICB9XG5cdCAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG5cdCAgdGhpcy5hdHRlbXB0cyA9IDA7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuXHQgIHRoaXMubXMgPSBtaW47XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuXHQgIHRoaXMubWF4ID0gbWF4O1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGppdHRlclxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRCYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuXHQgIHRoaXMuaml0dGVyID0gaml0dGVyO1xuXHR9O1xuXG5cblx0fSx7fV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQvKipcblx0ICogU2xpY2UgcmVmZXJlbmNlLlxuXHQgKi9cblxuXHR2YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuXHQvKipcblx0ICogQmluZCBgb2JqYCB0byBgZm5gLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcblx0ICogQHJldHVybiB7RnVuY3Rpb259XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG5cdCAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuXHQgIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuXHQgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuXHQgIHJldHVybiBmdW5jdGlvbigpe1xuXHRcdHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuXHQgIH1cblx0fTtcblxuXHR9LHt9XSwzODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cblx0LyoqXG5cdCAqIEV4cG9zZSBgRW1pdHRlcmAuXG5cdCAqL1xuXG5cdG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuXHQvKipcblx0ICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG5cdCAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG5cdH07XG5cblx0LyoqXG5cdCAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcblx0ICogQHJldHVybiB7T2JqZWN0fVxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG5cdCAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG5cdFx0b2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuXHQgIH1cblx0ICByZXR1cm4gb2JqO1xuXHR9XG5cblx0LyoqXG5cdCAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblx0ICAodGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW10pXG5cdFx0LnB1c2goZm4pO1xuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcblx0ICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuXHQgIGZ1bmN0aW9uIG9uKCkge1xuXHRcdHRoaXMub2ZmKGV2ZW50LCBvbik7XG5cdFx0Zm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICB9XG5cblx0ICBvbi5mbiA9IGZuO1xuXHQgIHRoaXMub24oZXZlbnQsIG9uKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcblx0ICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuXHQgKiBAcmV0dXJuIHtFbWl0dGVyfVxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuXHRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5cdEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuXHQgIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuXHQgIC8vIGFsbFxuXHQgIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHR0aGlzLl9jYWxsYmFja3MgPSB7fTtcblx0XHRyZXR1cm4gdGhpcztcblx0ICB9XG5cblx0ICAvLyBzcGVjaWZpYyBldmVudFxuXHQgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXHQgIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuXHQgIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcblx0ICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0ZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XG5cdFx0cmV0dXJuIHRoaXM7XG5cdCAgfVxuXG5cdCAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcblx0ICB2YXIgY2I7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcblx0XHRjYiA9IGNhbGxiYWNrc1tpXTtcblx0XHRpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuXHRcdCAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcblx0XHQgIGJyZWFrO1xuXHRcdH1cblx0ICB9XG5cdCAgcmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHBhcmFtIHtNaXhlZH0gLi4uXG5cdCAqIEByZXR1cm4ge0VtaXR0ZXJ9XG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG5cdCAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHQgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG5cdFx0LCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xuXG5cdCAgaWYgKGNhbGxiYWNrcykge1xuXHRcdGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG5cdFx0ICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fVxuXHQgIH1cblxuXHQgIHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcblx0ICogQHJldHVybiB7QXJyYXl9XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcblx0ICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdCAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XG5cdH07XG5cblx0LyoqXG5cdCAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdEVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcblx0ICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcblx0fTtcblxuXHR9LHt9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdGFyZ3VtZW50c1s0XVsxN11bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpXG5cdH0se1wiLi9kZWJ1Z1wiOjQwLFwiZHVwXCI6MTd9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdGFyZ3VtZW50c1s0XVsxOF1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpXG5cdH0se1wiZHVwXCI6MTgsXCJtc1wiOjQ0fV0sNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cblx0Lypcblx0ICogTW9kdWxlIHJlcXVpcmVtZW50cy5cblx0ICovXG5cblx0dmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpc2FycmF5Jyk7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBleHBvcnRzLlxuXHQgKi9cblxuXHRtb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuXHQvKipcblx0ICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cblx0ICpcblx0ICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cblx0ICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuXHRcdGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cblx0XHRpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuXHRcdFx0IChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG5cdFx0XHQgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG5cdFx0XHQgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG5cdFx0XHQpIHtcblx0XHQgIHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGlmIChpc0FycmF5KG9iaikpIHtcblx0XHQgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcblx0XHRcdFx0ICByZXR1cm4gdHJ1ZTtcblx0XHRcdCAgfVxuXHRcdCAgfVxuXHRcdH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcblx0XHQgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvaGFzLWJpbmFyeS9wdWxsLzRcblx0XHQgIGlmIChvYmoudG9KU09OICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIG9iai50b0pTT04pIHtcblx0XHRcdG9iaiA9IG9iai50b0pTT04oKTtcblx0XHQgIH1cblxuXHRcdCAgZm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcblx0XHRcdCAgcmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0ICB9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHQgIH1cblxuXHQgIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xuXHR9XG5cblx0fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDoge30pXG5cdH0se1wiaXNhcnJheVwiOjQzfV0sNDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHRhcmd1bWVudHNbNF1bMjNdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxuXHR9LHtcImR1cFwiOjIzfV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHRhcmd1bWVudHNbNF1bMjRdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxuXHR9LHtcImR1cFwiOjI0fV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHRhcmd1bWVudHNbNF1bMjVdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxuXHR9LHtcImR1cFwiOjI1fV0sNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHRhcmd1bWVudHNbNF1bMjhdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxuXHR9LHtcImR1cFwiOjI4fV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuXHQoZnVuY3Rpb24gKGdsb2JhbCl7XG5cdC8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cblx0LyoqXG5cdCAqIE1vZHVsZSByZXF1aXJlbWVudHNcblx0ICovXG5cblx0dmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpc2FycmF5Jyk7XG5cdHZhciBpc0J1ZiA9IF9kZXJlcV8oJy4vaXMtYnVmZmVyJyk7XG5cblx0LyoqXG5cdCAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG5cdCAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcblx0ICogaGVyZS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcblx0ICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG5cdCAgdmFyIGJ1ZmZlcnMgPSBbXTtcblx0ICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuXG5cdCAgZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcblx0XHRpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG5cdFx0aWYgKGlzQnVmKGRhdGEpKSB7XG5cdFx0ICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuXHRcdCAgYnVmZmVycy5wdXNoKGRhdGEpO1xuXHRcdCAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuXHRcdH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuXHRcdCAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuXHRcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuXHRcdCAgfVxuXHRcdCAgcmV0dXJuIG5ld0RhdGE7XG5cdFx0fSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuXHRcdCAgdmFyIG5ld0RhdGEgPSB7fTtcblx0XHQgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG5cdFx0XHRuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcblx0XHQgIH1cblx0XHQgIHJldHVybiBuZXdEYXRhO1xuXHRcdH1cblx0XHRyZXR1cm4gZGF0YTtcblx0ICB9XG5cblx0ICB2YXIgcGFjayA9IHBhY2tldDtcblx0ICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSk7XG5cdCAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcblx0ICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcblx0ICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcblx0ICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG5cdCAgdmFyIGN1clBsYWNlSG9sZGVyID0gMDtcblxuXHQgIGZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG5cdFx0aWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcblx0XHQgIHZhciBidWYgPSBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG5cdFx0ICByZXR1cm4gYnVmO1xuXHRcdH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuXHRcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuXHRcdCAgfVxuXHRcdCAgcmV0dXJuIGRhdGE7XG5cdFx0fSBlbHNlIGlmIChkYXRhICYmICdvYmplY3QnID09IHR5cGVvZiBkYXRhKSB7XG5cdFx0ICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuXHRcdFx0ZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG5cdFx0ICB9XG5cdFx0ICByZXR1cm4gZGF0YTtcblx0XHR9XG5cdFx0cmV0dXJuIGRhdGE7XG5cdCAgfVxuXG5cdCAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEpO1xuXHQgIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuXHQgIHJldHVybiBwYWNrZXQ7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuXHQgKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuXHQgKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRleHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcblx0ICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcblx0XHRpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuXHRcdC8vIGNvbnZlcnQgYW55IGJsb2Jcblx0XHRpZiAoKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG5cdFx0XHQoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcblx0XHQgIHBlbmRpbmdCbG9icysrO1xuXG5cdFx0ICAvLyBhc3luYyBmaWxlcmVhZGVyXG5cdFx0ICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0ICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuXHRcdFx0aWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcblx0XHRcdCAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG5cdFx0XHR9XG5cdFx0XHRlbHNlIHtcblx0XHRcdCAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuXHRcdFx0aWYoISAtLXBlbmRpbmdCbG9icykge1xuXHRcdFx0ICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuXHRcdFx0fVxuXHRcdCAgfTtcblxuXHRcdCAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG5cdFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuXHRcdFx0X3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcblx0XHQgIH1cblx0XHR9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3Rcblx0XHQgIGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRcdF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuXHRcdCAgfVxuXHRcdH1cblx0ICB9XG5cblx0ICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcblx0ICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcblx0ICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcblx0ICBpZiAoIXBlbmRpbmdCbG9icykge1xuXHRcdGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG5cdCAgfVxuXHR9O1xuXG5cdH0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxuXHR9LHtcIi4vaXMtYnVmZmVyXCI6NDgsXCJpc2FycmF5XCI6NDN9XSw0NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cblx0LyoqXG5cdCAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG5cdCAqL1xuXG5cdHZhciBkZWJ1ZyA9IF9kZXJlcV8oJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcblx0dmFyIGpzb24gPSBfZGVyZXFfKCdqc29uMycpO1xuXHR2YXIgaXNBcnJheSA9IF9kZXJlcV8oJ2lzYXJyYXknKTtcblx0dmFyIEVtaXR0ZXIgPSBfZGVyZXFfKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXHR2YXIgYmluYXJ5ID0gX2RlcmVxXygnLi9iaW5hcnknKTtcblx0dmFyIGlzQnVmID0gX2RlcmVxXygnLi9pcy1idWZmZXInKTtcblxuXHQvKipcblx0ICogUHJvdG9jb2wgdmVyc2lvbi5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlcy5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy50eXBlcyA9IFtcblx0ICAnQ09OTkVDVCcsXG5cdCAgJ0RJU0NPTk5FQ1QnLFxuXHQgICdFVkVOVCcsXG5cdCAgJ0JJTkFSWV9FVkVOVCcsXG5cdCAgJ0FDSycsXG5cdCAgJ0JJTkFSWV9BQ0snLFxuXHQgICdFUlJPUidcblx0XTtcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGUgYGNvbm5lY3RgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cblx0LyoqXG5cdCAqIFBhY2tldCB0eXBlIGBldmVudGAuXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdGV4cG9ydHMuRVZFTlQgPSAyO1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgYWNrYC5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5BQ0sgPSAzO1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRleHBvcnRzLkVSUk9SID0gNDtcblxuXHQvKipcblx0ICogUGFja2V0IHR5cGUgJ2JpbmFyeSBldmVudCdcblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG5cdC8qKlxuXHQgKiBQYWNrZXQgdHlwZSBgYmluYXJ5IGFja2AuIEZvciBhY2tzIHdpdGggYmluYXJ5IGFyZ3VtZW50cy5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuXHQvKipcblx0ICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuXHQvKipcblx0ICogRGVjb2RlciBjb25zdHJ1Y3Rvci5cblx0ICpcblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0ZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuXHQvKipcblx0ICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuXHQgKlxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBFbmNvZGVyKCkge31cblxuXHQvKipcblx0ICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG5cdCAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG5cdCAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3Ncblx0ICogQGFwaSBwdWJsaWNcblx0ICovXG5cblx0RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG5cdCAgZGVidWcoJ2VuY29kaW5nIHBhY2tldCAlaicsIG9iaik7XG5cblx0ICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG5cdFx0ZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHRcdHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG5cdFx0Y2FsbGJhY2soW2VuY29kaW5nXSk7XG5cdCAgfVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdGZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuXHQgIHZhciBzdHIgPSAnJztcblx0ICB2YXIgbnNwID0gZmFsc2U7XG5cblx0ICAvLyBmaXJzdCBpcyB0eXBlXG5cdCAgc3RyICs9IG9iai50eXBlO1xuXG5cdCAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG5cdCAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuXHRcdHN0ciArPSBvYmouYXR0YWNobWVudHM7XG5cdFx0c3RyICs9ICctJztcblx0ICB9XG5cblx0ICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG5cdCAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG5cdCAgaWYgKG9iai5uc3AgJiYgJy8nICE9IG9iai5uc3ApIHtcblx0XHRuc3AgPSB0cnVlO1xuXHRcdHN0ciArPSBvYmoubnNwO1xuXHQgIH1cblxuXHQgIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuXHQgIGlmIChudWxsICE9IG9iai5pZCkge1xuXHRcdGlmIChuc3ApIHtcblx0XHQgIHN0ciArPSAnLCc7XG5cdFx0ICBuc3AgPSBmYWxzZTtcblx0XHR9XG5cdFx0c3RyICs9IG9iai5pZDtcblx0ICB9XG5cblx0ICAvLyBqc29uIGRhdGFcblx0ICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuXHRcdGlmIChuc3ApIHN0ciArPSAnLCc7XG5cdFx0c3RyICs9IGpzb24uc3RyaW5naWZ5KG9iai5kYXRhKTtcblx0ICB9XG5cblx0ICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcblx0ICByZXR1cm4gc3RyO1xuXHR9XG5cblx0LyoqXG5cdCAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuXHQgKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG5cdCAqIGEgbGlzdCBvZiBidWZmZXJzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG5cdCAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG5cdCAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcblx0XHR2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcblx0XHR2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG5cdFx0dmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG5cdFx0YnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuXHRcdGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcblx0ICB9XG5cblx0ICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHRmdW5jdGlvbiBEZWNvZGVyKCkge1xuXHQgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG5cdH1cblxuXHQvKipcblx0ICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG5cdCAqL1xuXG5cdEVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG5cdC8qKlxuXHQgKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAYXBpIHB1YmxpY1xuXHQgKi9cblxuXHREZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcblx0ICB2YXIgcGFja2V0O1xuXHQgIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG5cdFx0cGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG5cdFx0aWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuXHRcdCAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuXHRcdCAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcblx0XHQgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG5cdFx0XHR0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuXHRcdCAgfVxuXHRcdH0gZWxzZSB7IC8vIG5vbi1iaW5hcnkgZnVsbCBwYWNrZXRcblx0XHQgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG5cdFx0fVxuXHQgIH1cblx0ICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG5cdFx0aWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcblx0XHQgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG5cdFx0fSBlbHNlIHtcblx0XHQgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuXHRcdCAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcblx0XHRcdHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG5cdFx0XHR0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuXHRcdCAgfVxuXHRcdH1cblx0ICB9XG5cdCAgZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuXHQgIH1cblx0fTtcblxuXHQvKipcblx0ICogRGVjb2RlIGEgcGFja2V0IFN0cmluZyAoSlNPTiBkYXRhKVxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdCAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBkZWNvZGVTdHJpbmcoc3RyKSB7XG5cdCAgdmFyIHAgPSB7fTtcblx0ICB2YXIgaSA9IDA7XG5cblx0ICAvLyBsb29rIHVwIHR5cGVcblx0ICBwLnR5cGUgPSBOdW1iZXIoc3RyLmNoYXJBdCgwKSk7XG5cdCAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSByZXR1cm4gZXJyb3IoKTtcblxuXHQgIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcblx0ICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwLnR5cGUpIHtcblx0XHR2YXIgYnVmID0gJyc7XG5cdFx0d2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPSAnLScpIHtcblx0XHQgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuXHRcdCAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG5cdFx0fVxuXHRcdGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPSAnLScpIHtcblx0XHQgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuXHRcdH1cblx0XHRwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG5cdCAgfVxuXG5cdCAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcblx0ICBpZiAoJy8nID09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG5cdFx0cC5uc3AgPSAnJztcblx0XHR3aGlsZSAoKytpKSB7XG5cdFx0ICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG5cdFx0ICBpZiAoJywnID09IGMpIGJyZWFrO1xuXHRcdCAgcC5uc3AgKz0gYztcblx0XHQgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuXHRcdH1cblx0ICB9IGVsc2Uge1xuXHRcdHAubnNwID0gJy8nO1xuXHQgIH1cblxuXHQgIC8vIGxvb2sgdXAgaWRcblx0ICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuXHQgIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuXHRcdHAuaWQgPSAnJztcblx0XHR3aGlsZSAoKytpKSB7XG5cdFx0ICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG5cdFx0ICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG5cdFx0XHQtLWk7XG5cdFx0XHRicmVhaztcblx0XHQgIH1cblx0XHQgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcblx0XHQgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuXHRcdH1cblx0XHRwLmlkID0gTnVtYmVyKHAuaWQpO1xuXHQgIH1cblxuXHQgIC8vIGxvb2sgdXAganNvbiBkYXRhXG5cdCAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuXHRcdHRyeSB7XG5cdFx0ICBwLmRhdGEgPSBqc29uLnBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuXHRcdH0gY2F0Y2goZSl7XG5cdFx0ICByZXR1cm4gZXJyb3IoKTtcblx0XHR9XG5cdCAgfVxuXG5cdCAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuXHQgIHJldHVybiBwO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG5cdCAqXG5cdCAqIEBhcGkgcHVibGljXG5cdCAqL1xuXG5cdERlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcblx0ICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG5cdFx0dGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcblx0ICB9XG5cdH07XG5cblx0LyoqXG5cdCAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcblx0ICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcblx0ICogZGVjb2RlZC5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuXHQgKiBAcmV0dXJuIHtCaW5hcnlSZWNvbnN0cnVjdG9yfSBpbml0aWFsaXplZCByZWNvbnN0cnVjdG9yXG5cdCAqIEBhcGkgcHJpdmF0ZVxuXHQgKi9cblxuXHRmdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCkge1xuXHQgIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuXHQgIHRoaXMuYnVmZmVycyA9IFtdO1xuXHR9XG5cblx0LyoqXG5cdCAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cblx0ICogYWZ0ZXIgYSBCSU5BUllfRVZFTlQgcGFja2V0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuXHQgKiBAcmV0dXJuIHtudWxsIHwgT2JqZWN0fSByZXR1cm5zIG51bGwgaWYgbW9yZSBiaW5hcnkgZGF0YSBpcyBleHBlY3RlZCBvclxuXHQgKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdEJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuXHQgIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuXHQgIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuXHRcdHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG5cdFx0dGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG5cdFx0cmV0dXJuIHBhY2tldDtcblx0ICB9XG5cdCAgcmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyoqXG5cdCAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cblx0ICpcblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXG5cdEJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcblx0ICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG5cdCAgdGhpcy5idWZmZXJzID0gW107XG5cdH07XG5cblx0ZnVuY3Rpb24gZXJyb3IoZGF0YSl7XG5cdCAgcmV0dXJuIHtcblx0XHR0eXBlOiBleHBvcnRzLkVSUk9SLFxuXHRcdGRhdGE6ICdwYXJzZXIgZXJyb3InXG5cdCAgfTtcblx0fVxuXG5cdH0se1wiLi9iaW5hcnlcIjo0NixcIi4vaXMtYnVmZmVyXCI6NDgsXCJjb21wb25lbnQtZW1pdHRlclwiOjQ5LFwiZGVidWdcIjozOSxcImlzYXJyYXlcIjo0MyxcImpzb24zXCI6NTB9XSw0ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdChmdW5jdGlvbiAoZ2xvYmFsKXtcblxuXHRtb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuXHQgKlxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cblx0ZnVuY3Rpb24gaXNCdWYob2JqKSB7XG5cdCAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcblx0XHRcdCAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcblx0fVxuXG5cdH0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxuXHR9LHt9XSw0OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdGFyZ3VtZW50c1s0XVsxNV1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpXG5cdH0se1wiZHVwXCI6MTV9XSw1MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdChmdW5jdGlvbiAoZ2xvYmFsKXtcblx0LyohIEpTT04gdjMuMy4yIHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTQsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuXHQ7KGZ1bmN0aW9uICgpIHtcblx0ICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcblx0ICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuXHQgIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG5cdCAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cblx0ICB2YXIgb2JqZWN0VHlwZXMgPSB7XG5cdFx0XCJmdW5jdGlvblwiOiB0cnVlLFxuXHRcdFwib2JqZWN0XCI6IHRydWVcblx0ICB9O1xuXG5cdCAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuXHQgIHZhciBmcmVlRXhwb3J0cyA9IG9iamVjdFR5cGVzW3R5cGVvZiBleHBvcnRzXSAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cblx0ICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuXHQgIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG5cdCAgLy8gYW5kIHRoZSBgd2luZG93YCBvYmplY3QgaW4gYnJvd3NlcnMuIFJoaW5vIGV4cG9ydHMgYSBgZ2xvYmFsYCBmdW5jdGlvblxuXHQgIC8vIGluc3RlYWQuXG5cdCAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcblx0XHQgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG5cdCAgaWYgKGZyZWVHbG9iYWwgJiYgKGZyZWVHbG9iYWxbXCJnbG9iYWxcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcIndpbmRvd1wiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wic2VsZlwiXSA9PT0gZnJlZUdsb2JhbCkpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0ICB9XG5cblx0ICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuXHQgIC8vIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGZ1bmN0aW9ucyB0byB0aGUgc3BlY2lmaWVkIGBleHBvcnRzYCBvYmplY3QuXG5cdCAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcblx0XHRjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblx0XHRleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuXHRcdC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuXHRcdHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG5cdFx0XHRTdHJpbmcgPSBjb250ZXh0W1wiU3RyaW5nXCJdIHx8IHJvb3RbXCJTdHJpbmdcIl0sXG5cdFx0XHRPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG5cdFx0XHREYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG5cdFx0XHRTeW50YXhFcnJvciA9IGNvbnRleHRbXCJTeW50YXhFcnJvclwiXSB8fCByb290W1wiU3ludGF4RXJyb3JcIl0sXG5cdFx0XHRUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG5cdFx0XHRNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG5cdFx0XHRuYXRpdmVKU09OID0gY29udGV4dFtcIkpTT05cIl0gfHwgcm9vdFtcIkpTT05cIl07XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgIGltcGxlbWVudGF0aW9ucy5cblx0XHRpZiAodHlwZW9mIG5hdGl2ZUpTT04gPT0gXCJvYmplY3RcIiAmJiBuYXRpdmVKU09OKSB7XG5cdFx0ICBleHBvcnRzLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuXHRcdCAgZXhwb3J0cy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVuaWVuY2UgYWxpYXNlcy5cblx0XHR2YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuXHRcdFx0Z2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcblx0XHRcdGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG5cdFx0Ly8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuXHRcdHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuXHRcdHRyeSB7XG5cdFx0ICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuXHRcdCAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cblx0XHQgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcblx0XHRcdC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG5cdFx0XHQvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuXHRcdFx0Ly8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuXHRcdFx0aXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG5cdFx0fSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG5cdFx0Ly8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcblx0XHQvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG5cdFx0ZnVuY3Rpb24gaGFzKG5hbWUpIHtcblx0XHQgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG5cdFx0XHQvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG5cdFx0XHRyZXR1cm4gaGFzW25hbWVdO1xuXHRcdCAgfVxuXHRcdCAgdmFyIGlzU3VwcG9ydGVkO1xuXHRcdCAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuXHRcdFx0Ly8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuXHRcdFx0Ly8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG5cdFx0XHRpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuXHRcdCAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG5cdFx0XHQvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcblx0XHRcdC8vIHN1cHBvcnRlZC5cblx0XHRcdGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcblx0XHQgIH0gZWxzZSB7XG5cdFx0XHR2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19Jztcblx0XHRcdC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cblx0XHRcdGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuXHRcdFx0ICB2YXIgc3RyaW5naWZ5ID0gZXhwb3J0cy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG5cdFx0XHQgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcblx0XHRcdFx0Ly8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cblx0XHRcdFx0KHZhbHVlID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHQgIHJldHVybiAxO1xuXHRcdFx0XHR9KS50b0pTT04gPSB2YWx1ZTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0ICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuXHRcdFx0XHRcdC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cblx0XHRcdFx0XHQvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cblx0XHRcdFx0XHRzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG5cdFx0XHRcdFx0Ly8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG5cdFx0XHRcdFx0Ly8gbGl0ZXJhbHMuXG5cdFx0XHRcdFx0c3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG5cdFx0XHRcdFx0c3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG5cdFx0XHRcdFx0Ly8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG5cdFx0XHRcdFx0Ly8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuXHRcdFx0XHRcdC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuXHRcdFx0XHRcdC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuXHRcdFx0XHRcdHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG5cdFx0XHRcdFx0Ly8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuXHRcdFx0XHRcdC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuXHRcdFx0XHRcdHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG5cdFx0XHRcdFx0Ly8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuXHRcdFx0XHRcdC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG5cdFx0XHRcdFx0c3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG5cdFx0XHRcdFx0Ly8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcblx0XHRcdFx0XHQvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cblx0XHRcdFx0XHQvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuXHRcdFx0XHRcdC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG5cdFx0XHRcdFx0Ly8gbWV0aG9kcyBlbnRpcmVseS5cblx0XHRcdFx0XHRzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuXHRcdFx0XHRcdHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG5cdFx0XHRcdFx0Ly8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG5cdFx0XHRcdFx0Ly8gYFwiW251bGxdXCJgLlxuXHRcdFx0XHRcdHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG5cdFx0XHRcdFx0Ly8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cblx0XHRcdFx0XHRzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcblx0XHRcdFx0XHQvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG5cdFx0XHRcdFx0Ly8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG5cdFx0XHRcdFx0Ly8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcblx0XHRcdFx0XHQvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG5cdFx0XHRcdFx0c3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuXHRcdFx0XHRcdC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG5cdFx0XHRcdFx0Ly8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG5cdFx0XHRcdFx0c3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuXHRcdFx0XHRcdC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cblx0XHRcdFx0XHRzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuXHRcdFx0XHRcdHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG5cdFx0XHRcdFx0Ly8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuXHRcdFx0XHRcdC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cblx0XHRcdFx0XHRzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcblx0XHRcdFx0XHQvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuXHRcdFx0XHRcdHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG5cdFx0XHRcdFx0Ly8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuXHRcdFx0XHRcdC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG5cdFx0XHRcdFx0c3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuXHRcdFx0XHRcdC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG5cdFx0XHRcdFx0Ly8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuXHRcdFx0XHRcdHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcblx0XHRcdFx0fSBjYXRjaCAoZXhjZXB0aW9uKSB7XG5cdFx0XHRcdCAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdCAgfVxuXHRcdFx0ICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcblx0XHRcdH1cblx0XHRcdC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuXHRcdFx0aWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcblx0XHRcdCAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcblx0XHRcdCAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0ICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG5cdFx0XHRcdCAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG5cdFx0XHRcdCAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cblx0XHRcdFx0ICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcblx0XHRcdFx0XHQvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuXHRcdFx0XHRcdHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG5cdFx0XHRcdFx0dmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcblx0XHRcdFx0XHRpZiAocGFyc2VTdXBwb3J0ZWQpIHtcblx0XHRcdFx0XHQgIHRyeSB7XG5cdFx0XHRcdFx0XHQvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG5cdFx0XHRcdFx0XHRwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuXHRcdFx0XHRcdCAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXHRcdFx0XHRcdCAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0ICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG5cdFx0XHRcdFx0XHQgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG5cdFx0XHRcdFx0XHQgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG5cdFx0XHRcdFx0XHQgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHQgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdCAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcblx0XHRcdFx0XHRcdCAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG5cdFx0XHRcdFx0XHQgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuXHRcdFx0XHRcdFx0ICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cdFx0XHRcdFx0ICB9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQgIH1cblx0XHRcdFx0fSBjYXRjaCAoZXhjZXB0aW9uKSB7XG5cdFx0XHRcdCAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0ICB9XG5cdFx0XHQgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG5cdFx0XHR9XG5cdFx0ICB9XG5cdFx0ICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcblx0XHR9XG5cblx0XHRpZiAoIWhhcyhcImpzb25cIikpIHtcblx0XHQgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG5cdFx0ICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcblx0XHRcdCAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG5cdFx0XHQgIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIixcblx0XHRcdCAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuXHRcdFx0ICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuXHRcdFx0ICBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuXHRcdCAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuXHRcdCAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG5cdFx0ICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cblx0XHQgIGlmICghaXNFeHRlbmRlZCkge1xuXHRcdFx0dmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblx0XHRcdC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG5cdFx0XHQvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuXHRcdFx0dmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG5cdFx0XHQvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG5cdFx0XHQvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuXHRcdFx0dmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuXHRcdFx0ICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG5cdFx0XHR9O1xuXHRcdCAgfVxuXG5cdFx0ICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuXHRcdCAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG5cdFx0ICBpZiAoIShpc1Byb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHkpKSB7XG5cdFx0XHRpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG5cdFx0XHQgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuXHRcdFx0ICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG5cdFx0XHRcdC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG5cdFx0XHRcdC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cblx0XHRcdFx0XCJ0b1N0cmluZ1wiOiAxXG5cdFx0XHQgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG5cdFx0XHRcdC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG5cdFx0XHRcdC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG5cdFx0XHRcdGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcblx0XHRcdFx0ICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuXHRcdFx0XHQgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cblx0XHRcdFx0ICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG5cdFx0XHRcdCAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuXHRcdFx0XHQgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cblx0XHRcdFx0ICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuXHRcdFx0XHQgIHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH07XG5cdFx0XHQgIH0gZWxzZSB7XG5cdFx0XHRcdC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cblx0XHRcdFx0Y29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuXHRcdFx0XHQvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cblx0XHRcdFx0Ly8gb3RoZXIgZW52aXJvbm1lbnRzLlxuXHRcdFx0XHRpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG5cdFx0XHRcdCAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG5cdFx0XHRcdCAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuXHRcdFx0XHR9O1xuXHRcdFx0ICB9XG5cdFx0XHQgIG1lbWJlcnMgPSBudWxsO1xuXHRcdFx0ICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcblx0XHRcdH07XG5cdFx0ICB9XG5cblx0XHQgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG5cdFx0ICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG5cdFx0ICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcblx0XHRcdHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cblx0XHRcdC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuXHRcdFx0Ly8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cblx0XHRcdC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuXHRcdFx0KFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHQgIHRoaXMudmFsdWVPZiA9IDA7XG5cdFx0XHR9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cblx0XHRcdC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuXHRcdFx0bWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG5cdFx0XHRmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcblx0XHRcdCAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cblx0XHRcdCAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcblx0XHRcdFx0c2l6ZSsrO1xuXHRcdFx0ICB9XG5cdFx0XHR9XG5cdFx0XHRQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cblx0XHRcdC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cblx0XHRcdGlmICghc2l6ZSkge1xuXHRcdFx0ICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG5cdFx0XHQgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG5cdFx0XHQgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuXHRcdFx0ICAvLyBwcm9wZXJ0aWVzLlxuXHRcdFx0ICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcblx0XHRcdFx0dmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSBcImZ1bmN0aW9uXCIgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG9iamVjdC5oYXNPd25Qcm9wZXJ0eV0gJiYgb2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGlzUHJvcGVydHk7XG5cdFx0XHRcdGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdCAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuXHRcdFx0XHQgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG5cdFx0XHRcdCAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2socHJvcGVydHkpO1xuXHRcdFx0XHQgIH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuXHRcdFx0XHRmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG5cdFx0XHQgIH07XG5cdFx0XHR9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuXHRcdFx0ICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuXHRcdFx0ICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcblx0XHRcdFx0Ly8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG5cdFx0XHRcdHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG5cdFx0XHRcdGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG5cdFx0XHRcdCAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcblx0XHRcdFx0ICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuXHRcdFx0XHQgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cblx0XHRcdFx0ICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKHByb3BlcnR5KTtcblx0XHRcdFx0ICB9XG5cdFx0XHRcdH1cblx0XHRcdCAgfTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHQgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG5cdFx0XHQgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3Rvcjtcblx0XHRcdFx0Zm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcblx0XHRcdFx0ICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKHByb3BlcnR5KTtcblx0XHRcdFx0ICB9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG5cdFx0XHRcdC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cblx0XHRcdFx0aWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcblx0XHRcdFx0ICBjYWxsYmFjayhwcm9wZXJ0eSk7XG5cdFx0XHRcdH1cblx0XHRcdCAgfTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuXHRcdCAgfTtcblxuXHRcdCAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuXHRcdCAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcblx0XHQgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuXHRcdCAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG5cdFx0ICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cblx0XHQgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG5cdFx0ICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG5cdFx0XHQvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuXHRcdFx0dmFyIEVzY2FwZXMgPSB7XG5cdFx0XHQgIDkyOiBcIlxcXFxcXFxcXCIsXG5cdFx0XHQgIDM0OiAnXFxcXFwiJyxcblx0XHRcdCAgODogXCJcXFxcYlwiLFxuXHRcdFx0ICAxMjogXCJcXFxcZlwiLFxuXHRcdFx0ICAxMDogXCJcXFxcblwiLFxuXHRcdFx0ICAxMzogXCJcXFxcclwiLFxuXHRcdFx0ICA5OiBcIlxcXFx0XCJcblx0XHRcdH07XG5cblx0XHRcdC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuXHRcdFx0Ly8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cblx0XHRcdHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcblx0XHRcdHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcblx0XHRcdCAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuXHRcdFx0ICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cblx0XHRcdCAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG5cdFx0XHQvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG5cdFx0XHQvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuXHRcdFx0Ly8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cblx0XHRcdHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG5cdFx0XHR2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdCAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCB1c2VDaGFySW5kZXggPSAhY2hhckluZGV4QnVnZ3kgfHwgbGVuZ3RoID4gMTA7XG5cdFx0XHQgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuXHRcdFx0ICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcblx0XHRcdFx0dmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG5cdFx0XHRcdC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG5cdFx0XHRcdC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG5cdFx0XHRcdHN3aXRjaCAoY2hhckNvZGUpIHtcblx0XHRcdFx0ICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5Mjpcblx0XHRcdFx0XHRyZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdCAgZGVmYXVsdDpcblx0XHRcdFx0XHRpZiAoY2hhckNvZGUgPCAzMikge1xuXHRcdFx0XHRcdCAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuXHRcdFx0XHRcdCAgYnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG5cdFx0XHRcdH1cblx0XHRcdCAgfVxuXHRcdFx0ICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcblx0XHRcdH07XG5cblx0XHRcdC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcblx0XHRcdC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuXHRcdFx0dmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG5cdFx0XHQgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG5cdFx0XHQgIHRyeSB7XG5cdFx0XHRcdC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cblx0XHRcdFx0dmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuXHRcdFx0ICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cdFx0XHQgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcblx0XHRcdFx0aWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcblx0XHRcdFx0ICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuXHRcdFx0XHRcdC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2Rcblx0XHRcdFx0XHQvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcblx0XHRcdFx0XHQvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuXHRcdFx0XHRcdGlmIChnZXREYXkpIHtcblx0XHRcdFx0XHQgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcblx0XHRcdFx0XHQgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuXHRcdFx0XHRcdCAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cblx0XHRcdFx0XHQgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcblx0XHRcdFx0XHQgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuXHRcdFx0XHRcdCAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG5cdFx0XHRcdFx0ICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuXHRcdFx0XHRcdCAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuXHRcdFx0XHRcdCAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG5cdFx0XHRcdFx0ICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuXHRcdFx0XHRcdCAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuXHRcdFx0XHRcdCAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG5cdFx0XHRcdFx0ICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG5cdFx0XHRcdFx0ICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuXHRcdFx0XHRcdCAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcblx0XHRcdFx0XHQgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuXHRcdFx0XHRcdCAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG5cdFx0XHRcdFx0ICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcblx0XHRcdFx0XHQgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcblx0XHRcdFx0XHQgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG5cdFx0XHRcdFx0ICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG5cdFx0XHRcdFx0ICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuXHRcdFx0XHRcdCAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcblx0XHRcdFx0XHQgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuXHRcdFx0XHRcdHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcblx0XHRcdFx0XHQgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuXHRcdFx0XHRcdCAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuXHRcdFx0XHRcdCAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG5cdFx0XHRcdFx0ICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcblx0XHRcdFx0XHQgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuXHRcdFx0XHRcdCAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG5cdFx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IG51bGw7XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcblx0XHRcdFx0ICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcblx0XHRcdFx0ICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG5cdFx0XHRcdCAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuXHRcdFx0XHQgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG5cdFx0XHRcdCAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuXHRcdFx0XHR9XG5cdFx0XHQgIH1cblx0XHRcdCAgaWYgKGNhbGxiYWNrKSB7XG5cdFx0XHRcdC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcblx0XHRcdFx0Ly8gZm9yIHNlcmlhbGl6YXRpb24uXG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG5cdFx0XHQgIH1cblx0XHRcdCAgaWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBcIm51bGxcIjtcblx0XHRcdCAgfVxuXHRcdFx0ICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcblx0XHRcdCAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcblx0XHRcdFx0Ly8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cblx0XHRcdFx0cmV0dXJuIFwiXCIgKyB2YWx1ZTtcblx0XHRcdCAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcblx0XHRcdFx0Ly8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuXHRcdFx0XHQvLyBgXCJudWxsXCJgLlxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuXHRcdFx0ICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuXHRcdFx0XHQvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuXHRcdFx0XHRyZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcblx0XHRcdCAgfVxuXHRcdFx0ICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuXHRcdFx0ICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0Ly8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2Vcblx0XHRcdFx0Ly8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cblx0XHRcdFx0Zm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuXHRcdFx0XHQgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuXHRcdFx0XHRcdC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG5cdFx0XHRcdFx0dGhyb3cgVHlwZUVycm9yKCk7XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cblx0XHRcdFx0c3RhY2sucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdHJlc3VsdHMgPSBbXTtcblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuXHRcdFx0XHRwcmVmaXggPSBpbmRlbnRhdGlvbjtcblx0XHRcdFx0aW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcblx0XHRcdFx0aWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG5cdFx0XHRcdCAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuXHRcdFx0XHQgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0XHRcdFx0ZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuXHRcdFx0XHRcdHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHQgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG5cdFx0XHRcdCAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuXHRcdFx0XHQgIC8vIGl0c2VsZi5cblx0XHRcdFx0ICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuXHRcdFx0XHRcdHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG5cdFx0XHRcdFx0aWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG5cdFx0XHRcdFx0ICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cblx0XHRcdFx0XHQgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuXHRcdFx0XHRcdCAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuXHRcdFx0XHRcdCAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2Vcblx0XHRcdFx0XHQgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cblx0XHRcdFx0XHQgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG5cdFx0XHRcdFx0ICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdCAgfSk7XG5cdFx0XHRcdCAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuXHRcdFx0XHRzdGFjay5wb3AoKTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdCAgfVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cblx0XHRcdGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuXHRcdFx0ICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcblx0XHRcdCAgaWYgKG9iamVjdFR5cGVzW3R5cGVvZiBmaWx0ZXJdICYmIGZpbHRlcikge1xuXHRcdFx0XHRpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuXHRcdFx0XHQgIGNhbGxiYWNrID0gZmlsdGVyO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG5cdFx0XHRcdCAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG5cdFx0XHRcdCAgcHJvcGVydGllcyA9IHt9O1xuXHRcdFx0XHQgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcblx0XHRcdFx0fVxuXHRcdFx0ICB9XG5cdFx0XHQgIGlmICh3aWR0aCkge1xuXHRcdFx0XHRpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuXHRcdFx0XHQgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcblx0XHRcdFx0ICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuXHRcdFx0XHQgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcblx0XHRcdFx0XHRmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHR9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuXHRcdFx0XHQgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcblx0XHRcdFx0fVxuXHRcdFx0ICB9XG5cdFx0XHQgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuXHRcdFx0ICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuXHRcdFx0ICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuXHRcdFx0ICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuXHRcdFx0fTtcblx0XHQgIH1cblxuXHRcdCAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG5cdFx0ICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcblx0XHRcdHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdFx0XHQvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuXHRcdFx0Ly8gZXF1aXZhbGVudHMuXG5cdFx0XHR2YXIgVW5lc2NhcGVzID0ge1xuXHRcdFx0ICA5MjogXCJcXFxcXCIsXG5cdFx0XHQgIDM0OiAnXCInLFxuXHRcdFx0ICA0NzogXCIvXCIsXG5cdFx0XHQgIDk4OiBcIlxcYlwiLFxuXHRcdFx0ICAxMTY6IFwiXFx0XCIsXG5cdFx0XHQgIDExMDogXCJcXG5cIixcblx0XHRcdCAgMTAyOiBcIlxcZlwiLFxuXHRcdFx0ICAxMTQ6IFwiXFxyXCJcblx0XHRcdH07XG5cblx0XHRcdC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cblx0XHRcdHZhciBJbmRleCwgU291cmNlO1xuXG5cdFx0XHQvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG5cdFx0XHR2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHQgIEluZGV4ID0gU291cmNlID0gbnVsbDtcblx0XHRcdCAgdGhyb3cgU3ludGF4RXJyb3IoKTtcblx0XHRcdH07XG5cblx0XHRcdC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcblx0XHRcdC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuXHRcdFx0Ly8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuXHRcdFx0dmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdCAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuXHRcdFx0ICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdFx0Y2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG5cdFx0XHRcdHN3aXRjaCAoY2hhckNvZGUpIHtcblx0XHRcdFx0ICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG5cdFx0XHRcdFx0Ly8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcblx0XHRcdFx0XHQvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG5cdFx0XHRcdFx0SW5kZXgrKztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG5cdFx0XHRcdFx0Ly8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuXHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuXHRcdFx0XHRcdHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG5cdFx0XHRcdFx0SW5kZXgrKztcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdCAgY2FzZSAzNDpcblx0XHRcdFx0XHQvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuXHRcdFx0XHRcdC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcblx0XHRcdFx0XHQvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcblx0XHRcdFx0XHQvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cblx0XHRcdFx0XHRmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuXHRcdFx0XHRcdCAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG5cdFx0XHRcdFx0ICBpZiAoY2hhckNvZGUgPCAzMikge1xuXHRcdFx0XHRcdFx0Ly8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuXHRcdFx0XHRcdFx0Ly8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuXHRcdFx0XHRcdFx0YWJvcnQoKTtcblx0XHRcdFx0XHQgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcblx0XHRcdFx0XHRcdC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcblx0XHRcdFx0XHRcdC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuXHRcdFx0XHRcdFx0Ly8gZXNjYXBlIHNlcXVlbmNlLlxuXHRcdFx0XHRcdFx0Y2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcblx0XHRcdFx0XHRcdHN3aXRjaCAoY2hhckNvZGUpIHtcblx0XHRcdFx0XHRcdCAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG5cdFx0XHRcdFx0XHRcdC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cblx0XHRcdFx0XHRcdFx0dmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcblx0XHRcdFx0XHRcdFx0SW5kZXgrKztcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHQgIGNhc2UgMTE3OlxuXHRcdFx0XHRcdFx0XHQvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG5cdFx0XHRcdFx0XHRcdC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG5cdFx0XHRcdFx0XHRcdC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cblx0XHRcdFx0XHRcdFx0YmVnaW4gPSArK0luZGV4O1xuXHRcdFx0XHRcdFx0XHRmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG5cdFx0XHRcdFx0XHRcdCAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG5cdFx0XHRcdFx0XHRcdCAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG5cdFx0XHRcdFx0XHRcdCAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cblx0XHRcdFx0XHRcdFx0ICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cblx0XHRcdFx0XHRcdFx0XHRhYm9ydCgpO1xuXHRcdFx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHQvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuXHRcdFx0XHRcdFx0XHR2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdCAgZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0Ly8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG5cdFx0XHRcdFx0XHRcdGFib3J0KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ICB9IGVsc2Uge1xuXHRcdFx0XHRcdFx0aWYgKGNoYXJDb2RlID09IDM0KSB7XG5cdFx0XHRcdFx0XHQgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG5cdFx0XHRcdFx0XHQgIC8vIHN0cmluZy5cblx0XHRcdFx0XHRcdCAgYnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcblx0XHRcdFx0XHRcdGJlZ2luID0gSW5kZXg7XG5cdFx0XHRcdFx0XHQvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuXHRcdFx0XHRcdFx0d2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG5cdFx0XHRcdFx0XHQgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cblx0XHRcdFx0XHRcdHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG5cdFx0XHRcdFx0ICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cblx0XHRcdFx0XHQgIEluZGV4Kys7XG5cdFx0XHRcdFx0ICByZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG5cdFx0XHRcdFx0YWJvcnQoKTtcblx0XHRcdFx0ICBkZWZhdWx0OlxuXHRcdFx0XHRcdC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuXHRcdFx0XHRcdGJlZ2luID0gSW5kZXg7XG5cdFx0XHRcdFx0Ly8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuXHRcdFx0XHRcdGlmIChjaGFyQ29kZSA9PSA0NSkge1xuXHRcdFx0XHRcdCAgaXNTaWduZWQgPSB0cnVlO1xuXHRcdFx0XHRcdCAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cblx0XHRcdFx0XHRpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcblx0XHRcdFx0XHQgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cblx0XHRcdFx0XHQgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuXHRcdFx0XHRcdFx0Ly8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuXHRcdFx0XHRcdFx0YWJvcnQoKTtcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHQgIGlzU2lnbmVkID0gZmFsc2U7XG5cdFx0XHRcdFx0ICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG5cdFx0XHRcdFx0ICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG5cdFx0XHRcdFx0ICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcblx0XHRcdFx0XHQgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG5cdFx0XHRcdFx0ICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG5cdFx0XHRcdFx0XHRwb3NpdGlvbiA9ICsrSW5kZXg7XG5cdFx0XHRcdFx0XHQvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG5cdFx0XHRcdFx0XHRmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG5cdFx0XHRcdFx0XHRpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcblx0XHRcdFx0XHRcdCAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuXHRcdFx0XHRcdFx0ICBhYm9ydCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0SW5kZXggPSBwb3NpdGlvbjtcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHQgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcblx0XHRcdFx0XHQgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG5cdFx0XHRcdFx0ICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcblx0XHRcdFx0XHQgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcblx0XHRcdFx0XHRcdGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG5cdFx0XHRcdFx0XHQvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG5cdFx0XHRcdFx0XHQvLyBzcGVjaWZpZWQuXG5cdFx0XHRcdFx0XHRpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcblx0XHRcdFx0XHRcdCAgSW5kZXgrKztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG5cdFx0XHRcdFx0XHRmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuXHRcdFx0XHRcdFx0aWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG5cdFx0XHRcdFx0XHQgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG5cdFx0XHRcdFx0XHQgIGFib3J0KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRJbmRleCA9IHBvc2l0aW9uO1xuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdCAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cblx0XHRcdFx0XHQgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG5cdFx0XHRcdFx0aWYgKGlzU2lnbmVkKSB7XG5cdFx0XHRcdFx0ICBhYm9ydCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG5cdFx0XHRcdFx0aWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuXHRcdFx0XHRcdCAgSW5kZXggKz0gNDtcblx0XHRcdFx0XHQgIHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuXHRcdFx0XHRcdCAgSW5kZXggKz0gNTtcblx0XHRcdFx0XHQgIHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuXHRcdFx0XHRcdCAgSW5kZXggKz0gNDtcblx0XHRcdFx0XHQgIHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG5cdFx0XHRcdFx0YWJvcnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0ICB9XG5cdFx0XHQgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcblx0XHRcdCAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG5cdFx0XHQgIHJldHVybiBcIiRcIjtcblx0XHRcdH07XG5cblx0XHRcdC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG5cdFx0XHR2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0XHQgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuXHRcdFx0ICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcblx0XHRcdFx0Ly8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG5cdFx0XHRcdGFib3J0KCk7XG5cdFx0XHQgIH1cblx0XHRcdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG5cdFx0XHRcdGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcblx0XHRcdFx0ICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG5cdFx0XHRcdCAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG5cdFx0XHRcdGlmICh2YWx1ZSA9PSBcIltcIikge1xuXHRcdFx0XHQgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuXHRcdFx0XHQgIHJlc3VsdHMgPSBbXTtcblx0XHRcdFx0ICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuXHRcdFx0XHRcdHZhbHVlID0gbGV4KCk7XG5cdFx0XHRcdFx0Ly8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG5cdFx0XHRcdFx0aWYgKHZhbHVlID09IFwiXVwiKSB7XG5cdFx0XHRcdFx0ICBicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuXHRcdFx0XHRcdC8vIG5leHQuXG5cdFx0XHRcdFx0aWYgKGhhc01lbWJlcnMpIHtcblx0XHRcdFx0XHQgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBsZXgoKTtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSA9PSBcIl1cIikge1xuXHRcdFx0XHRcdFx0ICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuXHRcdFx0XHRcdFx0ICBhYm9ydCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCAgfSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuXHRcdFx0XHRcdFx0YWJvcnQoKTtcblx0XHRcdFx0XHQgIH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuXHRcdFx0XHRcdGlmICh2YWx1ZSA9PSBcIixcIikge1xuXHRcdFx0XHRcdCAgYWJvcnQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuXHRcdFx0XHQgIH1cblx0XHRcdFx0ICByZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuXHRcdFx0XHQgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG5cdFx0XHRcdCAgcmVzdWx0cyA9IHt9O1xuXHRcdFx0XHQgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBsZXgoKTtcblx0XHRcdFx0XHQvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG5cdFx0XHRcdFx0aWYgKHZhbHVlID09IFwifVwiKSB7XG5cdFx0XHRcdFx0ICBicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG5cdFx0XHRcdFx0Ly8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuXHRcdFx0XHRcdGlmIChoYXNNZW1iZXJzKSB7XG5cdFx0XHRcdFx0ICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gbGV4KCk7XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgPT0gXCJ9XCIpIHtcblx0XHRcdFx0XHRcdCAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG5cdFx0XHRcdFx0XHQgIGFib3J0KCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ICB9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG5cdFx0XHRcdFx0XHRhYm9ydCgpO1xuXHRcdFx0XHRcdCAgfVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcblx0XHRcdFx0XHQvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcblx0XHRcdFx0XHQvLyBuYW1lIGFuZCB2YWx1ZS5cblx0XHRcdFx0XHRpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG5cdFx0XHRcdFx0ICBhYm9ydCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG5cdFx0XHRcdCAgfVxuXHRcdFx0XHQgIHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG5cdFx0XHRcdGFib3J0KCk7XG5cdFx0XHQgIH1cblx0XHRcdCAgcmV0dXJuIHZhbHVlO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cblx0XHRcdHZhciB1cGRhdGUgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcblx0XHRcdCAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcblx0XHRcdCAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG5cdFx0XHRcdGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuXHRcdFx0ICB9IGVsc2Uge1xuXHRcdFx0XHRzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcblx0XHRcdCAgfVxuXHRcdFx0fTtcblxuXHRcdFx0Ly8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG5cdFx0XHQvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuXHRcdFx0Ly8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cblx0XHRcdHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG5cdFx0XHQgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcblx0XHRcdCAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG5cdFx0XHRcdC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcblx0XHRcdFx0Ly8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG5cdFx0XHRcdC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cblx0XHRcdFx0aWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcblx0XHRcdFx0ICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG5cdFx0XHRcdFx0dXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcblx0XHRcdFx0ICB9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdCAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG5cdFx0XHRcdFx0dXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuXHRcdFx0XHQgIH0pO1xuXHRcdFx0XHR9XG5cdFx0XHQgIH1cblx0XHRcdCAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuXHRcdFx0ZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG5cdFx0XHQgIHZhciByZXN1bHQsIHZhbHVlO1xuXHRcdFx0ICBJbmRleCA9IDA7XG5cdFx0XHQgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG5cdFx0XHQgIHJlc3VsdCA9IGdldChsZXgoKSk7XG5cdFx0XHQgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuXHRcdFx0ICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcblx0XHRcdFx0YWJvcnQoKTtcblx0XHRcdCAgfVxuXHRcdFx0ICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuXHRcdFx0ICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG5cdFx0XHQgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuXHRcdFx0fTtcblx0XHQgIH1cblx0XHR9XG5cblx0XHRleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuXHRcdHJldHVybiBleHBvcnRzO1xuXHQgIH1cblxuXHQgIGlmIChmcmVlRXhwb3J0cyAmJiAhaXNMb2FkZXIpIHtcblx0XHQvLyBFeHBvcnQgZm9yIENvbW1vbkpTIGVudmlyb25tZW50cy5cblx0XHRydW5JbkNvbnRleHQocm9vdCwgZnJlZUV4cG9ydHMpO1xuXHQgIH0gZWxzZSB7XG5cdFx0Ly8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cblx0XHR2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcblx0XHRcdHByZXZpb3VzSlNPTiA9IHJvb3RbXCJKU09OM1wiXSxcblx0XHRcdGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuXHRcdHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuXHRcdCAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuXHRcdCAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG5cdFx0ICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKCFpc1Jlc3RvcmVkKSB7XG5cdFx0XHQgIGlzUmVzdG9yZWQgPSB0cnVlO1xuXHRcdFx0ICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuXHRcdFx0ICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG5cdFx0XHQgIG5hdGl2ZUpTT04gPSBwcmV2aW91c0pTT04gPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEpTT04zO1xuXHRcdCAgfVxuXHRcdH0pKTtcblxuXHRcdHJvb3QuSlNPTiA9IHtcblx0XHQgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG5cdFx0ICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcblx0XHR9O1xuXHQgIH1cblxuXHQgIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuXHQgIGlmIChpc0xvYWRlcikge1xuXHRcdGRlZmluZShmdW5jdGlvbiAoKSB7XG5cdFx0ICByZXR1cm4gSlNPTjM7XG5cdFx0fSk7XG5cdCAgfVxuXHR9KS5jYWxsKHRoaXMpO1xuXG5cdH0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHt9KVxuXHR9LHt9XSw1MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5cdG1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5cdGZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgaW5kZXgpIHtcblx0XHR2YXIgYXJyYXkgPSBbXVxuXG5cdFx0aW5kZXggPSBpbmRleCB8fCAwXG5cblx0XHRmb3IgKHZhciBpID0gaW5kZXggfHwgMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFycmF5XG5cdH1cblxuXHR9LHt9XX0se30sWzMxXSkoMzEpXG5cdH0pO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==